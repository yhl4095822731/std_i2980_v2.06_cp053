IMPORT_OVER_LISTFILE
 GET_SYNC_REFTO
, cLockGroupMoldHeight
, cLockGroupSafetyGateMold
, cLockGroupMotor
, cLockGroupRotateInjectPos
, cCompMoldNuts
, cMoveFwd
, cCompMold
, cCompTieBars
, cLockGroupNozzleFwd
, cMoveTarget
, tsTraceLevel
, tevStartRequest
, tyTieBarPosition
, tyTieBarStandStill
, tsDeviceId
, FBDebugTrace
, tevStartRequestData
, FBCheckReady
, FBStart
, FBCheckPosReached
, FBStop
, tsAlarm

END_IMPORT

ALGORITHM_BLOCK ABAdjust2Platen #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_bStandStillDetected : BOOL;
 sv_TraceLevel : tsTraceLevel;
 sv_rMoldPosOffset : REAL;
 sv_rMoldPosition : REAL;
 sv_rActMoldHeightPosition : REAL;
 sv_rReferencePosition : REAL;
 sv_rGrooveDistance : REAL;
 sv_rTieBarMinPos : REAL;
 sv_rTieBarMaxPos : REAL;
 sv_TieBarTargetPosition : tyTieBarPosition (* array with target position of the tiebars *);
 sv_TieBarReferencePosition : tyTieBarPosition (* array with reference position of the tiebars (= position where the locknuts could initially close) *);
 sv_bOpenMoldAfterAdjust : BOOL;
 sv_bUseSpringMold : BOOL;
 sv_dDelayBeforeNutsOpen : TIME (* delaytime between mold nuts close and mold nuts open (used for 2 platen IMM) *);
 sv_bSpringMoldStartPosReached : BOOL;
 sv_bFwdToStandStill : BOOL;
 sv_StandStillDetected : tyTieBarStandStill;
 sv_TieBarPosition : tyTieBarPosition (* array with actual position of the tiebars *);
 sv_bTBFwdStandStillDuringAdjust : BOOL (* TRUE: move tiebars forward until standstill during mold adjust procedure *);
END_VAR

SYSTEM_OBJECT
 evStartRequest : tevStartRequest;
 erMoldHeightAdjustFinished : ALARM;
 erMoldHeightAdjustAborted : ALARM;
END_OBJECT

ALGORITHM aRun


VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_TEMP
 i : INT;
END_VAR

VAR
 DeviceIdMold : tsDeviceId;
 DeviceIdLockNuts : tsDeviceId;
 DeviceIdTieBars : tsDeviceId;
 DeviceIdSpringMold : tsDeviceId;
 bFinished : BOOL;
 fbDebugTrace : FBDebugTrace;
 evStartRequestData : tevStartRequestData;
 fbCheckReady : FBCheckReady;
 dWaitTime : TIME := T#2s;
 fbStart : FBStart;
 fbCheckPosReached : FBCheckPosReached;
 bMoldOpenReady : BOOL;
 bMoldOpen : BOOL;
 fbStop : FBStop;
 rValue : REAL;
 iValue : INT;
 rDeltaPosition : REAL;
 bNutsClosed : BOOL;
 bMoldStopped : BOOL;
 Alarm : tsAlarm;
 bSpringMoldStarted : BOOL;
 rMoldLockTargetPosition : REAL;
 rMinTargetPosition : REAL;
 rTieBarMiddlePosition : REAL;
 bTBStandStillDetected : BOOL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
AInit (P);
END_STEP


(* steps *)
STEP S_MoldFwdStandstill:
aMoveMoldFwd (P);
aStartSpringMold (N);
aCheckMoldFwdReady (N);
END_STEP

STEP S_CheckStandstill:
END_STEP

STEP S_Trace:
ATrace (P);
END_STEP

STEP S_Wait:
aCalcMoldHeight (P);
END_STEP

STEP S_CalcLockPos:
A_CalcLockPos (P);
END_STEP

STEP S_TieBarsToTarget:
AMoveTieBarsToTarget (P);
ACheckTieBarsReady (N);
END_STEP

ACTION ACheckTieBarsReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdTieBars);

;#END_EDIT_BLOCK END_ACTION (*ACheckTieBarsReady*)
STEP S_CheckTieBarTarget:
ACheckTieBarTargetPos (P);
END_STEP

ACTION ACheckTieBarTargetPos: #BEGIN_EDIT_BLOCK
fbCheckPosReached(DeviceId := DeviceIdTieBars,
                  MoveDir := cMoveTarget,
                  MoveId := cMoveTieBarAll);
Alarm := fbCheckPosReached.Alarm;

;#END_EDIT_BLOCK END_ACTION (*ACheckTieBarTargetPos*)
STEP S_NotAtTarget:
ATieBarsNotAtTargetPos (P);
END_STEP

ACTION ATieBarsNotAtTargetPos: #BEGIN_EDIT_BLOCK
SET_ALARM(Name := Alarm.AlarmId);

;#END_EDIT_BLOCK END_ACTION (*ATieBarsNotAtTargetPos*)
STEP S_CloseNuts:
AStartNutsClose (P);
ACheckNutsClosed (N);
AStopSpringMold (P0);
END_STEP

ACTION ACheckNutsClosed: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdLockNuts);
fbCheckPosReached(DeviceId := DeviceIdLockNuts,
                  MoveDir := cMoveClose,
                  MoveId := cMoveClose,
                  bPosReached => bNutsClosed);

;#END_EDIT_BLOCK END_ACTION (*ACheckNutsClosed*)
ACTION AStopSpringMold: #BEGIN_EDIT_BLOCK
fbStop(DeviceId := DeviceIdSpringMold);

;#END_EDIT_BLOCK END_ACTION (*AStopSpringMold*)
STEP S_CheckNutsClosed:
ACheckNutsClosed2 (P);
END_STEP

ACTION ACheckNutsClosed2: #BEGIN_EDIT_BLOCK
IF NOT bNutsClosed THEN
   Alarm := fbCheckPosReached.Alarm;
   SET_ALARM(Name := Alarm.AlarmId);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckNutsClosed2*)
STEP S_TBFwdStandstill:
AStartFwdStandstill (P);
ACheckTieBarsFwdReady (N);
Action111 (P0);
END_STEP

ACTION ACheckTieBarsFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdTieBars);

;#END_EDIT_BLOCK END_ACTION (*ACheckTieBarsFwdReady*)
ACTION Action111: #BEGIN_EDIT_BLOCK
sv_bFwdToStandStill := FALSE;

;#END_EDIT_BLOCK END_ACTION (*Action111*)
STEP S_CheckStandStill:
ACheckStandStill (P);
END_STEP

STEP S_AdjustTargetPos:
AModifyTargetPositions (P);
END_STEP

STEP S_WaitDelay:
END_STEP

STEP S_OpenNuts:
AStartNutsOpen (P);
ACheckNutsOpen (N);
AStopSpringMoldBwd (P0);
END_STEP

ACTION ACheckNutsOpen: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdLockNuts);
fbCheckPosReached(DeviceId := DeviceIdLockNuts,
                  MoveDir := cMoveOpen,
                  MoveId := cMoveOpen);

;#END_EDIT_BLOCK END_ACTION (*ACheckNutsOpen*)
ACTION AStopSpringMoldBwd: #BEGIN_EDIT_BLOCK
fbStop(DeviceId := DeviceIdSpringMold);

;#END_EDIT_BLOCK END_ACTION (*AStopSpringMoldBwd*)
STEP S_NutsOpen:
END_STEP

STEP S_MoldOpen:
aOpenMold (P);
aCheckMoldOpen (N);
Action104 (P0);
END_STEP

ACTION Action104: #BEGIN_EDIT_BLOCK
IF bNutsClosed THEN
   bFinished := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*Action104*)
STEP S_NoMoldOpen:
ANoMoldOpen (P);
END_STEP

ACTION ANoMoldOpen: #BEGIN_EDIT_BLOCK
IF bNutsClosed THEN
   bFinished := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ANoMoldOpen*)
STEP S_NutsNotOpen:
ASetAlarmNutsNotOpen (P);
END_STEP

ACTION ASetAlarmNutsNotOpen: #BEGIN_EDIT_BLOCK
Alarm := fbCheckPosReached.Alarm;
SET_ALARM(Name := Alarm.AlarmId);

;#END_EDIT_BLOCK END_ACTION (*ASetAlarmNutsNotOpen*)
STEP S_Stop:
AStopMovements (P);
END_STEP

STEP S_Ready:
AReady (P);
END_STEP


(* transitions *)
TRANSITION TStart (* Trans1 *) FROM START TO S_MoldFwdStandstill :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoldCloseReady (* Trans111 *) FROM S_MoldFwdStandstill TO S_CheckStandstill :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStandstill (* Trans112 *) FROM S_CheckStandstill TO S_Wait :=  #BEGIN_EDIT_BLOCK
sv_bStandStillDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoStandstill (* Trans113 *) FROM S_CheckStandstill TO S_Trace :=  #BEGIN_EDIT_BLOCK
NOT sv_bStandStillDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans114 (* Trans114 *) FROM S_Trace TO S_Stop :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TWait (* Trans77 *) FROM S_Wait TO S_CalcLockPos :=  #BEGIN_EDIT_BLOCK
S_Wait.T > dWaitTime
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TLockPosCalculated (* Trans97 *) FROM S_CalcLockPos TO S_TieBarsToTarget :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans107 (* Trans107 *) FROM S_TieBarsToTarget TO S_CheckTieBarTarget :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND S_TieBarsToTarget.T > t#2.0s 
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPosReached (* Trans82 *) FROM S_CheckTieBarTarget TO S_CloseNuts :=  #BEGIN_EDIT_BLOCK
fbCheckPosReached.bPosReached
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TPosNotReached (* Trans119 *) FROM S_CheckTieBarTarget TO S_NotAtTarget :=  #BEGIN_EDIT_BLOCK
NOT fbCheckPosReached.bPosReached
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans120 (* Trans120 *) FROM S_NotAtTarget TO S_Stop :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNutsCloseReady (* Trans87 *) FROM S_CloseNuts TO S_CheckNutsClosed :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TFwdStandstill (* Trans121 *) FROM S_CheckNutsClosed TO S_TBFwdStandstill :=  #BEGIN_EDIT_BLOCK
sv_bTBFwdStandStillDuringAdjust
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TFwdStandStillReady (* Trans123 *) FROM S_TBFwdStandstill TO S_CheckStandStill :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStandStill (* Trans124 *) FROM S_CheckStandStill TO S_AdjustTargetPos :=  #BEGIN_EDIT_BLOCK
bTBStandStillDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPositionsAdjusted (* Trans126 *) FROM S_AdjustTargetPos TO S_WaitDelay :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoStandStill (* Trans125 *) FROM S_CheckStandStill TO S_Stop :=  #BEGIN_EDIT_BLOCK
NOT bTBStandStillDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoFwdToStandstill (* Trans122 *) FROM S_CheckNutsClosed TO S_WaitDelay :=  #BEGIN_EDIT_BLOCK
NOT sv_bTBFwdStandStillDuringAdjust
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TDelayOver (* Trans106 *) FROM S_WaitDelay TO S_OpenNuts :=  #BEGIN_EDIT_BLOCK
S_WaitDelay.T >= sv_dDelayBeforeNutsOpen
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNutsOpen (* Trans89 *) FROM S_OpenNuts TO S_NutsOpen :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
fbCheckPosReached.bPosReached
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoldOpen (* Trans103 *) FROM S_NutsOpen TO S_MoldOpen :=  #BEGIN_EDIT_BLOCK
sv_bOpenMoldAfterAdjust
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans118 (* Trans118 *) FROM S_MoldOpen TO S_Stop :=  #BEGIN_EDIT_BLOCK
bMoldOpenReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoMoldOpen (* Trans115 *) FROM S_NutsOpen TO S_NoMoldOpen :=  #BEGIN_EDIT_BLOCK
NOT sv_bOpenMoldAfterAdjust
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans117 (* Trans117 *) FROM S_NoMoldOpen TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNutsNotOpen (* Trans90 *) FROM S_OpenNuts TO S_NutsNotOpen :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
NOT fbCheckPosReached.bPosReached
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans91 (* Trans91 *) FROM S_NutsNotOpen TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TReady (* Trans32 *) FROM S_Stop TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans33 (* Trans33 *) FROM S_Ready TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION aOpenMold: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bMoldOpenReady := FALSE;
bMoldStopped := FALSE;

// Start the mold open movement
IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust: start mold open');
END_IF;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 

;#END_EDIT_BLOCK END_ACTION (*aOpenMold*)
ACTION aCheckMoldOpen: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// Check the status of mold open movement
// - Finished
// - PositionReached
fbCheckReady(DeviceId := DeviceIdMold,
             bReady => bMoldOpenReady);

fbCheckPosReached(DeviceId := DeviceIdMold,
                  MoveDir := cMoveBwd,
                  MoveId := cMoveBwd,
                  bPosReached => bMoldOpen);

IF bMoldOpen AND NOT bMoldStopped THEN
   fbStop(DeviceId := DeviceIdMold);
   bMoldStopped := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aCheckMoldOpen*)
ACTION aMoveMoldFwd: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust: start Mold forward until standstill');
END_IF;

//set offset to 0.0
//this way we make sure we do not move to negative position, which could cause error messages
sv_rMoldPosOffset := 0.0;

// Start the mold height forward movement
evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveFwd; 
evStartRequestData.MoveId := cMoveFwdForMHAdjust;
SET_EVENT(evStartRequest, evStartRequestData); 

;#END_EDIT_BLOCK END_ACTION (*aMoveMoldFwd*)
ACTION aCheckMoldFwdReady: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbCheckReady(DeviceId := DeviceIdMold);


;#END_EDIT_BLOCK END_ACTION (*aCheckMoldFwdReady*)
ACTION aCalcMoldHeight: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// mold height is identical with offset
sv_rMoldPosOffset := sv_rMoldPosition; 
sv_rActMoldHeightPosition := sv_rMoldPosition;

;#END_EDIT_BLOCK END_ACTION (*aCalcMoldHeight*)
ACTION A_CalcLockPos: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//check how many groove distances the mold is bigger than the init position
rValue := (sv_rActMoldHeightPosition - sv_rReferencePosition) / sv_rGrooveDistance;
iValue := TRUNC_TO_INT(rValue);

//calculate the delta position between the tiebar reference position
//and the next possible lock position
rDeltaPosition := (rValue - INT_TO_REAL(iValue)) * sv_rGrooveDistance;
rTieBarMiddlePosition := (sv_rTieBarMinPos + sv_rTieBarMaxPos) / 2.0;

FOR i := 1 TO 4 DO
   //get the min tiebar target position
   sv_TieBarTargetPosition[i] := sv_TieBarReferencePosition[i] + rDeltaPosition;       
   WHILE sv_TieBarTargetPosition[i] > sv_rTieBarMinPos DO
      sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] - sv_rGrooveDistance;
   END_WHILE;
   sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] + sv_rGrooveDistance;
   rMoldLockTargetPosition := sv_TieBarTargetPosition[i]; 
    
   //get the most middle tiebar target position 
   WHILE rMoldLockTargetPosition <= sv_rTieBarMaxPos DO
      IF ABS(sv_TieBarTargetPosition[i] - rTieBarMiddlePosition) > ABS(rMoldLockTargetPosition - rTieBarMiddlePosition) THEN
         sv_TieBarTargetPosition[i] := rMoldLockTargetPosition;
      END_IF;
      rMoldLockTargetPosition := rMoldLockTargetPosition + sv_rGrooveDistance;
   END_WHILE;       
END_FOR;

//set tiebar target positions as close as possible
rMinTargetPosition := MIN(sv_TieBarTargetPosition[1], sv_TieBarTargetPosition[2], sv_TieBarTargetPosition[3], sv_TieBarTargetPosition[4]);
FOR i := 1 TO 4 DO
   IF (sv_TieBarTargetPosition[i] - rMinTargetPosition) > (sv_rGrooveDistance / 2.0) THEN
      IF (sv_TieBarTargetPosition[i] - sv_rGrooveDistance) > sv_rTieBarMinPos THEN            
         sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] - sv_rGrooveDistance;     
      END_IF;
   END_IF;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*A_CalcLockPos*)
ACTION AStopMovements: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//stop active movement(s)
IF bStop OR NOT bFinished THEN
   fbStop(DeviceId := DeviceIdMold);
   fbStop(DeviceId := DeviceIdTieBars);
   fbStop(DeviceId := DeviceIdLockNuts);
   fbStop(DeviceId := DeviceIdSpringMold);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AStopMovements*)
ACTION AInit: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

DeviceIdMold.CompId := cCompMold;
DeviceIdMold.IndexId := 1;
DeviceIdLockNuts.CompId := cCompMoldNuts;
DeviceIdLockNuts.IndexId := 1;
DeviceIdTieBars.CompId := cCompTieBars;
DeviceIdTieBars.IndexId := 1;
DeviceIdSpringMold.CompId := cCompSpringMold;
DeviceIdSpringMold.IndexId := 1;

bReady := FALSE;
bFinished := FALSE;
bSpringMoldStarted := FALSE;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust started');
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AInit*)
ACTION AReady: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF bFinished THEN    
   SET_ALARM(erMoldHeightAdjustFinished);
ELSE
   SET_ALARM(erMoldHeightAdjustAborted);
END_IF;

bReady := TRUE;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust finished");
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AReady*)
ACTION AStartNutsClose: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start mold nuts close");
END_IF;

bNutsClosed := FALSE;

fbStart(DeviceId := DeviceIdLockNuts,
        MoveDir := cMoveClose,
        MoveId := cMoveClose);


;#END_EDIT_BLOCK END_ACTION (*AStartNutsClose*)
ACTION AStartNutsOpen: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseSpringMold THEN
   IF sv_TraceLevel.bApplication THEN   
      fbDebugTrace(sText := 'Mold Adjust: start Spring mold bwd');
   END_IF;
   
   fbStart(DeviceId := DeviceIdSpringMold,
        MoveDir := cMoveBwd,
        MoveId := cMoveBwd);
END_IF;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start mold nuts open");
END_IF;

fbStart(DeviceId := DeviceIdLockNuts,
        MoveDir := cMoveOpen,
        MoveId := cMoveOpen);

;#END_EDIT_BLOCK END_ACTION (*AStartNutsOpen*)
ACTION AMoveTieBarsToTarget: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start tie bar movement to target pos");
END_IF;

//move tiebars to the calculated target position
fbStart(DeviceId := DeviceIdTieBars,
        MoveDir := cMoveTarget,
        MoveId := cMoveTieBarAll);


;#END_EDIT_BLOCK END_ACTION (*AMoveTieBarsToTarget*)
ACTION ATrace: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: stop because no mold standstill detected");
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ATrace*)
ACTION aStartSpringMold: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseSpringMold AND sv_bSpringMoldStartPosReached AND NOT bSpringMoldStarted THEN
   //start spring mold after according position is reached
   IF sv_TraceLevel.bApplication THEN   
      fbDebugTrace(sText := 'Mold Adjust: start Spring mold fwd');
   END_IF;
   
   fbStart(DeviceId := DeviceIdSpringMold,
           MoveDir := cMoveFwd,
           MoveId := cMoveFwd);
   bSpringMoldStarted := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aStartSpringMold*)
ACTION AStartFwdStandstill: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start tie bar fwd to standstill");
END_IF;

sv_bFwdToStandStill := TRUE;

//move tiebars fwd until standstill is detected
fbStart(DeviceId := DeviceIdTieBars,
        MoveDir := cMoveFwd,
        MoveId := cMoveTieBarAll);

;#END_EDIT_BLOCK END_ACTION (*AStartFwdStandstill*)
ACTION ACheckStandStill: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bTBStandStillDetected := sv_StandStillDetected[1] AND sv_StandStillDetected[2] 
                         AND sv_StandStillDetected[3] AND sv_StandStillDetected[4];

;#END_EDIT_BLOCK END_ACTION (*ACheckStandStill*)
ACTION AModifyTargetPositions: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//The tiebars moved forward until standstill --> adjust target position 
//new target position = act. position + half of groove distance
FOR i := 1 TO 4 DO
   sv_TieBarTargetPosition[i] := sv_TieBarPosition[i] + (sv_rGrooveDistance / 2.0); 
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*AModifyTargetPositions*)

(* exits *)

EXIT_TRANSITION E_Stop := #BEGIN_EDIT_BLOCK
bStop AND NOT S_Stop.X AND NOT S_Ready.X
;#END_EDIT_BLOCK
PRIORITY 1 WITH  INITIAL_STEP S_Stop: END_STEP
END_TRANSITION
(* end sfc-code *)


END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 121 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
1 
@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
10 
@Var @RT(20)cLockGroupMoldHeight @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)66 @RT(8)Members: 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cLockGroupSafetyGateMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)61 @RT(73)Members: Mold Close, Mold Hight Forward, Auto Mold Hight, Core In, Inject 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cLockGroupMotor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)69 @RT(56)Members: Mold, Ejector, Cores, Injection, Plast, Purge,  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(25)cLockGroupRotateInjectPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)72 @RT(8)Members: 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cCompMoldNuts @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)159 @RT(40)Component MoldNuts (for 2 platten IMM´s) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)101 @RT(14)Component Mold 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cCompTieBars @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)160 @RT(39)Component TieBars (for 2 platten IMM´s) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cLockGroupNozzleFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)68 @RT(8)Members: 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)cMoveTarget @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)400 @RT(27)movement to target position 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(15)ABAdjust2Platen @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
22 
@Var @RT(22)sv_bStandStillDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @F @RT(12)tsTraceLevel @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rMoldPosOffset @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)evStartRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tevStartRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)sv_rMoldPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_rActMoldHeightPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rReferencePosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rGrooveDistance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rTieBarMinPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rTieBarMaxPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_TieBarTargetPosition @RT(0) @T @T @DERIVED 0 @F @RT(16)tyTieBarPosition @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)array with target position of the tiebars @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_TieBarReferencePosition @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tyTieBarPosition @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(98)array with reference position of the tiebars (= position where the locknuts could initially close) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bOpenMoldAfterAdjust @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)erMoldHeightAdjustFinished @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)erMoldHeightAdjustAborted @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)sv_bUseSpringMold @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_dDelayBeforeNutsOpen @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(76)delaytime between mold nuts close and mold nuts open (used for 2 platen IMM) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_bSpringMoldStartPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bFwdToStandStill @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_StandStillDetected @RT(0) @T @T @DERIVED 0 @F @RT(18)tyTieBarStandStill @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_TieBarPosition @RT(0) @T @T @DERIVED 0 @F @RT(16)tyTieBarPosition @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)array with actual position of the tiebars @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(31)sv_bTBFwdStandStillDuringAdjust @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(72)TRUE: move tiebars forward until standstill during mold adjust procedure @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

1 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
28 
@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)DeviceIdMold @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)DeviceIdLockNuts @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)DeviceIdTieBars @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)DeviceIdSpringMold @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bFinished @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)evStartRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevStartRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbCheckReady @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBCheckReady @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)dWaitTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)T#2s @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)fbStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)FBStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bMoldOpenReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bMoldOpen @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)fbStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)FBStop @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)iValue @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)rDeltaPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)bNutsClosed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMoldStopped @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Alarm @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)tsAlarm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bSpringMoldStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)rMoldLockTargetPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)rMinTargetPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)rTieBarMiddlePosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)bTBStandStillDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_SfcBody 
115 79 127 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 25 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)AInit @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(6)TStart @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)Trans1 @F 
@Step @RT(19)S_MoldFwdStandstill @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(12)aMoveMoldFwd @F @F @RT(1)P @RT(0) @F @F @T @F 
@Acb @RT(16)aStartSpringMold @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)aCheckMoldFwdReady @F @F @RT(1)N @RT(0) @F @F @T @F 

@Trans @RT(15)TMoldCloseReady @F @T @F @F @T @T @TL(2)
fbCheckReady.bReady

@RT(8)Trans111 @F 
@Step @RT(17)S_CheckStandstill @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(11)TStandstill @F @T @F @F @T @F @TL(2)
sv_bStandStillDetected

@RT(8)Trans112 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(13)TNoStandstill @F @T @F @F @T @F @TL(2)
NOT sv_bStandStillDetected

@RT(8)Trans113 @F 
@Step @RT(7)S_Trace @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)ATrace @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(8)Trans114 @F @T @F @F @T @F @TL(2)
TRUE

@RT(8)Trans114 @F 
@Goto @RT(6)S_Stop @F @F 


@Step @RT(6)S_Wait @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)aCalcMoldHeight @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(5)TWait @F @T @F @F @T @F @TL(2)
S_Wait.T > dWaitTime

@RT(7)Trans77 @F 
@Step @RT(13)S_CalcLockPos @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)A_CalcLockPos @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(18)TLockPosCalculated @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans97 @F 
@Step @RT(17)S_TieBarsToTarget @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(20)AMoveTieBarsToTarget @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(18)ACheckTieBarsReady @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdTieBars);

@F 

@Trans @RT(8)Trans107 @F @T @F @F @T @F @TL(2)
fbCheckReady.bReady AND S_TieBarsToTarget.T > t#2.0s 

@RT(8)Trans107 @F 
@Step @RT(19)S_CheckTieBarTarget @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(21)ACheckTieBarTargetPos @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
fbCheckPosReached(DeviceId := DeviceIdTieBars,
                  MoveDir := cMoveTarget,
                  MoveId := cMoveTieBarAll);
Alarm := fbCheckPosReached.Alarm;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(11)TPosReached @F @T @F @F @T @F @TL(2)
fbCheckPosReached.bPosReached

@RT(7)Trans82 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(14)TPosNotReached @F @T @F @F @T @T @TL(2)
NOT fbCheckPosReached.bPosReached

@RT(8)Trans119 @F 
@Step @RT(13)S_NotAtTarget @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)ATieBarsNotAtTargetPos @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
SET_ALARM(Name := Alarm.AlarmId);

@F 

@Trans @RT(8)Trans120 @F @T @F @F @T @F @TL(2)
TRUE

@RT(8)Trans120 @F 
@Goto @RT(6)S_Stop @F @F 


@Step @RT(11)S_CloseNuts @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(15)AStartNutsClose @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckNutsClosed @F @T @RT(1)N @RT(0) @F @F @T @TL(6)
fbCheckReady(DeviceId := DeviceIdLockNuts);
fbCheckPosReached(DeviceId := DeviceIdLockNuts,
                  MoveDir := cMoveClose,
                  MoveId := cMoveClose,
                  bPosReached => bNutsClosed);

@F 
@Acb @RT(15)AStopSpringMold @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
fbStop(DeviceId := DeviceIdSpringMold);

@F 

@Trans @RT(15)TNutsCloseReady @F @T @F @F @T @F @TL(2)
fbCheckReady.bReady

@RT(7)Trans87 @F 
@Step @RT(17)S_CheckNutsClosed @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)ACheckNutsClosed2 @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
IF NOT bNutsClosed THEN
   Alarm := fbCheckPosReached.Alarm;
   SET_ALARM(Name := Alarm.AlarmId);
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 5 
@Trans @RT(14)TFwdStandstill @F @T @F @F @T @F @TL(2)
sv_bTBFwdStandStillDuringAdjust

@RT(8)Trans121 @F 
@Step @RT(17)S_TBFwdStandstill @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(19)AStartFwdStandstill @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(21)ACheckTieBarsFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdTieBars);

@F 
@Acb @RT(9)Action111 @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
sv_bFwdToStandStill := FALSE;

@F 

@Trans @RT(19)TFwdStandStillReady @F @T @F @F @T @F @TL(2)
fbCheckReady.bReady

@RT(8)Trans123 @F 
@Step @RT(17)S_CheckStandStill @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)ACheckStandStill @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(11)TStandStill @F @T @F @F @T @F @TL(2)
bTBStandStillDetected

@RT(8)Trans124 @F 
@Step @RT(17)S_AdjustTargetPos @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)AModifyTargetPositions @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(18)TPositionsAdjusted @F @T @F @F @T @F @TL(2)
TRUE

@RT(8)Trans126 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(13)TNoStandStill @F @T @F @F @T @F @TL(2)
NOT bTBStandStillDetected

@RT(8)Trans125 @F 
@Goto @RT(6)S_Stop @F @F 



@TransSeq @RT(4)tseq @F 1 
@Trans @RT(18)TNoFwdToStandstill @F @T @T @F @T @F @TL(2)
NOT sv_bTBFwdStandStillDuringAdjust

@RT(8)Trans122 @F 


@Step @RT(11)S_WaitDelay @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(10)TDelayOver @F @T @F @F @T @F @TL(2)
S_WaitDelay.T >= sv_dDelayBeforeNutsOpen

@RT(8)Trans106 @F 
@Step @RT(10)S_OpenNuts @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(14)AStartNutsOpen @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)ACheckNutsOpen @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := DeviceIdLockNuts);
fbCheckPosReached(DeviceId := DeviceIdLockNuts,
                  MoveDir := cMoveOpen,
                  MoveId := cMoveOpen);

@F 
@Acb @RT(18)AStopSpringMoldBwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
fbStop(DeviceId := DeviceIdSpringMold);

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNutsOpen @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
fbCheckPosReached.bPosReached

@RT(7)Trans89 @F 
@Step @RT(10)S_NutsOpen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TMoldOpen @F @T @F @F @T @F @TL(2)
sv_bOpenMoldAfterAdjust

@RT(8)Trans103 @F 
@Step @RT(10)S_MoldOpen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(9)aOpenMold @F @F @RT(1)P @RT(0) @F @F @T @F 
@Acb @RT(14)aCheckMoldOpen @F @F @RT(1)N @RT(0) @F @F @T @F 
@Acb @RT(9)Action104 @F @T @RT(2)P0 @RT(0) @F @F @T @TL(4)
IF bNutsClosed THEN
   bFinished := TRUE;
END_IF;

@F 

@Trans @RT(8)Trans118 @F @T @F @F @T @T @TL(2)
bMoldOpenReady

@RT(8)Trans118 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(11)TNoMoldOpen @F @T @F @F @T @F @TL(2)
NOT sv_bOpenMoldAfterAdjust

@RT(8)Trans115 @F 
@Step @RT(12)S_NoMoldOpen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(11)ANoMoldOpen @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
IF bNutsClosed THEN
   bFinished := TRUE;
END_IF;

@F 

@Trans @RT(8)Trans117 @F @T @F @F @T @F @TL(2)
TRUE

@RT(8)Trans117 @F 
@Goto @RT(7)S_Ready @F @F 



@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TNutsNotOpen @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
NOT fbCheckPosReached.bPosReached

@RT(7)Trans90 @F 
@Step @RT(13)S_NutsNotOpen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(20)ASetAlarmNutsNotOpen @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
Alarm := fbCheckPosReached.Alarm;
SET_ALARM(Name := Alarm.AlarmId);

@F 

@Trans @RT(7)Trans91 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans91 @F 
@Goto @RT(7)S_Ready @F @F 


@Step @RT(6)S_Stop @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(14)AStopMovements @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(6)TReady @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans32 @F 
@Step @RT(7)S_Ready @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @F @RT(1)P @RT(0) @F @F @F @F 


@Trans @RT(7)Trans33 @F @T @T @T @T @T @TL(2)
TRUE

@RT(7)Trans33 @F 

@END_SfcData 
@SaActions 17 
@SaText @RT(9)aOpenMold 1 @TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bMoldOpenReady := FALSE;
bMoldStopped := FALSE;

// Start the mold open movement
IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust: start mold open');
END_IF;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 


@SaText @RT(14)aCheckMoldOpen 1 @TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// Check the status of mold open movement
// - Finished
// - PositionReached
fbCheckReady(DeviceId := DeviceIdMold,
             bReady => bMoldOpenReady);

fbCheckPosReached(DeviceId := DeviceIdMold,
                  MoveDir := cMoveBwd,
                  MoveId := cMoveBwd,
                  bPosReached => bMoldOpen);

IF bMoldOpen AND NOT bMoldStopped THEN
   fbStop(DeviceId := DeviceIdMold);
   bMoldStopped := TRUE;
END_IF;


@SaText @RT(12)aMoveMoldFwd 1 @TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust: start Mold forward until standstill');
END_IF;

//set offset to 0.0
//this way we make sure we do not move to negative position, which could cause error messages
sv_rMoldPosOffset := 0.0;

// Start the mold height forward movement
evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveFwd; 
evStartRequestData.MoveId := cMoveFwdForMHAdjust;
SET_EVENT(evStartRequest, evStartRequestData); 


@SaText @RT(18)aCheckMoldFwdReady 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbCheckReady(DeviceId := DeviceIdMold);



@SaText @RT(15)aCalcMoldHeight 1 @TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// mold height is identical with offset
sv_rMoldPosOffset := sv_rMoldPosition; 
sv_rActMoldHeightPosition := sv_rMoldPosition;


@SaText @RT(13)A_CalcLockPos 1 @TL(42)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//check how many groove distances the mold is bigger than the init position
rValue := (sv_rActMoldHeightPosition - sv_rReferencePosition) / sv_rGrooveDistance;
iValue := TRUNC_TO_INT(rValue);

//calculate the delta position between the tiebar reference position
//and the next possible lock position
rDeltaPosition := (rValue - INT_TO_REAL(iValue)) * sv_rGrooveDistance;
rTieBarMiddlePosition := (sv_rTieBarMinPos + sv_rTieBarMaxPos) / 2.0;

FOR i := 1 TO 4 DO
   //get the min tiebar target position
   sv_TieBarTargetPosition[i] := sv_TieBarReferencePosition[i] + rDeltaPosition;       
   WHILE sv_TieBarTargetPosition[i] > sv_rTieBarMinPos DO
      sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] - sv_rGrooveDistance;
   END_WHILE;
   sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] + sv_rGrooveDistance;
   rMoldLockTargetPosition := sv_TieBarTargetPosition[i]; 
    
   //get the most middle tiebar target position 
   WHILE rMoldLockTargetPosition <= sv_rTieBarMaxPos DO
      IF ABS(sv_TieBarTargetPosition[i] - rTieBarMiddlePosition) > ABS(rMoldLockTargetPosition - rTieBarMiddlePosition) THEN
         sv_TieBarTargetPosition[i] := rMoldLockTargetPosition;
      END_IF;
      rMoldLockTargetPosition := rMoldLockTargetPosition + sv_rGrooveDistance;
   END_WHILE;       
END_FOR;

//set tiebar target positions as close as possible
rMinTargetPosition := MIN(sv_TieBarTargetPosition[1], sv_TieBarTargetPosition[2], sv_TieBarTargetPosition[3], sv_TieBarTargetPosition[4]);
FOR i := 1 TO 4 DO
   IF (sv_TieBarTargetPosition[i] - rMinTargetPosition) > (sv_rGrooveDistance / 2.0) THEN
      IF (sv_TieBarTargetPosition[i] - sv_rGrooveDistance) > sv_rTieBarMinPos THEN            
         sv_TieBarTargetPosition[i] := sv_TieBarTargetPosition[i] - sv_rGrooveDistance;     
      END_IF;
   END_IF;
END_FOR;


@SaText @RT(14)AStopMovements 1 @TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//stop active movement(s)
IF bStop OR NOT bFinished THEN
   fbStop(DeviceId := DeviceIdMold);
   fbStop(DeviceId := DeviceIdTieBars);
   fbStop(DeviceId := DeviceIdLockNuts);
   fbStop(DeviceId := DeviceIdSpringMold);
END_IF;


@SaText @RT(5)AInit 1 @TL(24)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

DeviceIdMold.CompId := cCompMold;
DeviceIdMold.IndexId := 1;
DeviceIdLockNuts.CompId := cCompMoldNuts;
DeviceIdLockNuts.IndexId := 1;
DeviceIdTieBars.CompId := cCompTieBars;
DeviceIdTieBars.IndexId := 1;
DeviceIdSpringMold.CompId := cCompSpringMold;
DeviceIdSpringMold.IndexId := 1;

bReady := FALSE;
bFinished := FALSE;
bSpringMoldStarted := FALSE;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace(sText := 'Mold Adjust started');
END_IF;




@SaText @RT(6)AReady 1 @TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF bFinished THEN    
   SET_ALARM(erMoldHeightAdjustFinished);
ELSE
   SET_ALARM(erMoldHeightAdjustAborted);
END_IF;

bReady := TRUE;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust finished");
END_IF;


@SaText @RT(15)AStartNutsClose 1 @TL(16)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start mold nuts close");
END_IF;

bNutsClosed := FALSE;

fbStart(DeviceId := DeviceIdLockNuts,
        MoveDir := cMoveClose,
        MoveId := cMoveClose);



@SaText @RT(14)AStartNutsOpen 1 @TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseSpringMold THEN
   IF sv_TraceLevel.bApplication THEN   
      fbDebugTrace(sText := 'Mold Adjust: start Spring mold bwd');
   END_IF;
   
   fbStart(DeviceId := DeviceIdSpringMold,
        MoveDir := cMoveBwd,
        MoveId := cMoveBwd);
END_IF;

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start mold nuts open");
END_IF;

fbStart(DeviceId := DeviceIdLockNuts,
        MoveDir := cMoveOpen,
        MoveId := cMoveOpen);


@SaText @RT(20)AMoveTieBarsToTarget 1 @TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start tie bar movement to target pos");
END_IF;

//move tiebars to the calculated target position
fbStart(DeviceId := DeviceIdTieBars,
        MoveDir := cMoveTarget,
        MoveId := cMoveTieBarAll);



@SaText @RT(6)ATrace 1 @TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: stop because no mold standstill detected");
END_IF;


@SaText @RT(16)aStartSpringMold 1 @TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseSpringMold AND sv_bSpringMoldStartPosReached AND NOT bSpringMoldStarted THEN
   //start spring mold after according position is reached
   IF sv_TraceLevel.bApplication THEN   
      fbDebugTrace(sText := 'Mold Adjust: start Spring mold fwd');
   END_IF;
   
   fbStart(DeviceId := DeviceIdSpringMold,
           MoveDir := cMoveFwd,
           MoveId := cMoveFwd);
   bSpringMoldStarted := TRUE;
END_IF;


@SaText @RT(19)AStartFwdStandstill 1 @TL(16)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bApplication THEN   
   fbDebugTrace("Mold Adjust: start tie bar fwd to standstill");
END_IF;

sv_bFwdToStandStill := TRUE;

//move tiebars fwd until standstill is detected
fbStart(DeviceId := DeviceIdTieBars,
        MoveDir := cMoveFwd,
        MoveId := cMoveTieBarAll);


@SaText @RT(16)ACheckStandStill 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bTBStandStillDetected := sv_StandStillDetected[1] AND sv_StandStillDetected[2] 
                         AND sv_StandStillDetected[3] AND sv_StandStillDetected[4];


@SaText @RT(22)AModifyTargetPositions 1 @TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//The tiebars moved forward until standstill --> adjust target position 
//new target position = act. position + half of groove distance
FOR i := 1 TO 4 DO
   sv_TieBarTargetPosition[i] := sv_TieBarPosition[i] + (sv_rGrooveDistance / 2.0); 
END_FOR;


@SaTrans 0 
@SaExits 1 
@SaExit @SaText @RT(6)E_Stop 1 @TL(2)
bStop AND NOT S_Stop.X AND NOT S_Ready.X

@RT(6)S_Stop @RT(1)1 @F @F @SaSfc @RT(6)E_Stop 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(6)Step68 @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action95 @F @F @RT(1)N @RT(0) @F @F @T @F 

@Trans @RT(8)Trans109 @F @T @T @F @T @T @TL(2)
(*inl.*)

@RT(8)Trans109 @F 
@Goto @RT(9)unlabeled @F @F 
@END_SfcData 

@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
