IMPORT_OVER_LISTFILE
 GET_SYNC_REFTO
, IS_LINKED
, WRITE_SV_DIRECT
, WRITE_SVREAL_DIRECT
, cMoveAll
, ABValveController
, FBICMProfile
, tsMoveData
, tsMoveCtrl
, KAPPL_VisProfile
, tsControlParameters
, KCTRL_PIDT1
, tServoValveConstructionData
, tsToggleLeverSplineData
, tServoValveControlData
, tnICMActivateMode
, tServoValveData
, tnICMMode
, KCTRL_PIDT1_Param
, KAPPL_LintabData
, ABLintabApply
, tsMinOutput
, tsActTimes
, tsHydrMaxValues
, ABMovementRegister
, KSWO_Status
, FBSetMovementState
, FBDebugTrace2
, ABEstimatePressure
, TON
, KCTRL_PTN
, KCTRL_PTN_Param
, KCTRL_Ret

END_IMPORT

ALGORITHM_BLOCK ABMoveVenting #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_rMoldPressure1 : REAL (* pressure mold fwd *);
 sv_rMoldPressure2 : REAL (* pressure mold bwd *);
 sv_MoveVenting : tsMoveData;
 sv_bVentingActive : BOOL (* venting is active *);
 sv_bVentingDone : BOOL;
 sv_rMoldValveOutput : REAL;
 sv_rMaxPlausFirstCoiningStage : REAL;
 sv_rVentingClampForceRamp : REAL (* clamp force ramp  *);
 sv_rVentingPosRamp : REAL (* acceleration mm/s/s *);
 sv_VentingPosVis : KAPPL_VisProfile (* venting pos visualization *);
 sv_VentingForceVis : KAPPL_VisProfile (* ventin force visualization *);
 sv_ForceControlParam : tsControlParameters (* PID - parameters for pressure control *);
 sv_rToggleLeverStroke : REAL (* Opening Stroke of toggle lever *);
 sv_rToggleLeverVelEstimate : REAL;
 sv_rToggleLeverPosition : REAL;
 sv_rClampForceAct : REAL;
 sv_ConstructionData : tServoValveConstructionData;
 sv_ToggleLeverSplineData : tsToggleLeverSplineData;
 sv_ServoValveControlData : tServoValveControlData;
 sv_rMaxSpeedBwd : REAL;
 sv_rVelOutputICM : REAL (* pump output ICM *);
 sv_bOutputActive : BOOL;
 sv_bFwdActive : BOOL;
 sv_bBwdActive : BOOL;
 sv_bInitDone : BOOL;
 sv_CoiningActivateMode : tnICMActivateMode;
 sv_VentingActivateMode : tnICMActivateMode;
 sv_bUseInjectPressVenting : BOOL;
 sv_bUseInjectPosVenting : BOOL;
 sv_bUseDelayTimeVenting : BOOL;
 sv_rMaxSpeedFwd : REAL;
 sv_ValveData : tServoValveData;
 sv_ICMMode : tnICMMode;
 sv_rVelocityAbs : REAL;
 sv_bPreOutputReady : BOOL;
 sv_rVelocity : REAL;
 sv_rPressure : REAL;
 sv_rSetMoldStartPosition : REAL;
 sv_rMoldStroke : REAL;
 sv_ToggleLeverLintab : KAPPL_LintabData (* toggle lever lintab *);
 sv_VentingPos : KAPPL_VisProfile (* venting pos profile *);
 sv_MinOutputFwd : tsMinOutput;
 sv_MinOutputBwd : tsMinOutput;
 sv_MoldVentingTimesAct : tsActTimes;
 sv_rMinOutputVelVenting : REAL (* min output velocity for venting *);
 sv_HydrMaxValuesClose : tsHydrMaxValues (* hydraulic max values for mold close *);
 sv_HydrMaxValuesOpen : tsHydrMaxValues (* hydraulic max values for mold open *);
END_VAR

SYSTEM_OBJECT
 TaskSlow : TASK;
 TaskAnalog : TASK;
 PU_Task_7 : TASK;
END_OBJECT

VAR_EXTERNAL
 g_bClampPressSensorsAvailable : BOOL;
 g_bMoldValve : BOOL;
 g_bPressureSensor1Available : BOOL;
 g_bPressureSensor2Available : BOOL;
 g_bPressureSensorsAvailable : BOOL;
 g_MoveCtrl : tsMoveCtrl;
 pSysPressure : REFTO REAL;
END_VAR

VAR
 abValveController : ABValveController;
 fbClampForceProfile : FBICMProfile;
 bStart : BOOL;
 mrSetPosProfileVenting : REAL;
 mbVentingActive : BOOL;
 mrSetClampForceProfileVenting : REAL;
 mrSetVelProfileVenting : REAL;
 mrSetAccProfileVenting : REAL;
 fbPositionProfile : FBICMProfile;
 fbPIDControllerForce : KCTRL_PIDT1 (* proportion regulator for velocity *);
 rOffsetPos : REAL := 1.0;
 rOffsetNeg : REAL := -1.2;
 rTankPressure : REAL := 1.0;
 mrSetPos : REAL (* Set position for valve controller *);
 mrSetVel : REAL (* Set velocity for valve controller *);
 mrUCtrlForce : REAL;
 mrUCtrlForceP : REAL;
 mrUCtrlForceI : REAL;
 pidParamForce : KCTRL_PIDT1_Param;
 mrFilteredClampForceVenting : REAL;
 mrPosProfileLimitMin : REAL;
 abLintabApplyToggleLever : ABLintabApply;
END_VAR

ALGORITHM aRegister


VAR
 abMoveVentingRegister : ABMovementRegister;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration                                                   
sv_MoveVenting.pdActiveTimeAct := @sv_MoldVentingTimesAct.dActMoveTime;   

sv_MoveVenting.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveVenting.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveVenting.LockGroups[3] := cLockGroupMotor;
sv_MoveVenting.LockGroups[4] := cLockGroupRotateInjectPos;
sv_MoveVenting.pbPosReached := @sv_bVentingDone;     
sv_MoveVenting.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movVenting.gif");  

abMoveVentingRegister.aRegister(@sv_MoveVenting);



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();

variableName := CONCAT(fuName,'.Control.rSetPosVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPosProfileVenting);
variableName := CONCAT(fuName,'.Control.rSetVelVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVel);
variableName := CONCAT(fuName,'.Control.rSetVelVentingOrig');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelProfileVenting);

variableName := CONCAT(fuName,'.Control.rSetAccVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetAccProfileVenting);
variableName := CONCAT(fuName,'.Control.rSetClampForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetClampForceProfileVenting);
variableName := CONCAT(fuName,'.Control.rFilteredClampForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrFilteredClampForceVenting);
variableName := CONCAT(fuName,'.Control.bVentingActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bVentingActive);
variableName := CONCAT(fuName,'.Control.rClampForceAct');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rClampForceAct);
variableName := CONCAT(fuName,'.Control.rSetPosForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPos);

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_TEMP
 rVelOutputICM : REAL;
 rMoldValveOutput : REAL;
 b : BOOL;
 rVelocity : REAL;
END_VAR

VAR
 fbSetMovementState : FBSetMovementState;
 fbDebugTrace2 : FBDebugTrace2;
 rOutput : REAL;
 dCycleTime : TIME;
 rSetVelocity : REAL;
 rQNom : REAL;
 rPNom : REAL;
 rQNomPB : REAL;
 rPNomPB : REAL;
 rPressure1 : REAL;
 rPressure2 : REAL;
 abEstimatePressure : ABEstimatePressure;
 fbTON : TON (* ICM *);
 rTimer : REAL (* ICM *);
 cycleTime : TIME := T#6ms;
 PTN : KCTRL_PTN;
 ParamPTN : KCTRL_PTN_Param := (uN:=1,rK:=1.0,dT1:=T#100ms);
 parStatus : KCTRL_Ret;
 calcStatus : KCTRL_Ret;
 rInit : REAL;
 rGainOpenLoopBwd : REAL;
 rGainOpenLoopFwd : REAL;
 rGainP : REAL;
 bOldFwdActive : BOOL;
 bPosError : BOOL;
 rMaxSpeedVenting : REAL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
aStart (N);
END_STEP

ACTION aStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nActive);

sv_bVentingActive := TRUE;        
sv_bVentingDone := FALSE;

fbDebugTrace2(nDeviceState, 'Venting started');

;#END_EDIT_BLOCK END_ACTION (*aStart*)

(* steps *)
STEP S_ProfileVenting:
AInitProfileOutput (P);
AInitValveController (P);
AInitClampForceController (P);
AProfileOutput (N);
AUpdateCalcValveController (N);
ACalcClampForceController (N);
ACalcValveController (N);
ACalcPumpOutput (N);
END_STEP

STEP READY:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
  sv_rMoldValveOutput := 0.0;
END_IF;

bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nInactive);

sv_bOutputActive := FALSE;   

IF NOT bStop THEN   
   sv_bVentingDone := TRUE;                 
END_IF;

sv_bVentingActive := FALSE;
sv_bFwdActive := FALSE;
sv_bBwdActive := FALSE;  

fbDebugTrace2(nDeviceState, 'Venting ready');

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
TRANSITION Trans4 (* Trans4 *) FROM START TO S_ProfileVenting :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TProfileMoveReady (* TProfileMoveReady2 *) FROM S_ProfileVenting TO READY :=  #BEGIN_EDIT_BLOCK
NOT mbVentingActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans7 (* Trans7 *) FROM READY TO START :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION ACalcValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := mrSetPosProfileVenting*1.0e-3,
                                 rSetVel    := mrSetVelProfileVenting*1.0e-3,
                                 rSetAccel  := mrSetAccProfileVenting*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := mrSetPosProfileVenting*1.0e-3,
                                 rSetVel    := mrSetVelProfileVenting*1.0e-3,
                                 rSetAccel  := mrSetAccProfileVenting*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;                                  
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := mrSetPos*1.0e-3,     
                             rSetVelocity := mrSetVel*1.0e-3,      
                             rSetAcceleration := 0.0,
                             rSetJerk := 0.0,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
       
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);         
      ELSE
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, 0.0);         
      END_IF;
 
      bStart := FALSE;
    ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);                
    END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACalcValveController*)
ACTION ACalcClampForceController: #BEGIN_EDIT_BLOCK
IF NOT g_bClampPressSensorsAvailable THEN   
   //Only position controller available without force sensor 
   mrSetPos := mrSetPosProfileVenting; 
   mrSetVel := mrSetVelProfileVenting;
ELSE 
   sv_bOutputActive := TRUE;   

   //pid controller of clamp force 
   fbPIDControllerForce.Calculate(rActVal:= sv_rClampForceAct,
                                  rSetVal:= mrFilteredClampForceVenting,
                                  bEnable:= TRUE);
   //Control value
   mrUCtrlForce := fbPIDControllerForce.Calculate.rOutVal;
      
   //Pos limiter
   mrPosProfileLimitMin := LIMIT(0.0, (sv_rToggleLeverPosition - mrUCtrlForce), sv_rMoldStroke); 
   mrSetPos := LIMIT(mrPosProfileLimitMin, mrSetPosProfileVenting, sv_rMoldStroke);  

   //Monitoring the P- and I-Part 
   fbPIDControllerForce.GetActValues(rUProp => mrUCtrlForceP,
                                        rUInt => mrUCtrlForceI);
   //set velocity 
   IF (mrSetPos <> mrSetPosProfileVenting) THEN
      //force in limitation
      mrSetVel := 0.0;                        
   ELSE 
      IF mrSetVelProfileVenting > 0.0 THEN
         mrSetVel := rGainOpenLoopBwd * mrSetVelProfileVenting;
      ELSE 
         mrSetVel := rGainOpenLoopFwd * mrSetVelProfileVenting;
       END_IF;                                   
   END_IF;       
END_IF;          


;#END_EDIT_BLOCK END_ACTION (*ACalcClampForceController*)
ACTION AInitValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF g_bPressureSensorsAvailable THEN
     
      dCycleTime := GET_TASK_INTERVAL();
    
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
       
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                            bPositionIncreasing := TRUE);
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;    
   END_IF;
   bStart := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitValveController*)
ACTION AInitClampForceController: #BEGIN_EDIT_BLOCK
IF g_bClampPressSensorsAvailable THEN

   //Controller parameters
   dCycleTime := GET_TASK_INTERVAL();
   pidParamForce.rKR := sv_ForceControlParam.rP;
   pidParamForce.dTN := sv_ForceControlParam.dTN;
   pidParamForce.dTV := sv_ForceControlParam.dTV;
   pidParamForce.rKS := sv_ForceControlParam.rKS;

   //Limitation of control value
   pidParamForce.rUMax := sv_rMoldStroke;
   pidParamForce.rUMin := -sv_rMoldStroke;       

   //Parameterize pid controller
   fbPIDControllerForce.Par(dCycleTime := dCycleTime,
                            Param := pidParamForce);               
   //Initialization of pid controller        
   fbPIDControllerForce.Init(rActVal := 0.0,
                             rSetVal := 0.0,
                             rOpenLoopSetVal := 0.0,
                             rOutVal := 0.0);
   mrUCtrlForce := 0.0;
   mrUCtrlForceI := 0.0; 
   mrUCtrlForceP := 0.0;  
    
   rGainOpenLoopFwd := sv_ServoValveControlData.rGainOpenLoopFwd; 
   rGainOpenLoopBwd := sv_ServoValveControlData.rGainOpenLoopBwd; 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitClampForceController*)
ACTION AProfileOutput: #BEGIN_EDIT_BLOCK
//timer
fbTON(IN := TRUE);               
rTimer := LINT_TO_REAL(TIME_TO_LINT(fbTON.ET)) / 1000000.0;

//postion output
fbPositionProfile(bStart := TRUE,
                  bStop := bStop,
                  rAcceleration := sv_rVentingPosRamp,
                  bTimeModeVisu := TRUE,                     
                  ProfileICM := sv_VentingPos,
                  rTimer := rTimer,
                  rSetPos => mrSetPosProfileVenting,
                  rSetVel => mrSetVelProfileVenting,
                  rSetAcc => mrSetAccProfileVenting);

//clamp force output
fbClampForceProfile(bStart := TRUE,
                    bStop := bStop,
                    rAcceleration := sv_rVentingClampForceRamp,
                    bTimeModeVisu := TRUE,
                    ProfileICM := sv_VentingForceVis,
                    rTimer := rTimer,
                    rSetPos => mrSetClampForceProfileVenting);

//Filter PT1
PTN.Calculate(rInVal := mrSetClampForceProfileVenting, 
              rOutVal => mrFilteredClampForceVenting, 
              calcStatus => calcStatus);

//valve direction
IF fbPositionProfile.rAlgebraSign = 1.0 THEN
   sv_bFwdActive := FALSE;
   sv_bBwdActive := TRUE;                                
   rMaxSpeedVenting := sv_rMaxSpeedBwd; 
ELSIF fbPositionProfile.rAlgebraSign = -1.0 THEN
   sv_bFwdActive := TRUE;
   sv_bBwdActive := FALSE; 
   rMaxSpeedVenting := sv_rMaxSpeedFwd;                 
END_IF;

//Calculation of pump output
IF rMaxSpeedVenting = 0.0 THEN
   rMaxSpeedVenting:= 1.0; 
END_IF;

rVelOutputICM := ABS (mrSetVelProfileVenting / rMaxSpeedVenting * 100.0);
b := WRITE_SVREAL_DIRECT(sv_rVelOutputICM, rVelOutputICM);

mbVentingActive := (NOT fbPositionProfile.bReady)
                           AND (NOT fbClampForceProfile.bReady); 
                           
b := WRITE_SV_DIRECT(sv_MoldVentingTimesAct.dActMoveTime, fbTON.ET);

sv_bPreOutputReady := TRUE;
sv_bOutputActive := mbVentingActive;  



;#END_EDIT_BLOCK END_ACTION (*AProfileOutput*)
ACTION AInitProfileOutput: #BEGIN_EDIT_BLOCK
//Initialize timer to build profile
fbTON(IN := FALSE, PT := t#2d);

//Initialization of instance 
fbPositionProfile(bStart := FALSE,              
                  rStartPosition := sv_rToggleLeverPosition);      

fbClampForceProfile(bStart := FALSE);

PTN.Par(dCycleTime := cycleTime, 
        Param := ParamPTN, 
        parStatus => parStatus);

PTN.Init(rOutVal := rInit);



;#END_EDIT_BLOCK END_ACTION (*AInitProfileOutput*)
ACTION ACalcPumpOutput: #BEGIN_EDIT_BLOCK
//venting in squential mode: 
IF (sv_ICMMode = nSequentialICM) THEN 
   IF fbPositionProfile.rAlgebraSign = -1.0 THEN       //fwd                        
      b := WRITE_SVREAL_DIRECT(sv_rPressure, sv_HydrMaxValuesClose.rMaxPressure); 
      rVelocity := MAX(sv_rVelOutputICM, sv_MinOutputFwd.rVelocity);
      b := WRITE_SVREAL_DIRECT(sv_rVelocity, rVelocity);
   ELSIF fbPositionProfile.rAlgebraSign = 1.0 THEN       //bwd         
      b := WRITE_SVREAL_DIRECT(sv_rPressure, sv_HydrMaxValuesOpen.rMaxPressure); 
      rVelocity := MAX(sv_rVelOutputICM, sv_MinOutputBwd.rVelocity);
      b := WRITE_SVREAL_DIRECT(sv_rVelocity, rVelocity);      
   END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACalcPumpOutput*)
ACTION AUpdateCalcValveController: #BEGIN_EDIT_BLOCK
//update the control data 
IF (bOldFwdActive <> sv_bFwdActive) OR (mrSetAccProfileVenting = 0.0) THEN
   IF mrSetVelProfileVenting > 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPBwd;  
   ELSIF mrSetVelProfileVenting < 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPFwd;
   ELSE
      //stand still 
      IF mrSetPos > sv_rToggleLeverPosition THEN
         rGainP := sv_ServoValveControlData.rGainPBwd;
         bPosError := TRUE; 
      ELSE 
         rGainP := sv_ServoValveControlData.rGainPFwd;
         bPosError := FALSE;
      END_IF;
   END_IF;
    
   abValveController.aPar(rGainP := rGainP, 
                          bPositiveVoltageIncreasing := 
                                    sv_ServoValveControlData.bPositiveVoltageIncreasing,
                          bPositionIncreasing := sv_bBwdActive);
   bOldFwdActive := sv_bFwdActive;  
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AUpdateCalcValveController*)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pProfileChanged ON PU_Task_7 WITH sv_VentingPosVis,sv_VentingForceVis, sv_bInitDone,sv_VentingActivateMode,sv_rSetMoldStartPosition


VAR_TEMP
 i : UDINT;
END_VAR

VAR
 rTimeMid : REAL;
 rDistMax : REAL;
 rTempToggleLeverPos : REAL;
 rTempMoldPosMax : REAL;
 rTempMoldPosMin : REAL;
END_VAR

VAR CONSTANT
 rDistMin : REAL := 0.5;
END_VAR
#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN
    
   //copy for the force profile
   IF sv_VentingPosVis.Profile.iNoOfPoints = 0 THEN
       sv_VentingPosVis.Profile.iNoOfPoints := 1; 
   END_IF;           
    
   sv_VentingForceVis.Profile.iNoOfPoints := sv_VentingPosVis.Profile.iNoOfPoints;  
   sv_VentingPos.Profile.iNoOfPoints := sv_VentingPosVis.Profile.iNoOfPoints;     
    
   FOR i := 1 TO sv_VentingForceVis.Profile.iNoOfPoints DO
      //copy the movement time
      sv_VentingForceVis.Profile.Points[i].rStartPos := sv_VentingPosVis.Profile.Points[i].rStartPos; 
        
      //calculate the max available distance
      IF sv_rVentingPosRamp = 0.0 THEN
         sv_rVentingPosRamp := 1.0; 
      END_IF;

      rTimeMid := sv_VentingPosVis.Profile.Points[i].rStartPos - sv_VentingPosVis.Profile.Points[i].rVelocity / sv_rVentingPosRamp * 2.0;  
    
      IF rTimeMid < 0.0 THEN
         IF sv_VentingPosVis.Profile.Points[i].rStartPos <> 0.0 THEN
            sv_rVentingPosRamp := 2.0 * sv_VentingPosVis.Profile.Points[i].rVelocity / sv_VentingPosVis.Profile.Points[i].rStartPos; 
         END_IF;                                                                                                    
         rTimeMid := 0.0;         
      END_IF;
        
      rDistMax := MAX((sv_VentingPosVis.Profile.Points[i].rStartPos + rTimeMid) * sv_VentingPosVis.Profile.Points[i].rVelocity / 2.0, rDistMin); 
        
      //plausibility for the target position
      IF i = 1 THEN    //stage 1                   
         abLintabApplyToggleLever.aCalc(rX:= sv_rSetMoldStartPosition);       
      ELSE    
         abLintabApplyToggleLever.aCalc(rX:= sv_VentingPosVis.Profile.Points[i - 1].rPressure);       
      END_IF;
      
      //mold position in hmi of last stage -> toggle lever pos 
      rTempToggleLeverPos := abLintabApplyToggleLever.aCalc.rY;   
         
      //min target toggle lever pos -> min mold pos 
      abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos - rDistMax));       
      rTempMoldPosMin := abLintabApplyToggleLever.aCalcInv.rX;   
         
      //max target toggle lever pos -> max mold pos 
      abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos + rDistMax));       
      rTempMoldPosMax := abLintabApplyToggleLever.aCalcInv.rX;   
      
      IF i = sv_VentingForceVis.Profile.iNoOfPoints THEN
         sv_VentingPosVis.Profile.Points[i].rPressRamp :=  0.0;     //the last stage of venting is allowed to set to 0      
      ELSE   
         sv_VentingPosVis.Profile.Points[i].rPressRamp :=  MAX(0.0,  rTempMoldPosMin);   //plaus min                                             
      END_IF;

      sv_VentingPosVis.Profile.Points[i].rVelRamp :=  MIN(rTempMoldPosMax, sv_rMoldStroke);  //plaus max    
        
      //mold position -> toggle lever pos
      abLintabApplyToggleLever.aCalcInv(rY:= sv_VentingPosVis.Profile.Points[i].rPressure);       
    
      sv_VentingPos.Profile.Points[i].rPressure := abLintabApplyToggleLever.aCalcInv.rX;   
        
      sv_VentingPos.Profile.Points[i].rStartPos := sv_VentingPosVis.Profile.Points[i].rStartPos;
      sv_VentingPos.Profile.Points[i].rVelocity := sv_VentingPosVis.Profile.Points[i].rVelocity;
   END_FOR;    
    
   //update the max.plausibility for the first coining stage depandant on existance of venting
   IF sv_VentingActivateMode = nDeactivate THEN
      sv_rMaxPlausFirstCoiningStage := sv_rSetMoldStartPosition;    
   ELSE 
      sv_rMaxPlausFirstCoiningStage := sv_VentingPosVis.Profile.Points[sv_VentingForceVis.Profile.iNoOfPoints].rPressure;    
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInit

#BEGIN_EDIT_BLOCK
abLintabApplyToggleLever.aInit(pLintab := @sv_ToggleLeverLintab,
                               bLinearExtrapolation := TRUE);
                                                                                                
//Min Output Velocity 
IF IS_LINKED(sv_ICMMode) THEN
   IF sv_rMinOutputVelVenting = 0.0 THEN
      sv_rMinOutputVelVenting := 5.0;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcMovementDirection ON PU_Task_7 WITH sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd

#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
      rOffsetPos := sv_ValveData.rValveOffsetFwd;
      rOffsetNeg := sv_ValveData.rValveOffsetBwd;    
   ELSE    
      rOffsetPos := sv_ValveData.rValveOffsetBwd;
      rOffsetNeg := sv_ValveData.rValveOffsetFwd;  
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCheckActivateMode ON PU_Task_7 WITH sv_bInitDone,sv_CoiningActivateMode,sv_VentingActivateMode

#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN
    
    //Disable input field if unnecessary
   IF sv_VentingActivateMode = nAfterInject THEN
      sv_bUseDelayTimeVenting := TRUE; 
      sv_bUseInjectPressVenting  := FALSE;
      sv_bUseInjectPosVenting  := FALSE;
   ELSIF sv_VentingActivateMode = nInjectPosition THEN
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting := FALSE;
      sv_bUseInjectPosVenting  := TRUE;
   ELSIF sv_VentingActivateMode = nInjectPressure THEN
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting  := TRUE;
      sv_bUseInjectPosVenting  := FALSE;
   ELSE 
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting := FALSE;
      sv_bUseInjectPosVenting := FALSE;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 131 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)IS_LINKED @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(29)KEBA_STANDARD_FUNCTION : BOOL @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
1 
@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMaxMoveIdent @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(13)ABMoveVenting @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
79 
@Var @RT(17)abValveController @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABValveController @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)fbClampForceProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBICMProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)pressure mold fwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)pressure mold bwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)sv_MoveVenting @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_bVentingActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)venting is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bVentingDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_rMaxPlausFirstCoiningStage @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_rVentingClampForceRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)clamp force ramp  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rVentingPosRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)acceleration mm/s/s @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)g_bClampPressSensorsAvailable @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(12)g_bMoldValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor1Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor2Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensorsAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(16)sv_VentingPosVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(25)venting pos visualization @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_VentingForceVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)ventin force visualization @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)mrSetPosProfileVenting @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbVentingActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)mrSetClampForceProfileVenting @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mrSetVelProfileVenting @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mrSetAccProfileVenting @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)sv_ForceControlParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tsControlParameters @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)PID - parameters for pressure control @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)fbPositionProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBICMProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)fbPIDControllerForce @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCTRL_PIDT1 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)proportion regulator for velocity @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)sv_rToggleLeverStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)Opening Stroke of toggle lever @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_rToggleLeverVelEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rToggleLeverPosition @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)rOffsetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rOffsetNeg @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)-1.2 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)pSysPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(13)rTankPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mrSetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)Set position for valve controller @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mrSetVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)Set velocity for valve controller @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)sv_rClampForceAct @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)mrUCtrlForce @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrUCtrlForceP @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)sv_ConstructionData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tServoValveConstructionData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ToggleLeverSplineData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsToggleLeverSplineData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ServoValveControlData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tServoValveControlData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)mrUCtrlForceI @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rVelOutputICM @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)pump output ICM @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bFwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_CoiningActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_VentingActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_bUseInjectPressVenting @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bUseInjectPosVenting @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bUseDelayTimeVenting @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedFwd @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_ValveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tServoValveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_ICMMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)tnICMMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)pidParamForce @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KCTRL_PIDT1_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bPreOutputReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rSetMoldStartPosition @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)mrFilteredClampForceVenting @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mrPosProfileLimitMin @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)sv_rMoldStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ToggleLeverLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)toggle lever lintab @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)abLintabApplyToggleLever @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)sv_VentingPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)venting pos profile @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MinOutputFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsMinOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MinOutputBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsMinOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_MoldVentingTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rMinOutputVelVenting @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)min output velocity for venting @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_HydrMaxValuesClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)hydraulic max values for mold close @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_HydrMaxValuesOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)hydraulic max values for mold open @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

7 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(21)abMoveVentingRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
32 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rSetVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rQNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rPNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rQNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rPNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)abEstimatePressure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABEstimatePressure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbTON @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(3)ICM @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTimer @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(3)ICM @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)cycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)T#6ms @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(3)PTN @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_PTN @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)ParamPTN @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_PTN_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(28)(uN:=1,rK:=1.0,dT1:=T#100ms) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)parStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_Ret @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)calcStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_Ret @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rInit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rGainOpenLoopBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rGainOpenLoopFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rGainP @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bOldFwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bPosError @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMaxSpeedVenting @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rVelOutputICM @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(16)rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(15)pProfileChanged @STRUCTURED_TEXT 
@RT(0) @RT(97)sv_VentingPosVis,sv_VentingForceVis, sv_bInitDone,sv_VentingActivateMode,sv_rSetMoldStartPosition @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)rTimeMid @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rDistMax @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rDistMin @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.5 @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(19)rTempToggleLeverPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rTempMoldPosMax @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rTempMoldPosMin @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pCalcMovementDirection @STRUCTURED_TEXT 
@RT(0) @RT(70)sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pCheckActivateMode @STRUCTURED_TEXT 
@RT(0) @RT(58)sv_bInitDone,sv_CoiningActivateMode,sv_VentingActivateMode @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration                                                   
sv_MoveVenting.pdActiveTimeAct := @sv_MoldVentingTimesAct.dActMoveTime;   

sv_MoveVenting.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveVenting.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveVenting.LockGroups[3] := cLockGroupMotor;
sv_MoveVenting.LockGroups[4] := cLockGroupRotateInjectPos;
sv_MoveVenting.pbPosReached := @sv_bVentingDone;     
sv_MoveVenting.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movVenting.gif");  

abMoveVentingRegister.aRegister(@sv_MoveVenting);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(42)
fuName := GET_MY_FU_NAME();

variableName := CONCAT(fuName,'.Control.rSetPosVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPosProfileVenting);
variableName := CONCAT(fuName,'.Control.rSetVelVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVel);
variableName := CONCAT(fuName,'.Control.rSetVelVentingOrig');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelProfileVenting);

variableName := CONCAT(fuName,'.Control.rSetAccVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetAccProfileVenting);
variableName := CONCAT(fuName,'.Control.rSetClampForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetClampForceProfileVenting);
variableName := CONCAT(fuName,'.Control.rFilteredClampForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrFilteredClampForceVenting);
variableName := CONCAT(fuName,'.Control.bVentingActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bVentingActive);
variableName := CONCAT(fuName,'.Control.rClampForceAct');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rClampForceAct);
variableName := CONCAT(fuName,'.Control.rSetPosForceVenting');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPos);

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
7 5 8 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 5 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)aStart @F @T @RT(1)N @RT(0) @F @F @T @TL(10)
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nActive);

sv_bVentingActive := TRUE;        
sv_bVentingDone := FALSE;

fbDebugTrace2(nDeviceState, 'Venting started');

@F 

@Trans @RT(6)Trans4 @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)Trans4 @F 
@Step @RT(16)S_ProfileVenting @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 8 
@Acb @RT(18)AInitProfileOutput @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(20)AInitValveController @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(25)AInitClampForceController @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)AProfileOutput @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(26)AUpdateCalcValveController @F @F @RT(1)N @RT(0) @F @F @T @F 
@Acb @RT(25)ACalcClampForceController @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(20)ACalcValveController @F @F @RT(1)N @RT(0) @F @F @T @F 
@Acb @RT(15)ACalcPumpOutput @F @F @RT(1)N @RT(0) @F @F @T @F 

@Trans @RT(17)TProfileMoveReady @F @T @F @F @T @T @TL(2)
NOT mbVentingActive

@RT(18)TProfileMoveReady2 @F 
@Step @RT(5)READY @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(21)
IF g_bMoldValve THEN
  sv_rMoldValveOutput := 0.0;
END_IF;

bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nInactive);

sv_bOutputActive := FALSE;   

IF NOT bStop THEN   
   sv_bVentingDone := TRUE;                 
END_IF;

sv_bVentingActive := FALSE;
sv_bFwdActive := FALSE;
sv_bBwdActive := FALSE;  

fbDebugTrace2(nDeviceState, 'Venting ready');

@F 


@Trans @RT(6)Trans7 @F @T @T @T @T @T @TL(3)
TRUE


@RT(6)Trans7 @F 

@END_SfcData 
@SaActions 8 
@SaText @RT(20)ACalcValveController 1 @TL(62)
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := mrSetPosProfileVenting*1.0e-3,
                                 rSetVel    := mrSetVelProfileVenting*1.0e-3,
                                 rSetAccel  := mrSetAccProfileVenting*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := mrSetPosProfileVenting*1.0e-3,
                                 rSetVel    := mrSetVelProfileVenting*1.0e-3,
                                 rSetAccel  := mrSetAccProfileVenting*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;                                  
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := mrSetPos*1.0e-3,     
                             rSetVelocity := mrSetVel*1.0e-3,      
                             rSetAcceleration := 0.0,
                             rSetJerk := 0.0,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
       
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);         
      ELSE
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, 0.0);         
      END_IF;
 
      bStart := FALSE;
    ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);                
    END_IF;
END_IF;


@SaText @RT(25)ACalcClampForceController 1 @TL(35)
IF NOT g_bClampPressSensorsAvailable THEN   
   //Only position controller available without force sensor 
   mrSetPos := mrSetPosProfileVenting; 
   mrSetVel := mrSetVelProfileVenting;
ELSE 
   sv_bOutputActive := TRUE;   

   //pid controller of clamp force 
   fbPIDControllerForce.Calculate(rActVal:= sv_rClampForceAct,
                                  rSetVal:= mrFilteredClampForceVenting,
                                  bEnable:= TRUE);
   //Control value
   mrUCtrlForce := fbPIDControllerForce.Calculate.rOutVal;
      
   //Pos limiter
   mrPosProfileLimitMin := LIMIT(0.0, (sv_rToggleLeverPosition - mrUCtrlForce), sv_rMoldStroke); 
   mrSetPos := LIMIT(mrPosProfileLimitMin, mrSetPosProfileVenting, sv_rMoldStroke);  

   //Monitoring the P- and I-Part 
   fbPIDControllerForce.GetActValues(rUProp => mrUCtrlForceP,
                                        rUInt => mrUCtrlForceI);
   //set velocity 
   IF (mrSetPos <> mrSetPosProfileVenting) THEN
      //force in limitation
      mrSetVel := 0.0;                        
   ELSE 
      IF mrSetVelProfileVenting > 0.0 THEN
         mrSetVel := rGainOpenLoopBwd * mrSetVelProfileVenting;
      ELSE 
         mrSetVel := rGainOpenLoopFwd * mrSetVelProfileVenting;
       END_IF;                                   
   END_IF;       
END_IF;          



@SaText @RT(20)AInitValveController 1 @TL(43)
IF g_bMoldValve THEN
   IF g_bPressureSensorsAvailable THEN
     
      dCycleTime := GET_TASK_INTERVAL();
    
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
       
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                            bPositionIncreasing := TRUE);
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;    
   END_IF;
   bStart := TRUE;
END_IF;


@SaText @RT(25)AInitClampForceController 1 @TL(29)
IF g_bClampPressSensorsAvailable THEN

   //Controller parameters
   dCycleTime := GET_TASK_INTERVAL();
   pidParamForce.rKR := sv_ForceControlParam.rP;
   pidParamForce.dTN := sv_ForceControlParam.dTN;
   pidParamForce.dTV := sv_ForceControlParam.dTV;
   pidParamForce.rKS := sv_ForceControlParam.rKS;

   //Limitation of control value
   pidParamForce.rUMax := sv_rMoldStroke;
   pidParamForce.rUMin := -sv_rMoldStroke;       

   //Parameterize pid controller
   fbPIDControllerForce.Par(dCycleTime := dCycleTime,
                            Param := pidParamForce);               
   //Initialization of pid controller        
   fbPIDControllerForce.Init(rActVal := 0.0,
                             rSetVal := 0.0,
                             rOpenLoopSetVal := 0.0,
                             rOutVal := 0.0);
   mrUCtrlForce := 0.0;
   mrUCtrlForceI := 0.0; 
   mrUCtrlForceP := 0.0;  
    
   rGainOpenLoopFwd := sv_ServoValveControlData.rGainOpenLoopFwd; 
   rGainOpenLoopBwd := sv_ServoValveControlData.rGainOpenLoopBwd; 
END_IF;


@SaText @RT(14)AProfileOutput 1 @TL(58)
//timer
fbTON(IN := TRUE);               
rTimer := LINT_TO_REAL(TIME_TO_LINT(fbTON.ET)) / 1000000.0;

//postion output
fbPositionProfile(bStart := TRUE,
                  bStop := bStop,
                  rAcceleration := sv_rVentingPosRamp,
                  bTimeModeVisu := TRUE,                     
                  ProfileICM := sv_VentingPos,
                  rTimer := rTimer,
                  rSetPos => mrSetPosProfileVenting,
                  rSetVel => mrSetVelProfileVenting,
                  rSetAcc => mrSetAccProfileVenting);

//clamp force output
fbClampForceProfile(bStart := TRUE,
                    bStop := bStop,
                    rAcceleration := sv_rVentingClampForceRamp,
                    bTimeModeVisu := TRUE,
                    ProfileICM := sv_VentingForceVis,
                    rTimer := rTimer,
                    rSetPos => mrSetClampForceProfileVenting);

//Filter PT1
PTN.Calculate(rInVal := mrSetClampForceProfileVenting, 
              rOutVal => mrFilteredClampForceVenting, 
              calcStatus => calcStatus);

//valve direction
IF fbPositionProfile.rAlgebraSign = 1.0 THEN
   sv_bFwdActive := FALSE;
   sv_bBwdActive := TRUE;                                
   rMaxSpeedVenting := sv_rMaxSpeedBwd; 
ELSIF fbPositionProfile.rAlgebraSign = -1.0 THEN
   sv_bFwdActive := TRUE;
   sv_bBwdActive := FALSE; 
   rMaxSpeedVenting := sv_rMaxSpeedFwd;                 
END_IF;

//Calculation of pump output
IF rMaxSpeedVenting = 0.0 THEN
   rMaxSpeedVenting:= 1.0; 
END_IF;

rVelOutputICM := ABS (mrSetVelProfileVenting / rMaxSpeedVenting * 100.0);
b := WRITE_SVREAL_DIRECT(sv_rVelOutputICM, rVelOutputICM);

mbVentingActive := (NOT fbPositionProfile.bReady)
                           AND (NOT fbClampForceProfile.bReady); 
                           
b := WRITE_SV_DIRECT(sv_MoldVentingTimesAct.dActMoveTime, fbTON.ET);

sv_bPreOutputReady := TRUE;
sv_bOutputActive := mbVentingActive;  




@SaText @RT(18)AInitProfileOutput 1 @TL(17)
//Initialize timer to build profile
fbTON(IN := FALSE, PT := t#2d);

//Initialization of instance 
fbPositionProfile(bStart := FALSE,              
                  rStartPosition := sv_rToggleLeverPosition);      

fbClampForceProfile(bStart := FALSE);

PTN.Par(dCycleTime := cycleTime, 
        Param := ParamPTN, 
        parStatus => parStatus);

PTN.Init(rOutVal := rInit);




@SaText @RT(15)ACalcPumpOutput 1 @TL(13)
//venting in squential mode: 
IF (sv_ICMMode = nSequentialICM) THEN 
   IF fbPositionProfile.rAlgebraSign = -1.0 THEN       //fwd                        
      b := WRITE_SVREAL_DIRECT(sv_rPressure, sv_HydrMaxValuesClose.rMaxPressure); 
      rVelocity := MAX(sv_rVelOutputICM, sv_MinOutputFwd.rVelocity);
      b := WRITE_SVREAL_DIRECT(sv_rVelocity, rVelocity);
   ELSIF fbPositionProfile.rAlgebraSign = 1.0 THEN       //bwd         
      b := WRITE_SVREAL_DIRECT(sv_rPressure, sv_HydrMaxValuesOpen.rMaxPressure); 
      rVelocity := MAX(sv_rVelOutputICM, sv_MinOutputBwd.rVelocity);
      b := WRITE_SVREAL_DIRECT(sv_rVelocity, rVelocity);      
   END_IF;
END_IF;


@SaText @RT(26)AUpdateCalcValveController 1 @TL(26)
//update the control data 
IF (bOldFwdActive <> sv_bFwdActive) OR (mrSetAccProfileVenting = 0.0) THEN
   IF mrSetVelProfileVenting > 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPBwd;  
   ELSIF mrSetVelProfileVenting < 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPFwd;
   ELSE
      //stand still 
      IF mrSetPos > sv_rToggleLeverPosition THEN
         rGainP := sv_ServoValveControlData.rGainPBwd;
         bPosError := TRUE; 
      ELSE 
         rGainP := sv_ServoValveControlData.rGainPFwd;
         bPosError := FALSE;
      END_IF;
   END_IF;
    
   abValveController.aPar(rGainP := rGainP, 
                          bPositiveVoltageIncreasing := 
                                    sv_ServoValveControlData.bPositiveVoltageIncreasing,
                          bPositionIncreasing := sv_bBwdActive);
   bOldFwdActive := sv_bFwdActive;  
END_IF;




@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(73)
IF IS_LINKED(sv_ICMMode) THEN
    
   //copy for the force profile
   IF sv_VentingPosVis.Profile.iNoOfPoints = 0 THEN
       sv_VentingPosVis.Profile.iNoOfPoints := 1; 
   END_IF;           
    
   sv_VentingForceVis.Profile.iNoOfPoints := sv_VentingPosVis.Profile.iNoOfPoints;  
   sv_VentingPos.Profile.iNoOfPoints := sv_VentingPosVis.Profile.iNoOfPoints;     
    
   FOR i := 1 TO sv_VentingForceVis.Profile.iNoOfPoints DO
      //copy the movement time
      sv_VentingForceVis.Profile.Points[i].rStartPos := sv_VentingPosVis.Profile.Points[i].rStartPos; 
        
      //calculate the max available distance
      IF sv_rVentingPosRamp = 0.0 THEN
         sv_rVentingPosRamp := 1.0; 
      END_IF;

      rTimeMid := sv_VentingPosVis.Profile.Points[i].rStartPos - sv_VentingPosVis.Profile.Points[i].rVelocity / sv_rVentingPosRamp * 2.0;  
    
      IF rTimeMid < 0.0 THEN
         IF sv_VentingPosVis.Profile.Points[i].rStartPos <> 0.0 THEN
            sv_rVentingPosRamp := 2.0 * sv_VentingPosVis.Profile.Points[i].rVelocity / sv_VentingPosVis.Profile.Points[i].rStartPos; 
         END_IF;                                                                                                    
         rTimeMid := 0.0;         
      END_IF;
        
      rDistMax := MAX((sv_VentingPosVis.Profile.Points[i].rStartPos + rTimeMid) * sv_VentingPosVis.Profile.Points[i].rVelocity / 2.0, rDistMin); 
        
      //plausibility for the target position
      IF i = 1 THEN    //stage 1                   
         abLintabApplyToggleLever.aCalc(rX:= sv_rSetMoldStartPosition);       
      ELSE    
         abLintabApplyToggleLever.aCalc(rX:= sv_VentingPosVis.Profile.Points[i - 1].rPressure);       
      END_IF;
      
      //mold position in hmi of last stage -> toggle lever pos 
      rTempToggleLeverPos := abLintabApplyToggleLever.aCalc.rY;   
         
      //min target toggle lever pos -> min mold pos 
      abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos - rDistMax));       
      rTempMoldPosMin := abLintabApplyToggleLever.aCalcInv.rX;   
         
      //max target toggle lever pos -> max mold pos 
      abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos + rDistMax));       
      rTempMoldPosMax := abLintabApplyToggleLever.aCalcInv.rX;   
      
      IF i = sv_VentingForceVis.Profile.iNoOfPoints THEN
         sv_VentingPosVis.Profile.Points[i].rPressRamp :=  0.0;     //the last stage of venting is allowed to set to 0      
      ELSE   
         sv_VentingPosVis.Profile.Points[i].rPressRamp :=  MAX(0.0,  rTempMoldPosMin);   //plaus min                                             
      END_IF;

      sv_VentingPosVis.Profile.Points[i].rVelRamp :=  MIN(rTempMoldPosMax, sv_rMoldStroke);  //plaus max    
        
      //mold position -> toggle lever pos
      abLintabApplyToggleLever.aCalcInv(rY:= sv_VentingPosVis.Profile.Points[i].rPressure);       
    
      sv_VentingPos.Profile.Points[i].rPressure := abLintabApplyToggleLever.aCalcInv.rX;   
        
      sv_VentingPos.Profile.Points[i].rStartPos := sv_VentingPosVis.Profile.Points[i].rStartPos;
      sv_VentingPos.Profile.Points[i].rVelocity := sv_VentingPosVis.Profile.Points[i].rVelocity;
   END_FOR;    
    
   //update the max.plausibility for the first coining stage depandant on existance of venting
   IF sv_VentingActivateMode = nDeactivate THEN
      sv_rMaxPlausFirstCoiningStage := sv_rSetMoldStartPosition;    
   ELSE 
      sv_rMaxPlausFirstCoiningStage := sv_VentingPosVis.Profile.Points[sv_VentingForceVis.Profile.iNoOfPoints].rPressure;    
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
abLintabApplyToggleLever.aInit(pLintab := @sv_ToggleLeverLintab,
                               bLinearExtrapolation := TRUE);
                                                                                                
//Min Output Velocity 
IF IS_LINKED(sv_ICMMode) THEN
   IF sv_rMinOutputVelVenting = 0.0 THEN
      sv_rMinOutputVelVenting := 5.0;
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
IF g_bMoldValve THEN
   IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
      rOffsetPos := sv_ValveData.rValveOffsetFwd;
      rOffsetNeg := sv_ValveData.rValveOffsetBwd;    
   ELSE    
      rOffsetPos := sv_ValveData.rValveOffsetBwd;
      rOffsetNeg := sv_ValveData.rValveOffsetFwd;  
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(22)
IF IS_LINKED(sv_ICMMode) THEN
    
    //Disable input field if unnecessary
   IF sv_VentingActivateMode = nAfterInject THEN
      sv_bUseDelayTimeVenting := TRUE; 
      sv_bUseInjectPressVenting  := FALSE;
      sv_bUseInjectPosVenting  := FALSE;
   ELSIF sv_VentingActivateMode = nInjectPosition THEN
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting := FALSE;
      sv_bUseInjectPosVenting  := TRUE;
   ELSIF sv_VentingActivateMode = nInjectPressure THEN
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting  := TRUE;
      sv_bUseInjectPosVenting  := FALSE;
   ELSE 
      sv_bUseDelayTimeVenting  := FALSE; 
      sv_bUseInjectPressVenting := FALSE;
      sv_bUseInjectPosVenting := FALSE;
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
