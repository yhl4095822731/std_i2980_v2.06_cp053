IMPORT_OVER_LISTFILE
 GET_SYNC_REFTO
, IS_LINKED
, WRITE_SV_DIRECT
, WRITE_SVREAL_DIRECT
, cMoveAll
, FBICMProfile
, tnICMActivateMode
, KAPPL_LintabData
, KAPPL_VisProfile
, tsMoveData
, ABValveController
, tServoValveConstructionData
, tsMoveCtrl
, KCTRL_PIDT1_Param
, tsToggleLeverSplineData
, tsControlParameters
, KCTRL_PIDT1
, tServoValveControlData
, tServoValveData
, tnICMMode
, ABLintabApply
, tsActTimes
, ABMovementRegister
, KSWO_Status
, FBSetMovementState
, FBDebugTrace2
, ABEstimatePressure
, TON
, KCTRL_PTN
, KCTRL_PTN_Param
, KCTRL_Ret

END_IMPORT

ALGORITHM_BLOCK ABMoveCoining #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_VentingActivateMode : tnICMActivateMode (* activating mode for venting *);
 sv_ToggleLeverLintab : KAPPL_LintabData (* toggle lever lintab *);
 sv_CoiningPosVis : KAPPL_VisProfile (* coining pos visualization *);
 sv_CoiningForceVis : KAPPL_VisProfile (* coining force visualization *);
 sv_MoveCoining : tsMoveData;
 sv_bCoiningActive : BOOL (* coining is active *);
 sv_bInitDone : BOOL;
 sv_rMoldValveOutput : REAL;
 sv_rCoiningClampForceRamp : REAL (* clamp force ramp  *);
 sv_ConstructionData : tServoValveConstructionData;
 sv_rCoiningPosRamp : REAL (* acceleration mm/s/s *);
 sv_rMaxSpeedFwd : REAL;
 sv_CoiningActivateMode : tnICMActivateMode;
 sv_ToggleLeverSplineData : tsToggleLeverSplineData;
 sv_ForceControlParam : tsControlParameters (* PID - parameters for pressure control *);
 sv_rToggleLeverPosition : REAL;
 sv_rClampForceAct : REAL;
 sv_ServoValveControlData : tServoValveControlData;
 sv_ValveData : tServoValveData;
 sv_rVelocityAbs : REAL;
 sv_rVelOutputICM : REAL;
 sv_rToggleLeverVelEstimate : REAL;
 sv_rToggleLeverStroke : REAL (* Opening Stroke of toggle lever *);
 sv_ICMMode : tnICMMode;
 sv_bCoiningDone : BOOL;
 sv_bFwdActive : BOOL;
 sv_bBwdActive : BOOL;
 sv_bUseInjectPressCoining : BOOL;
 sv_bUseInjectPosCoining : BOOL;
 sv_bUseDelayTimeCoining : BOOL;
 sv_bOutputActive : BOOL;
 sv_rMoldPressure2 : REAL;
 sv_rMoldPressure1 : REAL;
 sv_rMaxPlausFirstCoiningStage : REAL;
 sv_rSetMoldStartPosition : REAL;
 sv_CoiningPos : KAPPL_VisProfile (* coining pos profile *);
 sv_rMaxSpeedBwd : REAL;
 sv_rMoldStroke : REAL;
 sv_bEnableMoldStartPosCoining : BOOL (* enable mold start pos coining *);
 sv_MoldCoiningTimesAct : tsActTimes;
 sv_rMinOutputVelCoining : REAL (* min output velocity for coining *);
END_VAR

SYSTEM_OBJECT
 TaskSlow : TASK;
 TaskAnalog : TASK;
 PU_Task_7 : TASK;
END_OBJECT

VAR_EXTERNAL
 g_bMoldValve : BOOL;
 g_bPressureSensor1Available : BOOL;
 g_bPressureSensor2Available : BOOL;
 g_bPressureSensorsAvailable : BOOL;
 g_MoveCtrl : tsMoveCtrl;
 pSysPressure : REFTO REAL;
 g_bClampPressSensorsAvailable : BOOL;
END_VAR

VAR
 fbPositionProfile : FBICMProfile;
 fbClampForceProfile : FBICMProfile;
 abValveController : ABValveController;
 bStart : BOOL;
 mrSetPosProfileCoining : REAL;
 mrSetClampForceProfileCoining : REAL;
 mrSetVelProfileCoining : REAL;
 mrSetAccProfileCoining : REAL;
 pidParamForce : KCTRL_PIDT1_Param;
 fbPIDControllerForce : KCTRL_PIDT1 (* proportion regulator for velocity *);
 mrSetPos : REAL (* Set position for valve controller *);
 mrSetVel : REAL (* Set velocity for valve controller *);
 mrUCtrlForce : REAL;
 mrUCtrlForceP : REAL;
 mrUCtrlForceI : REAL;
 rTankPressure : REAL := 1.0;
 rOffsetPos : REAL := 1.0;
 rOffsetNeg : REAL := -1.2;
 mrFilteredClampForceCoining : REAL;
 mrPosProfileLimitMin : REAL;
 abLintabApplyToggleLever : ABLintabApply;
END_VAR

ALGORITHM aInit

#BEGIN_EDIT_BLOCK
abLintabApplyToggleLever.aInit(pLintab := @sv_ToggleLeverLintab,
                               bLinearExtrapolation := TRUE);
                                                                                   
//Min Output Velocity 
IF IS_LINKED(sv_ICMMode) THEN
   IF sv_rMinOutputVelCoining = 0.0 THEN
      sv_rMinOutputVelCoining := 5.0;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRegister


VAR
 abMoveCoiningRegister : ABMovementRegister;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration                                                
sv_MoveCoining.pdActiveTimeAct := @sv_MoldCoiningTimesAct.dActMoveTime;    

sv_MoveCoining.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveCoining.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveCoining.LockGroups[3] := cLockGroupMotor;
sv_MoveCoining.LockGroups[4] := cLockGroupRotateInjectPos;

sv_MoveCoining.pbPosReached := @sv_bCoiningDone;     
sv_MoveCoining.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movCoining.gif");     

abMoveCoiningRegister.aRegister(@sv_MoveCoining);

 


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();

variableName := CONCAT(fuName,'.Control.rSetPosCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPosProfileCoining);
variableName := CONCAT(fuName,'.Control.rSetVelCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVel);
variableName := CONCAT(fuName,'.Control.rSetVelCoiningOrig');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelProfileCoining);
variableName := CONCAT(fuName,'.Control.rSetAccCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetAccProfileCoining);       
variableName := CONCAT(fuName,'.Control.rSetClampForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetClampForceProfileCoining);
variableName := CONCAT(fuName,'.Control.rFilteredClampForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrFilteredClampForceCoining);
variableName := CONCAT(fuName,'.Control.rClampForceAct');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rClampForceAct);
variableName := CONCAT(fuName,'.Control.rSetPosForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPos);
variableName := CONCAT(fuName,'.Control.bCoiningActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bCoiningActive);           
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_TEMP
 b : BOOL;
 rVelOutputICM : REAL;
 rMoldValveOutput : REAL;
END_VAR

VAR
 fbSetMovementState : FBSetMovementState;
 fbDebugTrace2 : FBDebugTrace2;
 rOutput : REAL;
 dCycleTime : TIME;
 rSetVelocity : REAL;
 rQNom : REAL;
 rPNom : REAL;
 rQNomPB : REAL;
 rPNomPB : REAL;
 rPressure1 : REAL;
 rPressure2 : REAL;
 abEstimatePressure : ABEstimatePressure;
 fbTON : TON (* ICM *);
 rTimer : REAL (* ICM *);
 mbCoiningActive : BOOL;
 mrForceControlStartPos : REAL;
 cycleTime : TIME := T#6ms;
 PTN : KCTRL_PTN;
 ParamPTN : KCTRL_PTN_Param := (uN:=1,rK:=1.0,dT1:=T#100ms);
 parStatus : KCTRL_Ret;
 calcStatus : KCTRL_Ret;
 rInit : REAL;
 rGainOpenLoopBwd : REAL;
 rGainOpenLoopFwd : REAL;
 rGainP : REAL;
 bPosError : BOOL;
 bOldFwdActive : BOOL;
 rMaxSpeedCoining : REAL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
aStart (N);
END_STEP

ACTION aStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nActive);
sv_bCoiningActive := TRUE;   

fbDebugTrace2(nDeviceState, 'Coining started');

;#END_EDIT_BLOCK END_ACTION (*aStart*)

(* steps *)
STEP S_ProfileCoining:
AInitProfileOutput (P);
AInitClampForceController (P);
AInitValveController (P);
AProfileOutput (N);
AUpdateCalcValveController (N);
ACalcClampForceController (N);
ACalcValveController (N);
END_STEP

STEP READY:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   sv_rMoldValveOutput := 0.0;
END_IF;
bReady := TRUE;
fbSetMovementState(MoveId  := g_MoveCtrl.pData^.MoveId,
                   MoveDir := cMoveAll,
                   State   := nInactive);

sv_bOutputActive := FALSE;  
sv_bCoiningActive := FALSE;
sv_bFwdActive := FALSE;
sv_bBwdActive := FALSE;    

IF NOT bStop THEN
   sv_bCoiningDone := TRUE;                 
END_IF;

fbDebugTrace2(nDeviceState, 'Coining ready');

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
TRANSITION Trans4 (* Trans4 *) FROM START TO S_ProfileCoining :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileMoveReady (* TProfileMoveReady2 *) FROM S_ProfileCoining TO READY :=  #BEGIN_EDIT_BLOCK
NOT mbCoiningActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans7 (* Trans7 *) FROM READY TO START :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION ACalcValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := mrSetPosProfileCoining*1.0e-3,
                                 rSetVel    := mrSetVelProfileCoining*1.0e-3,
                                 rSetAccel  := mrSetAccProfileCoining*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := mrSetPosProfileCoining*1.0e-3,
                                 rSetVel    := mrSetVelProfileCoining*1.0e-3,
                                 rSetAccel  := mrSetAccProfileCoining*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;                                   
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := mrSetPos*1.0e-3,       
                             rSetVelocity := mrSetVel*1.0e-3,      
                             rSetAcceleration := 0.0,
                             rSetJerk := 0.0,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;

      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSE
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, 0.0);
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);

      bStart := FALSE;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);      
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*ACalcValveController*)
ACTION ACalcClampForceController: #BEGIN_EDIT_BLOCK
IF NOT g_bClampPressSensorsAvailable THEN   
   //Only position controller available without force sensor 
   mrSetPos := mrSetPosProfileCoining; 
   mrSetVel := mrSetVelProfileCoining;
ELSE 
   sv_bOutputActive := TRUE;   
    
   //pid controller of clamp force 
   fbPIDControllerForce.Calculate(rActVal:= sv_rClampForceAct,
                                  rSetVal:= mrFilteredClampForceCoining,
                                  bEnable:= TRUE);
   //Control value    
   mrUCtrlForce := fbPIDControllerForce.Calculate.rOutVal;
    
   //Limiter  
   mrPosProfileLimitMin := LIMIT(0.0, (sv_rToggleLeverPosition - mrUCtrlForce), mrForceControlStartPos); 
   mrSetPos := LIMIT(mrPosProfileLimitMin, mrSetPosProfileCoining, sv_rMoldStroke);  
      
   //Monitoring the P- and I-Part 
   fbPIDControllerForce.GetActValues(rUProp => mrUCtrlForceP,
                                     rUInt => mrUCtrlForceI);
   //Set velocity      
   IF (mrSetPos <> mrSetPosProfileCoining) THEN 
      //force in limitation
      mrSetVel := 0.0;                          
   ELSE     
      //pos in limitation                            
      IF mrSetVelProfileCoining > 0.0 THEN
         mrSetVel :=  rGainOpenLoopBwd * mrSetVelProfileCoining;
      ELSE 
         mrSetVel :=  rGainOpenLoopFwd * mrSetVelProfileCoining;
      END_IF;                                   
   END_IF;       
END_IF;          


;#END_EDIT_BLOCK END_ACTION (*ACalcClampForceController*)
ACTION AInitValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF g_bPressureSensorsAvailable THEN
     
      dCycleTime := GET_TASK_INTERVAL();
    
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                             bPositionIncreasing := FALSE);
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;    
   END_IF;
   
   bStart := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitValveController*)
ACTION AInitClampForceController: #BEGIN_EDIT_BLOCK
IF g_bClampPressSensorsAvailable THEN
    
   //Start position of force control
   mrForceControlStartPos := sv_rToggleLeverPosition;
    
   //Controller parameters
   dCycleTime := GET_TASK_INTERVAL();
   pidParamForce.rKR := sv_ForceControlParam.rP;
   pidParamForce.dTN := sv_ForceControlParam.dTN;
   pidParamForce.dTV := sv_ForceControlParam.dTV;
   pidParamForce.rKS := sv_ForceControlParam.rKS;

   //Limitation of control value                 
   pidParamForce.rUMax := sv_rMoldStroke;
   pidParamForce.rUMin := -sv_rMoldStroke;        

   //Parameterize pid controller
   fbPIDControllerForce.Par(dCycleTime := dCycleTime,
                            Param := pidParamForce);               
   //Initialization of pid controller        
   fbPIDControllerForce.Init(rActVal := 0.0,
                             rSetVal := 0.0,
                             rOpenLoopSetVal := 0.0,
                             rOutVal := 0.0);
   mrUCtrlForce := 0.0;
   mrUCtrlForceI := 0.0; 
   mrUCtrlForceP := 0.0;  
    
   rGainOpenLoopFwd := sv_ServoValveControlData.rGainOpenLoopFwd;
   rGainOpenLoopBwd := sv_ServoValveControlData.rGainOpenLoopBwd; 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitClampForceController*)
ACTION AProfileOutput: #BEGIN_EDIT_BLOCK
//timer
fbTON(IN := TRUE);               
rTimer := LINT_TO_REAL(TIME_TO_LINT(fbTON.ET)) / 1000000.0;

//postion output
fbPositionProfile(bStart := TRUE,
                  bStop := bStop,
                  rAcceleration := sv_rCoiningPosRamp,
                  bTimeModeVisu := TRUE,                     
                  ProfileICM := sv_CoiningPos,            
                  rTimer := rTimer,
                  rSetPos => mrSetPosProfileCoining,
                  rSetVel => mrSetVelProfileCoining,
                  rSetAcc => mrSetAccProfileCoining);

//clamp force output
fbClampForceProfile(bStart := TRUE,
                    bStop := bStop,
                    rAcceleration := sv_rCoiningClampForceRamp,
                    bTimeModeVisu := TRUE,
                    ProfileICM := sv_CoiningForceVis,
                    rTimer := rTimer,
                    rSetPos => mrSetClampForceProfileCoining);

//Filter PT1
PTN.Calculate(rInVal := mrSetClampForceProfileCoining, 
              rOutVal => mrFilteredClampForceCoining, 
              calcStatus => calcStatus);

//valve direction
IF fbPositionProfile.rAlgebraSign = 1.0 THEN
   sv_bFwdActive := FALSE;
   sv_bBwdActive := TRUE;    
   rMaxSpeedCoining := sv_rMaxSpeedBwd;    
ELSIF fbPositionProfile.rAlgebraSign = -1.0 THEN
   sv_bFwdActive := TRUE;    
   sv_bBwdActive := FALSE;    
   rMaxSpeedCoining := sv_rMaxSpeedFwd;        
END_IF;

//Calculation of pump output
IF rMaxSpeedCoining = 0.0 THEN
   rMaxSpeedCoining := 1.0; 
END_IF;
rVelOutputICM := ABS(mrSetVelProfileCoining / rMaxSpeedCoining * 100.0);
b := WRITE_SVREAL_DIRECT(sv_rVelOutputICM, rVelOutputICM);

mbCoiningActive := (NOT fbPositionProfile.bReady)
                            AND (NOT fbClampForceProfile.bReady);    

b := WRITE_SV_DIRECT(sv_MoldCoiningTimesAct.dActMoveTime, fbTON.ET);

sv_bOutputActive := mbCoiningActive;  

;#END_EDIT_BLOCK END_ACTION (*AProfileOutput*)
ACTION AInitProfileOutput: #BEGIN_EDIT_BLOCK
//Initialize timer to build profile
fbTON(IN := FALSE, PT := t#2d);

//Initialization of instance 
fbPositionProfile(bStart := FALSE,          
                  rStartPosition := sv_rToggleLeverPosition);

fbClampForceProfile(bStart := FALSE);

PTN.Par(dCycleTime := cycleTime, 
        Param := ParamPTN, 
        parStatus => parStatus);

PTN.Init(rOutVal := rInit);


;#END_EDIT_BLOCK END_ACTION (*AInitProfileOutput*)
ACTION AUpdateCalcValveController: #BEGIN_EDIT_BLOCK
//update the control data 
IF (bOldFwdActive <> sv_bFwdActive) OR (mrSetAccProfileCoining = 0.0) THEN
    
   IF mrSetVelProfileCoining > 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPBwd;  
   ELSIF mrSetVelProfileCoining < 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPFwd;
   ELSE
      //stand still 
      IF mrSetPos > sv_rToggleLeverPosition THEN
         rGainP := sv_ServoValveControlData.rGainPBwd;
         bPosError := TRUE; 
      ELSE 
         rGainP := sv_ServoValveControlData.rGainPFwd;
         bPosError := FALSE;
      END_IF;
   END_IF;
    
   abValveController.aPar(rGainP := rGainP, 
                          bPositiveVoltageIncreasing := 
                                    sv_ServoValveControlData.bPositiveVoltageIncreasing,
                          bPositionIncreasing := sv_bBwdActive);
   bOldFwdActive := sv_bFwdActive;  
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AUpdateCalcValveController*)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pProfileChanged ON PU_Task_7 WITH sv_CoiningPosVis,sv_CoiningForceVis,sv_bInitDone,sv_rSetMoldStartPosition


VAR_TEMP
 i : UDINT;
END_VAR

VAR
 rTimeMid : REAL;
 rDistMax : REAL;
 rTempToggleLeverPos : REAL;
 rTempMoldPosMax : REAL;
 rTempMoldPosMin : REAL;
END_VAR

VAR CONSTANT
 rDistMin : REAL := 0.5;
END_VAR
#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN
    
    //copy for the force profile
    IF sv_CoiningPosVis.Profile.iNoOfPoints = 0 THEN
       sv_CoiningPosVis.Profile.iNoOfPoints := 1; 
    END_IF;           

    sv_CoiningForceVis.Profile.iNoOfPoints := sv_CoiningPosVis.Profile.iNoOfPoints;  
    sv_CoiningPos.Profile.iNoOfPoints := sv_CoiningPosVis.Profile.iNoOfPoints; 
    
    FOR i := 1 TO sv_CoiningForceVis.Profile.iNoOfPoints DO
        
       //copy the time duration of pos profile
       sv_CoiningForceVis.Profile.Points[i].rStartPos := sv_CoiningPosVis.Profile.Points[i].rStartPos;  
        
       //calculate the max available distance
       IF sv_rCoiningPosRamp = 0.0 THEN
          sv_rCoiningPosRamp := 1.0; 
       END_IF;
        
       rTimeMid := sv_CoiningPosVis.Profile.Points[i].rStartPos - sv_CoiningPosVis.Profile.Points[i].rVelocity / sv_rCoiningPosRamp * 2.0;  
        
       IF rTimeMid < 0.0 THEN
          IF sv_CoiningPosVis.Profile.Points[i].rStartPos <> 0.0 THEN
             sv_rCoiningPosRamp := 2.0 * sv_CoiningPosVis.Profile.Points[i].rVelocity / sv_CoiningPosVis.Profile.Points[i].rStartPos; 
          END_IF;                                                                                                    
          rTimeMid := 0.0;         
       END_IF;
        
       rDistMax := MAX((sv_CoiningPosVis.Profile.Points[i].rStartPos + rTimeMid) * sv_CoiningPosVis.Profile.Points[i].rVelocity / 2.0, rDistMin); 

       //plausibility for the target position
       IF i = 1 THEN
         abLintabApplyToggleLever.aCalc(rX:= sv_rMaxPlausFirstCoiningStage);                                                     
       ELSE 
         abLintabApplyToggleLever.aCalc(rX:= sv_CoiningPosVis.Profile.Points[i - 1].rPressure);                                      
       END_IF; 
        
       //mold pos in hmi of last stage -> toggle lever pos
       rTempToggleLeverPos := abLintabApplyToggleLever.aCalc.rY;  
        
       //min toggle lever pos 
       abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos - rDistMax));       
       rTempMoldPosMin := abLintabApplyToggleLever.aCalcInv.rX;   
         
       //max toggle lever pos  
       abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos + rDistMax));       
       rTempMoldPosMax := abLintabApplyToggleLever.aCalcInv.rX;   
           
       sv_CoiningPosVis.Profile.Points[i].rPressRamp :=  MAX(0.0,  rTempMoldPosMin);        //plaus min
       sv_CoiningPosVis.Profile.Points[i].rVelRamp :=  MIN(rTempMoldPosMax, sv_rMoldStroke);  //plaus max
        
       //mold position -> toggle lever pos
       abLintabApplyToggleLever.aCalcInv(rY:= sv_CoiningPosVis.Profile.Points[i].rPressure);       
    
       sv_CoiningPos.Profile.Points[i].rPressure := abLintabApplyToggleLever.aCalcInv.rX;    
       sv_CoiningPos.Profile.Points[i].rStartPos := sv_CoiningPosVis.Profile.Points[i].rStartPos;
       sv_CoiningPos.Profile.Points[i].rVelocity := sv_CoiningPosVis.Profile.Points[i].rVelocity;
        
   END_FOR;    
END_IF;    


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcMovementDirection ON PU_Task_7 WITH sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd

#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
      rOffsetPos := sv_ValveData.rValveOffsetFwd;
      rOffsetNeg := sv_ValveData.rValveOffsetBwd;       
   ELSE    
      rOffsetPos := sv_ValveData.rValveOffsetBwd;
      rOffsetNeg := sv_ValveData.rValveOffsetFwd;    
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCheckActivateMode ON PU_Task_7 WITH sv_bInitDone,sv_CoiningActivateMode,sv_VentingActivateMode,sv_ICMMode

#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN
    
   //Disable coining in case of sequential mode without venting
   IF (sv_VentingActivateMode = nDeactivate) AND (sv_ICMMode = nSequentialICM) THEN 
      sv_CoiningActivateMode := nDeactivate;
   END_IF;
    
   //Disable input field 
   IF sv_CoiningActivateMode = nAfterInject THEN
      sv_bUseDelayTimeCoining := TRUE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := FALSE;
   ELSIF sv_CoiningActivateMode = nInjectPosition THEN
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := TRUE;
   ELSIF sv_CoiningActivateMode = nInjectPressure THEN
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := TRUE;
      sv_bUseInjectPosCoining := FALSE;
   ELSE 
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := FALSE;
   END_IF;
    
   //Enable input field for mold start pos 
   IF (sv_VentingActivateMode = nDeactivate)AND(sv_CoiningActivateMode <> nDeactivate) THEN
      sv_bEnableMoldStartPosCoining := TRUE;
   ELSE 
      sv_bEnableMoldStartPosCoining := FALSE;
   END_IF;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 131 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)IS_LINKED @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(29)KEBA_STANDARD_FUNCTION : BOOL @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(29)KEBA_STANDARD_FUNCTION : BOOL @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
1 
@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMaxMoveIdent @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(13)ABMoveCoining @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
72 
@Var @RT(17)fbPositionProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBICMProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)fbClampForceProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBICMProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)sv_VentingActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)activating mode for venting @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ToggleLeverLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)toggle lever lintab @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_CoiningPosVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(25)coining pos visualization @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_CoiningForceVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)coining force visualization @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_MoveCoining @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_bCoiningActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)coining is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)abValveController @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABValveController @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)sv_rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_rCoiningClampForceRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)clamp force ramp  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_ConstructionData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tServoValveConstructionData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rCoiningPosRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)acceleration mm/s/s @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)g_bMoldValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor1Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor2Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensorsAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(22)mrSetPosProfileCoining @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)mrSetClampForceProfileCoining @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mrSetVelProfileCoining @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mrSetAccProfileCoining @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)sv_CoiningActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(12)pSysPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(13)pidParamForce @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KCTRL_PIDT1_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)sv_ToggleLeverSplineData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsToggleLeverSplineData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ForceControlParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tsControlParameters @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)PID - parameters for pressure control @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)fbPIDControllerForce @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCTRL_PIDT1 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)proportion regulator for velocity @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)sv_rToggleLeverPosition @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)mrSetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)Set position for valve controller @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mrSetVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)Set velocity for valve controller @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)sv_rClampForceAct @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)mrUCtrlForce @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrUCtrlForceP @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrUCtrlForceI @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rTankPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rOffsetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rOffsetNeg @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)-1.2 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)sv_ServoValveControlData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tServoValveControlData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_ValveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tServoValveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rVelOutputICM @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_rToggleLeverVelEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rToggleLeverStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)Opening Stroke of toggle lever @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_ICMMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)tnICMMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bCoiningDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bFwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_bUseInjectPressCoining @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bUseInjectPosCoining @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bUseDelayTimeCoining @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)mrFilteredClampForceCoining @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure2 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure1 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)g_bClampPressSensorsAvailable @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(20)mrPosProfileLimitMin @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)sv_rMaxPlausFirstCoiningStage @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rSetMoldStartPosition @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_CoiningPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)coining pos profile @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)abLintabApplyToggleLever @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedBwd @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_rMoldStroke @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_bEnableMoldStartPosCoining @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)enable mold start pos coining @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_MoldCoiningTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rMinOutputVelCoining @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)min output velocity for coining @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

7 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(21)abMoveCoiningRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
33 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rSetVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rQNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rPNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rQNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rPNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)abEstimatePressure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABEstimatePressure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbTON @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(3)ICM @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTimer @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(3)ICM @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbCoiningActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mrForceControlStartPos @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)cycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)T#6ms @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(3)PTN @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_PTN @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)ParamPTN @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_PTN_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(28)(uN:=1,rK:=1.0,dT1:=T#100ms) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)parStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_Ret @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)calcStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_Ret @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rInit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rGainOpenLoopBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rGainOpenLoopFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rGainP @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bPosError @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bOldFwdActive @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMaxSpeedCoining @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)rVelOutputICM @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(16)rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(15)pProfileChanged @STRUCTURED_TEXT 
@RT(0) @RT(73)sv_CoiningPosVis,sv_CoiningForceVis,sv_bInitDone,sv_rSetMoldStartPosition @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)rTimeMid @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rDistMax @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rDistMin @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.5 @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(19)rTempToggleLeverPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rTempMoldPosMax @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rTempMoldPosMin @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pCalcMovementDirection @STRUCTURED_TEXT 
@RT(0) @RT(70)sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pCheckActivateMode @STRUCTURED_TEXT 
@RT(0) @RT(69)sv_bInitDone,sv_CoiningActivateMode,sv_VentingActivateMode,sv_ICMMode @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(10)
abLintabApplyToggleLever.aInit(pLintab := @sv_ToggleLeverLintab,
                               bLinearExtrapolation := TRUE);
                                                                                   
//Min Output Velocity 
IF IS_LINKED(sv_ICMMode) THEN
   IF sv_rMinOutputVelCoining = 0.0 THEN
      sv_rMinOutputVelCoining := 5.0;
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(20)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration                                                
sv_MoveCoining.pdActiveTimeAct := @sv_MoldCoiningTimesAct.dActMoveTime;    

sv_MoveCoining.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveCoining.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveCoining.LockGroups[3] := cLockGroupMotor;
sv_MoveCoining.LockGroups[4] := cLockGroupRotateInjectPos;

sv_MoveCoining.pbPosReached := @sv_bCoiningDone;     
sv_MoveCoining.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movCoining.gif");     

abMoveCoiningRegister.aRegister(@sv_MoveCoining);

 

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(40)
fuName := GET_MY_FU_NAME();

variableName := CONCAT(fuName,'.Control.rSetPosCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPosProfileCoining);
variableName := CONCAT(fuName,'.Control.rSetVelCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVel);
variableName := CONCAT(fuName,'.Control.rSetVelCoiningOrig');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelProfileCoining);
variableName := CONCAT(fuName,'.Control.rSetAccCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetAccProfileCoining);       
variableName := CONCAT(fuName,'.Control.rSetClampForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetClampForceProfileCoining);
variableName := CONCAT(fuName,'.Control.rFilteredClampForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrFilteredClampForceCoining);
variableName := CONCAT(fuName,'.Control.rClampForceAct');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rClampForceAct);
variableName := CONCAT(fuName,'.Control.rSetPosForceCoining');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetPos);
variableName := CONCAT(fuName,'.Control.bCoiningActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bCoiningActive);           
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
6 5 8 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 5 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)aStart @F @T @RT(1)N @RT(0) @F @F @T @TL(8)
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveAll,
                   State    := nActive);
sv_bCoiningActive := TRUE;   

fbDebugTrace2(nDeviceState, 'Coining started');

@F 

@Trans @RT(6)Trans4 @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)Trans4 @F 
@Step @RT(16)S_ProfileCoining @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 7 
@Acb @RT(18)AInitProfileOutput @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(25)AInitClampForceController @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(20)AInitValveController @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)AProfileOutput @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(26)AUpdateCalcValveController @F @F @RT(1)N @RT(0) @F @F @T @F 
@Acb @RT(25)ACalcClampForceController @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(20)ACalcValveController @F @F @RT(1)N @RT(0) @F @F @T @F 

@Trans @RT(17)TProfileMoveReady @F @T @F @F @T @F @TL(2)
NOT mbCoiningActive

@RT(18)TProfileMoveReady2 @F 
@Step @RT(5)READY @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(19)
IF g_bMoldValve THEN
   sv_rMoldValveOutput := 0.0;
END_IF;
bReady := TRUE;
fbSetMovementState(MoveId  := g_MoveCtrl.pData^.MoveId,
                   MoveDir := cMoveAll,
                   State   := nInactive);

sv_bOutputActive := FALSE;  
sv_bCoiningActive := FALSE;
sv_bFwdActive := FALSE;
sv_bBwdActive := FALSE;    

IF NOT bStop THEN
   sv_bCoiningDone := TRUE;                 
END_IF;

fbDebugTrace2(nDeviceState, 'Coining ready');

@F 


@Trans @RT(6)Trans7 @F @T @T @T @T @T @TL(3)
TRUE


@RT(6)Trans7 @F 

@END_SfcData 
@SaActions 7 
@SaText @RT(20)ACalcValveController 1 @TL(63)
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := mrSetPosProfileCoining*1.0e-3,
                                 rSetVel    := mrSetVelProfileCoining*1.0e-3,
                                 rSetAccel  := mrSetAccProfileCoining*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := mrSetPosProfileCoining*1.0e-3,
                                 rSetVel    := mrSetVelProfileCoining*1.0e-3,
                                 rSetAccel  := mrSetAccProfileCoining*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;                                   
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := mrSetPos*1.0e-3,       
                             rSetVelocity := mrSetVel*1.0e-3,      
                             rSetAcceleration := 0.0,
                             rSetJerk := 0.0,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;

      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSE
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, 0.0);
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);

      bStart := FALSE;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);      
   END_IF;
END_IF;



@SaText @RT(25)ACalcClampForceController 1 @TL(36)
IF NOT g_bClampPressSensorsAvailable THEN   
   //Only position controller available without force sensor 
   mrSetPos := mrSetPosProfileCoining; 
   mrSetVel := mrSetVelProfileCoining;
ELSE 
   sv_bOutputActive := TRUE;   
    
   //pid controller of clamp force 
   fbPIDControllerForce.Calculate(rActVal:= sv_rClampForceAct,
                                  rSetVal:= mrFilteredClampForceCoining,
                                  bEnable:= TRUE);
   //Control value    
   mrUCtrlForce := fbPIDControllerForce.Calculate.rOutVal;
    
   //Limiter  
   mrPosProfileLimitMin := LIMIT(0.0, (sv_rToggleLeverPosition - mrUCtrlForce), mrForceControlStartPos); 
   mrSetPos := LIMIT(mrPosProfileLimitMin, mrSetPosProfileCoining, sv_rMoldStroke);  
      
   //Monitoring the P- and I-Part 
   fbPIDControllerForce.GetActValues(rUProp => mrUCtrlForceP,
                                     rUInt => mrUCtrlForceI);
   //Set velocity      
   IF (mrSetPos <> mrSetPosProfileCoining) THEN 
      //force in limitation
      mrSetVel := 0.0;                          
   ELSE     
      //pos in limitation                            
      IF mrSetVelProfileCoining > 0.0 THEN
         mrSetVel :=  rGainOpenLoopBwd * mrSetVelProfileCoining;
      ELSE 
         mrSetVel :=  rGainOpenLoopFwd * mrSetVelProfileCoining;
      END_IF;                                   
   END_IF;       
END_IF;          



@SaText @RT(20)AInitValveController 1 @TL(43)
IF g_bMoldValve THEN
   IF g_bPressureSensorsAvailable THEN
     
      dCycleTime := GET_TASK_INTERVAL();
    
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                             bPositionIncreasing := FALSE);
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;    
   END_IF;
   
   bStart := TRUE;
END_IF;


@SaText @RT(25)AInitClampForceController 1 @TL(32)
IF g_bClampPressSensorsAvailable THEN
    
   //Start position of force control
   mrForceControlStartPos := sv_rToggleLeverPosition;
    
   //Controller parameters
   dCycleTime := GET_TASK_INTERVAL();
   pidParamForce.rKR := sv_ForceControlParam.rP;
   pidParamForce.dTN := sv_ForceControlParam.dTN;
   pidParamForce.dTV := sv_ForceControlParam.dTV;
   pidParamForce.rKS := sv_ForceControlParam.rKS;

   //Limitation of control value                 
   pidParamForce.rUMax := sv_rMoldStroke;
   pidParamForce.rUMin := -sv_rMoldStroke;        

   //Parameterize pid controller
   fbPIDControllerForce.Par(dCycleTime := dCycleTime,
                            Param := pidParamForce);               
   //Initialization of pid controller        
   fbPIDControllerForce.Init(rActVal := 0.0,
                             rSetVal := 0.0,
                             rOpenLoopSetVal := 0.0,
                             rOutVal := 0.0);
   mrUCtrlForce := 0.0;
   mrUCtrlForceI := 0.0; 
   mrUCtrlForceP := 0.0;  
    
   rGainOpenLoopFwd := sv_ServoValveControlData.rGainOpenLoopFwd;
   rGainOpenLoopBwd := sv_ServoValveControlData.rGainOpenLoopBwd; 
END_IF;


@SaText @RT(14)AProfileOutput 1 @TL(54)
//timer
fbTON(IN := TRUE);               
rTimer := LINT_TO_REAL(TIME_TO_LINT(fbTON.ET)) / 1000000.0;

//postion output
fbPositionProfile(bStart := TRUE,
                  bStop := bStop,
                  rAcceleration := sv_rCoiningPosRamp,
                  bTimeModeVisu := TRUE,                     
                  ProfileICM := sv_CoiningPos,            
                  rTimer := rTimer,
                  rSetPos => mrSetPosProfileCoining,
                  rSetVel => mrSetVelProfileCoining,
                  rSetAcc => mrSetAccProfileCoining);

//clamp force output
fbClampForceProfile(bStart := TRUE,
                    bStop := bStop,
                    rAcceleration := sv_rCoiningClampForceRamp,
                    bTimeModeVisu := TRUE,
                    ProfileICM := sv_CoiningForceVis,
                    rTimer := rTimer,
                    rSetPos => mrSetClampForceProfileCoining);

//Filter PT1
PTN.Calculate(rInVal := mrSetClampForceProfileCoining, 
              rOutVal => mrFilteredClampForceCoining, 
              calcStatus => calcStatus);

//valve direction
IF fbPositionProfile.rAlgebraSign = 1.0 THEN
   sv_bFwdActive := FALSE;
   sv_bBwdActive := TRUE;    
   rMaxSpeedCoining := sv_rMaxSpeedBwd;    
ELSIF fbPositionProfile.rAlgebraSign = -1.0 THEN
   sv_bFwdActive := TRUE;    
   sv_bBwdActive := FALSE;    
   rMaxSpeedCoining := sv_rMaxSpeedFwd;        
END_IF;

//Calculation of pump output
IF rMaxSpeedCoining = 0.0 THEN
   rMaxSpeedCoining := 1.0; 
END_IF;
rVelOutputICM := ABS(mrSetVelProfileCoining / rMaxSpeedCoining * 100.0);
b := WRITE_SVREAL_DIRECT(sv_rVelOutputICM, rVelOutputICM);

mbCoiningActive := (NOT fbPositionProfile.bReady)
                            AND (NOT fbClampForceProfile.bReady);    

b := WRITE_SV_DIRECT(sv_MoldCoiningTimesAct.dActMoveTime, fbTON.ET);

sv_bOutputActive := mbCoiningActive;  


@SaText @RT(18)AInitProfileOutput 1 @TL(16)
//Initialize timer to build profile
fbTON(IN := FALSE, PT := t#2d);

//Initialization of instance 
fbPositionProfile(bStart := FALSE,          
                  rStartPosition := sv_rToggleLeverPosition);

fbClampForceProfile(bStart := FALSE);

PTN.Par(dCycleTime := cycleTime, 
        Param := ParamPTN, 
        parStatus => parStatus);

PTN.Init(rOutVal := rInit);



@SaText @RT(26)AUpdateCalcValveController 1 @TL(27)
//update the control data 
IF (bOldFwdActive <> sv_bFwdActive) OR (mrSetAccProfileCoining = 0.0) THEN
    
   IF mrSetVelProfileCoining > 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPBwd;  
   ELSIF mrSetVelProfileCoining < 0.0 THEN
      rGainP := sv_ServoValveControlData.rGainPFwd;
   ELSE
      //stand still 
      IF mrSetPos > sv_rToggleLeverPosition THEN
         rGainP := sv_ServoValveControlData.rGainPBwd;
         bPosError := TRUE; 
      ELSE 
         rGainP := sv_ServoValveControlData.rGainPFwd;
         bPosError := FALSE;
      END_IF;
   END_IF;
    
   abValveController.aPar(rGainP := rGainP, 
                          bPositiveVoltageIncreasing := 
                                    sv_ServoValveControlData.bPositiveVoltageIncreasing,
                          bPositionIncreasing := sv_bBwdActive);
   bOldFwdActive := sv_bFwdActive;  
END_IF;




@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(62)
IF IS_LINKED(sv_ICMMode) THEN
    
    //copy for the force profile
    IF sv_CoiningPosVis.Profile.iNoOfPoints = 0 THEN
       sv_CoiningPosVis.Profile.iNoOfPoints := 1; 
    END_IF;           

    sv_CoiningForceVis.Profile.iNoOfPoints := sv_CoiningPosVis.Profile.iNoOfPoints;  
    sv_CoiningPos.Profile.iNoOfPoints := sv_CoiningPosVis.Profile.iNoOfPoints; 
    
    FOR i := 1 TO sv_CoiningForceVis.Profile.iNoOfPoints DO
        
       //copy the time duration of pos profile
       sv_CoiningForceVis.Profile.Points[i].rStartPos := sv_CoiningPosVis.Profile.Points[i].rStartPos;  
        
       //calculate the max available distance
       IF sv_rCoiningPosRamp = 0.0 THEN
          sv_rCoiningPosRamp := 1.0; 
       END_IF;
        
       rTimeMid := sv_CoiningPosVis.Profile.Points[i].rStartPos - sv_CoiningPosVis.Profile.Points[i].rVelocity / sv_rCoiningPosRamp * 2.0;  
        
       IF rTimeMid < 0.0 THEN
          IF sv_CoiningPosVis.Profile.Points[i].rStartPos <> 0.0 THEN
             sv_rCoiningPosRamp := 2.0 * sv_CoiningPosVis.Profile.Points[i].rVelocity / sv_CoiningPosVis.Profile.Points[i].rStartPos; 
          END_IF;                                                                                                    
          rTimeMid := 0.0;         
       END_IF;
        
       rDistMax := MAX((sv_CoiningPosVis.Profile.Points[i].rStartPos + rTimeMid) * sv_CoiningPosVis.Profile.Points[i].rVelocity / 2.0, rDistMin); 

       //plausibility for the target position
       IF i = 1 THEN
         abLintabApplyToggleLever.aCalc(rX:= sv_rMaxPlausFirstCoiningStage);                                                     
       ELSE 
         abLintabApplyToggleLever.aCalc(rX:= sv_CoiningPosVis.Profile.Points[i - 1].rPressure);                                      
       END_IF; 
        
       //mold pos in hmi of last stage -> toggle lever pos
       rTempToggleLeverPos := abLintabApplyToggleLever.aCalc.rY;  
        
       //min toggle lever pos 
       abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos - rDistMax));       
       rTempMoldPosMin := abLintabApplyToggleLever.aCalcInv.rX;   
         
       //max toggle lever pos  
       abLintabApplyToggleLever.aCalcInv(rY:= (rTempToggleLeverPos + rDistMax));       
       rTempMoldPosMax := abLintabApplyToggleLever.aCalcInv.rX;   
           
       sv_CoiningPosVis.Profile.Points[i].rPressRamp :=  MAX(0.0,  rTempMoldPosMin);        //plaus min
       sv_CoiningPosVis.Profile.Points[i].rVelRamp :=  MIN(rTempMoldPosMax, sv_rMoldStroke);  //plaus max
        
       //mold position -> toggle lever pos
       abLintabApplyToggleLever.aCalcInv(rY:= sv_CoiningPosVis.Profile.Points[i].rPressure);       
    
       sv_CoiningPos.Profile.Points[i].rPressure := abLintabApplyToggleLever.aCalcInv.rX;    
       sv_CoiningPos.Profile.Points[i].rStartPos := sv_CoiningPosVis.Profile.Points[i].rStartPos;
       sv_CoiningPos.Profile.Points[i].rVelocity := sv_CoiningPosVis.Profile.Points[i].rVelocity;
        
   END_FOR;    
END_IF;    

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
IF g_bMoldValve THEN
   IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
      rOffsetPos := sv_ValveData.rValveOffsetFwd;
      rOffsetNeg := sv_ValveData.rValveOffsetBwd;       
   ELSE    
      rOffsetPos := sv_ValveData.rValveOffsetBwd;
      rOffsetNeg := sv_ValveData.rValveOffsetFwd;    
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(35)
IF IS_LINKED(sv_ICMMode) THEN
    
   //Disable coining in case of sequential mode without venting
   IF (sv_VentingActivateMode = nDeactivate) AND (sv_ICMMode = nSequentialICM) THEN 
      sv_CoiningActivateMode := nDeactivate;
   END_IF;
    
   //Disable input field 
   IF sv_CoiningActivateMode = nAfterInject THEN
      sv_bUseDelayTimeCoining := TRUE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := FALSE;
   ELSIF sv_CoiningActivateMode = nInjectPosition THEN
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := TRUE;
   ELSIF sv_CoiningActivateMode = nInjectPressure THEN
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := TRUE;
      sv_bUseInjectPosCoining := FALSE;
   ELSE 
      sv_bUseDelayTimeCoining := FALSE; 
      sv_bUseInjectPressCoining := FALSE;
      sv_bUseInjectPosCoining := FALSE;
   END_IF;
    
   //Enable input field for mold start pos 
   IF (sv_VentingActivateMode = nDeactivate)AND(sv_CoiningActivateMode <> nDeactivate) THEN
      sv_bEnableMoldStartPosCoining := TRUE;
   ELSE 
      sv_bEnableMoldStartPosCoining := FALSE;
   END_IF;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
