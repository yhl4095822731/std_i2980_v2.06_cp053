IMPORT_OVER_LISTFILE
 GET_MY_FU_NAME
, WRITE_SVREAL_DIRECT
, GET_TASK_INTERVAL
, WRITE_SV_DIRECT
, KSWO_AddVariable
, KCTRL_YXGen_Input_Default
, cLockGroupClampingUnit
, cLockGroupSafetyGateMold
, cLockGroupMotor
, cLockGroupRotateInjectPos
, cMoveFwd
, nActive
, nDeviceState
, cMoveFwdInterPos
, nInactive
, nSetup
, cMoveFwdForMHAdjust
, cMoveFwdForMHAdjustSetup
, tnCalibState_Error
, KCTRL_Ret_OK
, MAX_VOLTAGE
, KCTRL_YXGen_RampType_Sin
, nDeactivate
, cMaxIntermediateConditions
, tsMoveData
, KAPPL_VisProfile
, tnOperationMode
, tsVelPre
, KCTRL_Lintab_Point
, tsCalibMovement
, tsMinOutput
, tsSetTimes
, tsActTimes
, KAPPL_LintabData
, tyInstanceListArray
, tsClampForces
, KCTRL_Lintab_Param_Light
, tServoValveControlData
, tServoValveData
, tServoValveControlSet
, tsToggleLeverSplineData
, tServoValveConstructionData
, tnICMMode
, tnICMActivateMode
, tsPropValveParams
, tsMoveCtrl
, ABProfileMovement
, ABConstMovement
, ABConstCalib
, ABLintabApply
, KCTRL_Lintab_Light
, ABValveController
, KCTRL_YXGen_LightB
, KCTRL_YXGenParam
, KCTRL_YXGen_InputType
, KCTRL_YXGen_Accelerations
, KCTRL_ProfPoint
, KAPPL_ProfileData
, ABStepOutput
, KAPPL_Plastics_ProfileOutput
, ABProportionalValve
, tCalculatedProfiles
, ABMovementRegister
, tsAlarm
, FBSetMovementState
, FBStandStill
, ABMoldProtection
, TON
, FBDebugTrace2
, FBConstOutputRamp
, ABEstimatePressure
, KSWO_Status

END_IMPORT

ALGORITHM_BLOCK ABMoveClose #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_MoveClose : tsMoveData;
 sv_MoveCloseInterPos : tsMoveData;
 sv_rMoldPosition : REAL;
 sv_rPressure : REAL;
 sv_rVelocity : REAL;
 sv_iActiveStage : DINT;
 sv_MoldFwdProfVis : KAPPL_VisProfile;
 sv_rFwdInterruptAccel : REAL;
 sv_rFwdInterruptDeaccel : REAL;
 sv_rFwdInterruptPosition : REAL;
 sv_bMoldClosed : BOOL;
 sv_OperationMode : tnOperationMode;
 sv_ConstFwdVis : tsVelPre (* const output for mold close movement *);
 sv_TmpLintabPoint : KCTRL_Lintab_Point;
 ai_Position : REAL (* analog input value from transducer *);
 sv_dStandStillDetectTime : TIME (* time for standstill detection *);
 sv_rMaxVoltageDiff : REAL (* max. voltage difference to detect stand still *);
 sv_bPreOutputReady : BOOL (* PreOutput is ready *);
 sv_MoveCloseForMHAdj : tsMoveData (* move forward for mold height auto adjustment *);
 sv_bOutputActive : BOOL (* Output is active *);
 sv_bDoTransducerCalib : BOOL;
 sv_bTransducerError : BOOL;
 sv_CalibState : tsCalibMovement;
 sv_MinOutputFwd : tsMinOutput;
 sv_dMoldProtectTimeSet : TIME;
 sv_dMoldProtectTimeAct : TIME;
 sv_MoldCloseTimesSet : tsSetTimes;
 sv_MoldCloseTimesAct : tsActTimes;
 sv_rMoldStroke : REAL;
 sv_bInitStart : BOOL;
 sv_LintabOutFwdP : KAPPL_LintabData;
 sv_LintabOutFwdV : KAPPL_LintabData;
 sv_rPressureAbs : REAL;
 sv_rVelocityAbs : REAL;
 sv_bInitDone : BOOL;
 sv_rMaxSpeedFwd : REAL;
 sv_MoveCloseForMHAdjSetup : tsMoveData;
 sv_ToggleLeverLintabDerive : KAPPL_LintabData (* derivation calculated from sv_ToggleLeverLintab *);
 sv_CloseInterstopDeadTime : TIME;
 sv_CloseManualDelayTime : TIME;
 sv_dCalculatedDurationClose : TIME (* Calculated duration for mold close *);
 sv_MoldBwdProfVis : KAPPL_VisProfile;
 sv_InstanceDataCloseInterPos : tyInstanceListArray (* array with target positions of mold close interpos movements *);
 sv_ConstHiPressVis : tsVelPre;
 sv_ClampForceBuildUpTimeSet : TIME (* set build up time for clamp pressure *);
 sv_ClampForceBuildUpTimeAct : TIME (* act build up time for clamp pressure *);
 sv_bMoldLockStageActive : BOOL (* mold lock stage active *);
 sv_bClampForceBuildUpWithTime : BOOL (* use time dependent clamp force build up *);
 sv_bClampForceReached : BOOL (* Clamp force reached *);
 sv_dClampPressureCheckTime : TIME;
 sv_ClampForce : tsClampForces (* actual clamp force *);
 sv_MoldLockTimesAct : tsActTimes;
 sv_MoldLockTimesSet : tsSetTimes;
 sv_rClampForceAct : REAL;
 sv_bCloseActive : BOOL (* mold close is active *);
 sv_rMoldValveOutput : REAL;
 sv_ValveCharacteristicLintab : KCTRL_Lintab_Param_Light;
 sv_ToggleLeverLintab : KAPPL_LintabData (* derivation calculated from sv_ToggleLeverLintab *);
 sv_ToggleFwdProfVis : KAPPL_VisProfile;
 sv_InstanceDataCloseToggleInter : tyInstanceListArray (* array with target positions of mold close interpos movements *);
 sv_rToggleLeverPosition : REAL;
 sv_rToggleLeverStroke : REAL (* Opening Stroke of toggle lever *);
 sv_rMoldPressure1 : REAL (* pressure mold fwd *);
 sv_rMoldPressure2 : REAL (* pressure mold bwd *);
 sv_rToggleLeverVelEstimate : REAL;
 sv_ServoValveControlData : tServoValveControlData;
 sv_ValveData : tServoValveData;
 sv_ServoValveControlSet : tServoValveControlSet;
 sv_bUseValve : BOOL;
 sv_ToggleLeverSplineData : tsToggleLeverSplineData;
 sv_ConstructionData : tServoValveConstructionData;
 sv_rInterstopTolerance : REAL;
 sv_bMoveIdent : BOOL;
 sv_rIdentPosition : REAL;
 sv_rIdentStopRamp : REAL;
 sv_dSetDelayTimeOffFwd : TIME;
 sv_rSmoothFactor : REAL;
 sv_bPresMoldHeightAdjustActive : BOOL;
 sv_rMinAmplification : REAL (* minimum amplification *);
 sv_rMaxAmplification : REAL (* maximum amplification *);
 sv_rToggleLeverSetPosition : REAL;
 sv_rSetMoldStartPosition : REAL;
 sv_rActMoldStartPosition : REAL;
 sv_bICMStartPosReached : BOOL;
 sv_ICMMode : tnICMMode;
 sv_CoiningActivateMode : tnICMActivateMode;
 sv_VentingActivateMode : tnICMActivateMode;
 sv_dActCloseTime : TIME (* includes pressure build up time *);
 sv_bDoPumpPressureCalib : BOOL;
 sv_rMoldPropValveParams : tsPropValveParams;
 sv_rMoldValvePressureDropClose : REAL;
 sv_rFastVelocityFactor : REAL;
 do_FastClose : BOOL;
 sv_bPumpUseProfileVelociy : BOOL;
 sv_CalculatedProfileFwd : tCalculatedProfiles;
 sv_CalculatedProfileFwdToggle : tCalculatedProfiles;
 sv_bStandStillDetected : BOOL;
END_VAR

SYSTEM_OBJECT
 erMoldNotClosed : ALARM;
 erMoldPosNotCorrect : ALARM;
 PU_Task_7 : TASK;
 TaskSlow : TASK;
 TaskAnalog : TASK;
 PU_Task_3 : TASK;
 PU_Task_13 : TASK;
END_OBJECT

VAR_EXTERNAL
 pSysPressure : REFTO REAL;
 g_MoveCtrl : tsMoveCtrl;
 g_bDirectLockAvailable : BOOL;
 g_bMoldValve : BOOL;
 g_bPressureSensor1Available : BOOL;
 g_bPressureSensor2Available : BOOL;
 g_bPressureSensorsAvailable : BOOL;
 g_b2Platen : BOOL;
END_VAR

VAR
 rTankPressure : REAL := 1.0;
 rMaxVoltageValve : REAL;
 abMoldClose : ABProfileMovement;
 abMoldCloseConst : ABConstMovement;
 abMoldFwdCalib : ABConstCalib;
 abLintabApplyVel : ABLintabApply;
 abLintabApplyPres : ABLintabApply;
 abToggleLeverLintab : KCTRL_Lintab_Light;
 ToggleLeverLintabPar : KCTRL_Lintab_Param_Light;
 abConstHiPress : ABConstMovement;
 mrStartOutputPres : REAL;
 mrStartOutputVel : REAL;
 rInterruptTogglePosition : REAL;
 abLintabApplyToggleSlow : ABLintabApply (* block for usage in TaskSlow *);
 abLintabApplyToggle : ABLintabApply;
 abValveController : ABValveController;
 bStart : BOOL;
 abYXGenLightB : KCTRL_YXGen_LightB;
 Param : KCTRL_YXGenParam;
 InputType : KCTRL_YXGen_InputType := KCTRL_YXGen_Input_Default;
 Accelerations : KCTRL_YXGen_Accelerations;
 StopPoint : KCTRL_ProfPoint;
 rYXSetPos : REAL;
 rYXSetVel : REAL;
 rYXSetAccel : REAL;
 rYXSetJerk : REAL;
 CalcedVelocityProfile : KAPPL_ProfileData;
 rOffsetPos : REAL := 1.0;
 rOffsetNeg : REAL := -1.2;
 abMoldCloseStep : ABStepOutput;
 PumpVelocityProfile : KAPPL_ProfileData;
 fbPumpVelocityOutput : KAPPL_Plastics_ProfileOutput;
 mrPumpVelocity : REAL;
 mrSetVelocity : REAL;
 mrUP : REAL;
 mrUD : REAL;
 abPropValve : ABProportionalValve;
 mrAreaOutletFactor : REAL;
 mrPropValveOutput : REAL;
 mbUsePropValve : BOOL;
 mrSetFlowOutlet : REAL;
 mrPressOutlet : REAL;
 mrSign : REAL;
 mbFastCloseLinked : BOOL;
END_VAR

ALGORITHM aRegister


VAR
 abMoveCloseForMHAdjRegister : ABMovementRegister;
 abMoveCloseForMHAdjSetupReg : ABMovementRegister;
 abMoveCloseRegister : ABMovementRegister;
 abMoveCloseInterPosRegister : ABMovementRegister;
 Alarm : tsAlarm;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveClose.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveClose.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveClose.pdActiveTimeAct := @sv_dActCloseTime;
sv_MoveClose.pdTimeLimit     := @sv_MoldCloseTimesSet.dMaxMoveTime;
sv_MoveClose.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveClose.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveClose.LockGroups[3] := cLockGroupMotor;
sv_MoveClose.LockGroups[4] := cLockGroupRotateInjectPos;
sv_MoveClose.LockGroups[5] := cLockGroupMoldNutOpen;
sv_MoveClose.pbPosReached := @sv_bMoldClosed;
sv_MoveClose.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movMoldFwd.gif");
Alarm.AlarmId := erMoldNotClosed;
sv_MoveClose.Alarm := Alarm;
abMoveCloseRegister.aRegister(@sv_MoveClose);


// register movement to intermediate position
sv_MoveCloseInterPos.pdActiveTimeAct := @sv_MoldCloseTimesAct.dActMoveTime;
sv_MoveCloseInterPos.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseInterPos.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movMoldInterposFwd.gif");    
Alarm.AlarmId := erMoldPosNotCorrect;
sv_MoveCloseInterPos.Alarm := Alarm;
abMoveCloseInterPosRegister.aRegister(@sv_MoveCloseInterPos);

// register movement for automatic mold height adjustment
sv_MoveCloseForMHAdj.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveCloseForMHAdj.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveCloseForMHAdj.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseForMHAdj.sIconPath := sv_MoveClose.sIconPath;
sv_MoveCloseForMHAdj.pbPosReached := @sv_bMoldClosed;       
Alarm.AlarmId := erMoldNotClosed;
sv_MoveCloseForMHAdj.Alarm := Alarm;
abMoveCloseForMHAdjRegister.aRegister(@sv_MoveCloseForMHAdj);


sv_MoveCloseForMHAdjSetup.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveCloseForMHAdjSetup.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveCloseForMHAdjSetup.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseForMHAdjSetup.sIconPath := sv_MoveClose.sIconPath;
sv_MoveCloseForMHAdjSetup.pbPosReached := @sv_bMoldClosed;
Alarm.AlarmId := erMoldNotClosed;
sv_MoveCloseForMHAdjSetup.Alarm := Alarm;
abMoveCloseForMHAdjSetupReg.aRegister(@sv_MoveCloseForMHAdjSetup);



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_TEMP
 b : BOOL;
 rMoldValveOutput : REAL;
 dActCloseTime : TIME;
END_VAR

VAR
 dummy : DINT;
 fbSetMovementState : FBSetMovementState;
 fbStandStill : FBStandStill;
 bStandStill : BOOL;
 abMoldProtection : ABMoldProtection;
 bPosReached : BOOL;
 rTargetPos : REAL;
 rAmplification : REAL;
 bError : BOOL;
 iErrorInfo : DINT;
 fbBuildUpTimer : TON;
 fbClampPreTON : TON;
 fbDebugTrace2 : FBDebugTrace2;
 fbConstOutputRamp : FBConstOutputRamp;
 rEndValue : REAL;
 rStopRamp : REAL;
 rMinOutput : REAL := 10.0 (* % *);
 rOutput : REAL;
 rSetPos : REAL;
 dCycleTime : TIME;
 rSetVelocity : REAL;
 rQNom : REAL;
 rPNom : REAL;
 rQNomPB : REAL;
 rPNomPB : REAL;
 rPressure1 : REAL;
 rPressure2 : REAL;
 abEstimatePressure : ABEstimatePressure;
 bStopActive : BOOL;
 rCycleTime : REAL;
 bICMInterruptStop : BOOL;
 dValveOffDelay : TIME;
 dummypoint : KCTRL_Lintab_Point;
 rPositionDown : REAL;
 bInitDone : BOOL;
 rSetFlow : REAL;
 rPessureDrop : REAL := 10.0 (* pressure drop at valve edge *);
 rSetVelocityValve : REAL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
aStart (P);
aICMInterruptStop (P);
END_STEP

ACTION aStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveFwd,
                   State    := nActive);
sv_bCloseActive := TRUE;
fbDebugTrace2(nDeviceState, 'Mold close started');

;#END_EDIT_BLOCK END_ACTION (*aStart*)

(* steps *)
STEP s_CheckOperationMode:
END_STEP

STEP S_CheckIfCalib:
END_STEP

STEP Step16:
END_STEP

STEP S_ConstMove:
AResetConstBlock (P);
AConstOutput (N);
END_STEP

STEP S_FwdToEnd:
AResetCalibBlock2 (P);
ATransducerCalib2 (N);
END_STEP

STEP S_Calib:
AResetCalibBlock (P);
ATransducerCalib (N);
ACheckCalibError (N);
END_STEP

STEP S_MoveIdent:
AResetIdentBlock (P);
AStepOutput (N);
END_STEP

STEP S_ProfileMove:
AResetProfileBlock (P);
AParToggleLeverAmplification (P);
ACalcToggleLeverAmplification (N);
AICMInterruptPos (P);
AProfileOutput (N);
AMoldCloseTime (N);
AMoldProtection (N);
AInitValveController (P);
ACalcValveController (N);
ACalcPumpVelocity (N);
ACopySetPositionClose (P0);
AResetEndOutputPressure (P0);
END_STEP

ACTION ACopySetPositionClose: #BEGIN_EDIT_BLOCK
IF bStop THEN
   b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, sv_rToggleLeverPosition);
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, abMoldClose.aRun.rEndPosition); 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACopySetPositionClose*)
ACTION AResetEndOutputPressure: #BEGIN_EDIT_BLOCK
// use EndOutpuPressure only before HiPress
IF (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressure, 0.0);
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, sv_rPressure);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetEndOutputPressure*)
STEP S_Check2Platen:
END_STEP

STEP S_Const_HiPress:
AResetConstOutputHiPress (P);
AResetStandStillDetect (P);
AConstOutputHiPress (N);
AInitValveControllerHiPRess (P);
ACalcValveControllerHiPress (N);
ACheckClampForce (N);
ADetectStandStillMoldAdjust (N);
ACopySetPositionHiPress (P0);
END_STEP

ACTION ACopySetPositionHiPress: #BEGIN_EDIT_BLOCK
b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, sv_rToggleLeverPosition);

;#END_EDIT_BLOCK END_ACTION (*ACopySetPositionHiPress*)
STEP S_ProfileMoveForMHAdj:
Action22 (N);
AResetConstBlock (P);
AResetStandStillDetect (P);
ADetectStandStill (N);
AConstOutputMHAdjustSetup (N);
END_STEP

ACTION Action22: #BEGIN_EDIT_BLOCK
bPosReached := sv_bMoldClosed;
rTargetPos := -10.0;

;#END_EDIT_BLOCK END_ACTION (*Action22*)
STEP Step17:
Action21 (P);
AResetConstBlock (P);
AResetStandStillDetect (P);
ADetectStandStill (N);
AConstOutputMHAdjustSetup (N);
END_STEP

ACTION Action21: #BEGIN_EDIT_BLOCK
bPosReached := FALSE;
rTargetPos := 0.0;

;#END_EDIT_BLOCK END_ACTION (*Action21*)
STEP READY:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   sv_rMoldValveOutput := 0.0;
END_IF;

//injection compression molding
IF bICMInterruptStop THEN
    IF NOT bStop THEN
        sv_bICMStartPosReached := TRUE;
        //copy the actual start pos of ICM
        sv_rActMoldStartPosition := sv_rMoldPosition;
    END_IF;
    
    //set pos-raach for mold close if use ICM 
    sv_MoveClose.pbPosReached := @sv_bICMStartPosReached;
    bICMInterruptStop := FALSE;
END_IF;

bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveFwd,
                   State    := nInactive);
sv_bCloseActive := FALSE;
fbDebugTrace2(nDeviceState, 'Mold close ready');

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
GO_ON_TRANSITION TMoveFwd (* TMoveFwd *) FROM START TO s_CheckOperationMode :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveId = cMoveFwd OR
g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TSetupMode (* TSetupMode *) FROM s_CheckOperationMode TO S_CheckIfCalib :=  #BEGIN_EDIT_BLOCK
(sv_OperationMode = nSetup) AND NOT sv_bPresMoldHeightAdjustActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotCalib (* TNotCalib *) FROM S_CheckIfCalib TO Step16 :=  #BEGIN_EDIT_BLOCK
NOT sv_bDoTransducerCalib AND 
NOT sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoPumpPressureCalib (* TNoPumpPressureCalib *) FROM Step16 TO S_ConstMove :=  #BEGIN_EDIT_BLOCK
NOT sv_bDoPumpPressureCalib
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TConstMoveReady (* TConstMoveReady *) FROM S_ConstMove TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldCloseConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveFwdToEnd (* TMoveFwdToEnd *) FROM Step16 TO S_FwdToEnd :=  #BEGIN_EDIT_BLOCK
sv_bDoPumpPressureCalib
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TFwdEnd (* TFwdEnd *) FROM S_FwdToEnd TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldFwdCalib.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCalibActivated (* TCalibActivated *) FROM S_CheckIfCalib TO S_Calib :=  #BEGIN_EDIT_BLOCK
sv_bDoTransducerCalib
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCalibReady (* TCalibReady *) FROM S_Calib TO READY :=  #BEGIN_EDIT_BLOCK
 NOT abMoldFwdCalib.aRun.bActive OR bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveIdentActivated (* TMoveIdentActivated *) FROM S_CheckIfCalib TO S_MoveIdent :=  #BEGIN_EDIT_BLOCK
sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentReady (* TMoveIdentReady *) FROM S_MoveIdent TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldCloseStep.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotSetup (* TNotSetup *) FROM s_CheckOperationMode TO S_ProfileMove :=  #BEGIN_EDIT_BLOCK
(sv_OperationMode <> nSetup) OR sv_bPresMoldHeightAdjustActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileMoveReady (* TProfileMoveReady *) FROM S_ProfileMove TO S_Check2Platen :=  #BEGIN_EDIT_BLOCK
NOT abMoldClose.aRun.bActive
AND NOT bStop
AND NOT abMoldClose.aRun.bError
AND NOT abMoldClose.aRun.bTimeOut
AND (g_MoveCtrl.pData^.MoveId <> cMoveFwdInterPos)
AND NOT bICMInterruptStop
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoldCloseStopped (* TMoldCloseStopped *) FROM S_ProfileMove TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldClose.aRun.bActive

;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNo2PLaten (* Trans21 *) FROM S_Check2Platen TO S_Const_HiPress :=  #BEGIN_EDIT_BLOCK
NOT g_b2Platen
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION T2Platen (* Trans22 *) FROM S_Check2Platen TO READY :=  #BEGIN_EDIT_BLOCK
g_b2Platen
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileHiPressReady (* TProfileHiPressReady *) FROM S_Const_HiPress TO READY :=  #BEGIN_EDIT_BLOCK
NOT sv_bOutputActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveFwdForMoldHeightAdjust (* TMoveFwdForMoldHeightAdjust *) FROM START TO S_ProfileMoveForMHAdj :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveId = cMoveFwdForMHAdjust
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TProfileMoveReady2 (* TProfileMoveReady2 *) FROM S_ProfileMoveForMHAdj TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldCloseConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveFwdForMHAdjustSetup (* TMoveFwdForMHAdjustSetup *) FROM START TO Step17 :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveId = cMoveFwdForMHAdjustSetup
;#END_EDIT_BLOCK
(*Comment :try to move to pos 0
detect standstill, when pos is not reached*)
END_TRANSITION

TRANSITION TMoveFwdForMHAdjustSetupReady (* TMoveFwdForMHAdjustSetupReady *) FROM Step17 TO READY :=  #BEGIN_EDIT_BLOCK
NOT abMoldCloseConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReady (* TReady *) FROM READY TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AResetCalibBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := FALSE;
abMoldFwdCalib.aRun(bStart := FALSE,
                    LintabPoint := sv_TmpLintabPoint);
IF abMoldFwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock*)
ACTION AResetProfileBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldClose.aRun(bStart := FALSE);
sv_bClampForceReached := FALSE;
sv_ClampForceBuildUpTimeAct := T#0s;

;#END_EDIT_BLOCK END_ACTION (*AResetProfileBlock*)
ACTION AResetConstBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;
IF sv_bMoveIdent OR sv_rIdentPosition > 0.0 THEN
   sv_rFwdInterruptPosition := sv_rIdentPosition;
END_IF;
abMoldCloseConst.aRun(bStart := FALSE);
                   

;#END_EDIT_BLOCK END_ACTION (*AResetConstBlock*)
ACTION ADetectStandStill: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill THEN
    fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := sv_dStandStillDetectTime,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);
END_IF;

sv_bStandStillDetected := bStandStill;



;#END_EDIT_BLOCK END_ACTION (*ADetectStandStill*)
ACTION AParToggleLeverAmplification: #BEGIN_EDIT_BLOCK
// parametrization
ToggleLeverLintabPar.Mode.bZeroExtrapolation := FALSE;
ToggleLeverLintabPar.Mode.bLinearExtrapolation := TRUE;
ToggleLeverLintabPar.Mode.bSetNegativeValuesToZero :=FALSE;
ToggleLeverLintabPar.rXOffs := 0.0;
ToggleLeverLintabPar.rYOffs := 0.0;
ToggleLeverLintabPar.LintabPoints := sv_ToggleLeverLintabDerive.LintabPoints;
abToggleLeverLintab.Par(Param:=ToggleLeverLintabPar);

;#END_EDIT_BLOCK END_ACTION (*AParToggleLeverAmplification*)
ACTION ACalcToggleLeverAmplification: #BEGIN_EDIT_BLOCK
// calculate
abToggleLeverLintab.Calculate(rX:=sv_rMoldPosition);

IF ((abToggleLeverLintab.Calculate.rY) < sv_rMinAmplification) THEN
   //use at least a minimum value
   rAmplification := sv_rMinAmplification;
ELSIF ((abToggleLeverLintab.Calculate.rY) > sv_rMaxAmplification) THEN
   //don´t exceed a maximum value
   rAmplification := sv_rMaxAmplification;
ELSE
   //use calculated value
   rAmplification := abToggleLeverLintab.Calculate.rY;
END_IF;

IF bStop OR (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) OR bICMInterruptStop OR g_b2Platen THEN
   //movement interrupted (button released or locked) or movement to interrupt position is executed
   //or 2 platen IMM
   //-> use set valve delay time
   dValveOffDelay := sv_MoldCloseTimesSet.dSetDelayTimeValve;
ELSE
   //valve delay is done after high pressure build up
   //-> set valve delay for profile movement to 0.0s 
   dValveOffDelay := t#0.0s;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACalcToggleLeverAmplification*)
ACTION ACheckCalibError: #BEGIN_EDIT_BLOCK
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckCalibError*)
ACTION ACheckClampForce: #BEGIN_EDIT_BLOCK
fbClampPreTON(IN := sv_rClampForceAct > sv_ClampForce.rSetClampForce,
              PT := sv_dClampPressureCheckTime);
IF g_bDirectLockAvailable THEN
   IF NOT sv_bClampForceReached THEN
      IF NOT sv_bClampForceBuildUpWithTime THEN
         IF fbClampPreTON.Q THEN
            sv_bClampForceReached := TRUE;
         END_IF;
      ELSE
         fbBuildUpTimer(IN := sv_bMoldLockStageActive, 
                        PT := sv_ClampForceBuildUpTimeSet,
                        Q => sv_bClampForceReached,
                        ET => sv_ClampForceBuildUpTimeAct);
      END_IF;
   END_IF;
ELSE
   sv_bClampForceReached := sv_bMoldClosed; 
END_IF;


;#END_EDIT_BLOCK END_ACTION (*ACheckClampForce*)
ACTION AResetConstOutputHiPress: #BEGIN_EDIT_BLOCK
abConstHiPress.aRun(bStart := FALSE, // reset start flag
                    bStop := TRUE,
                    dMaxTime := T#0s);  // ignore timeout before start
sv_bMoldLockStageActive := TRUE;
sv_bClampForceReached := FALSE;
fbBuildUpTimer(IN:=FALSE);
fbClampPreTON(IN := FALSE);

sv_ConstHiPressVis.Pressure.PreOutput.rOutputValue := sv_rPressureAbs;
sv_ConstHiPressVis.Velocity.PreOutput.rOutputValue := mrSetVelocity;//sv_rVelocityAbs is usedd for pump, not for profile
mrStartOutputPres := sv_rPressureAbs;
mrStartOutputVel := mrSetVelocity;//sv_rVelocityAbs is usedd for pump, not for profile

;#END_EDIT_BLOCK END_ACTION (*AResetConstOutputHiPress*)
ACTION ACalcValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN
   IF mbFastCloseLinked AND do_FastClose THEN
      rSetVelocityValve := sv_rFastVelocityFactor * rSetVelocity;
   ELSE
      rSetVelocityValve := rSetVelocity;   
   END_IF;
   IF sv_bPumpUseProfileVelociy THEN
      mrPumpVelocity := rSetVelocity;
   ELSE
      fbPumpVelocityOutput(Start := bStart,
                           Stop  := bStop,
                           ReParam  := FALSE,
                           PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                           StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                           InputValue := sv_rToggleLeverPosition,
                           Interrupt := FALSE,
                           DelayTime := T#0s);   
      IF fbPumpVelocityOutput.Error  THEN
         mrPumpVelocity := rSetVelocity;
      ELSE
         IF ((NOT abMoldClose.aRun.bActive) AND bStop)  THEN
            mrPumpVelocity := 0.0;
         ELSE
            mrPumpVelocity := fbPumpVelocityOutput.Output;      
         END_IF;
      END_IF;         
   END_IF;      
   
   IF sv_ServoValveControlData.bEnable THEN
      IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
           bStopActive := TRUE;    
      ELSE
           bStopActive := FALSE;  
      END_IF;
      
      //rYXSetPos := abYXGenLightB.Calculate.rS;  -> calculate after controller call
      rYXSetVel := rSetVelocityValve;
             
      IF NOT g_bPressureSensor1Available THEN
         abYXGenLightB.Calculate(rX:=sv_rToggleLeverPosition, bStopPointActive:=bStopActive);
         IF (abYXGenLightB.Calculate.calcStatus <> KCTRL_Ret_OK)  THEN
            sv_rMoldValveOutput := 0.0;
            sv_rVelocityAbs := 0.0; 
            RETURN; 
         END_IF; 
         rYXSetAccel := abYXGenLightB.Calculate.rA;
         rYXSetJerk := abYXGenLightB.Calculate.rJ;
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abYXGenLightB.Calculate(rX:=sv_rToggleLeverPosition, bStopPointActive:=bStopActive);
         IF (abYXGenLightB.Calculate.calcStatus <> KCTRL_Ret_OK)  THEN
            sv_rMoldValveOutput := 0.0;
            sv_rVelocityAbs := 0.0; 
            RETURN; 
         END_IF; 
         rYXSetAccel := abYXGenLightB.Calculate.rA;
         rYXSetJerk := abYXGenLightB.Calculate.rJ;
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;          
       
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := rYXSetPos*1.0e-3,
                             rSetVelocity := -rYXSetVel*1.0e-3,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
      mrUP := abValveController.aRun.rUP;
      mrUD := abValveController.aRun.rUD;
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSE
         rMoldValveOutput := 0.5 * (rOffsetPos + rOffsetNeg); 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;
      
      // update reference position
      rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
      // integrator stop at maximum position (profile or interstop) of movement
      IF rYXSetPos < rEndValue  THEN
         rYXSetPos :=  rEndValue;
      END_IF;            

      
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, mrPumpVelocity);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rYXSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rYXSetVel);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetAccel, rYXSetAccel);
   ELSIF sv_bUseValve THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      IF mbUsePropValve THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := mrAreaOutletFactor * (rSetVelocityValve 
                   + sv_ServoValveControlData.rGainPFwd * (sv_rToggleLeverPosition - rYXSetPos)                       
                   + sv_ServoValveControlData.rGainDFwd * (rSetVelocityValve + sv_rToggleLeverVelEstimate));
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
         // update reference position
         rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
         // integrator stop at maximum position (profile or interstop) of movement
         IF rYXSetPos < rEndValue  THEN
            rYXSetPos :=  rEndValue;
         END_IF;            
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abMoldClose.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput);
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
      END_IF;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
   END_IF;

   bStart := FALSE;
ELSIF g_bMoldValve THEN
   IF (sv_bUseValve OR sv_ServoValveControlData.bEnable) THEN
      IF mbFastCloseLinked AND do_FastClose THEN
         rSetVelocityValve := sv_rFastVelocityFactor * rSetVelocity;
      ELSE
         rSetVelocityValve := rSetVelocity;   
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      IF (mbUsePropValve AND sv_ServoValveControlData.bEnable) THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := mrAreaOutletFactor * (rSetVelocityValve
                   + sv_ServoValveControlData.rGainPFwd * (sv_rToggleLeverPosition - rYXSetPos)                       
                   + sv_ServoValveControlData.rGainDFwd * (rSetVelocityValve + sv_rToggleLeverVelEstimate));
         
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
         // update reference position
         rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
         // integrator stop at maximum position (profile or interstop) of movement
         IF rYXSetPos < rEndValue  THEN
            rYXSetPos :=  rEndValue;
         END_IF;            
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abMoldClose.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput);
      END_IF;
   ELSE
       b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
       b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
   END_IF;
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
END_IF;

mrSetVelocity := rSetVelocity;

;#END_EDIT_BLOCK END_ACTION (*ACalcValveController*)
ACTION AInitValveController: #BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
      rEndValue := rInterruptTogglePosition; // use toggle lever position calculated from mold position sv_rFwdInterruptPosition
   ELSE
      rEndValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rStartPos;
   END_IF;
   IF rEndValue < 0.0 THEN
      rEndValue := 0.0;
   END_IF;
   rYXSetPos := sv_rToggleLeverPosition;

   IF NOT bInitDone THEN
      dCycleTime := GET_TASK_INTERVAL();
      rCycleTime := LINT_TO_REAL(TIME_TO_LINT(dCycleTime))/1.0e6;  
      bInitDone := TRUE;
   END_IF;
    
   IF g_bPressureSensorsAvailable THEN
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                             bPositionIncreasing := FALSE);
      rSetPos := sv_rToggleLeverPosition;
      // trajectories generator: s, v, a, j
      abMoldClose.aGetVelocityProfile();
      CalcedVelocityProfile := abMoldClose.aGetVelocityProfile.CalcedVelocityProfile;
      Accelerations.rSoft  := CalcedVelocityProfile.StopAcceleration;
      Accelerations.rStop  := CalcedVelocityProfile.InterAcceleration;
      Accelerations.rStart := CalcedVelocityProfile.Acceleration;
      Param.Mode.RampType    := KCTRL_YXGen_RampType_Sin;
      Param.Mode.bPeriodMode := FALSE;;
      Param.ProfilePoints := CalcedVelocityProfile.ProfilePoints;
    
      abYXGenLightB.Par(dCycleTime:= dCycleTime,
                        Param:=Param,
                        InputType:=InputType);
      abYXGenLightB.ParAccelerations(Accelerations:=Accelerations);
      StopPoint.rX :=rInterruptTogglePosition - sv_rInterstopTolerance; 
      abYXGenLightB.ParStopPoint(StopPoint:=StopPoint); 
      abYXGenLightB.Init(rX0:=sv_rToggleLeverPosition,
                         rY0:=0.0);
      
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;           
   END_IF;
        
   IF sv_MoldFwdProfVis.rMaxRampVel > sv_MoldBwdProfVis.rMaxRampVel THEN
      rStopRamp := sv_MoldBwdProfVis.rMaxRampVel;
   ELSE
      rStopRamp := sv_MoldFwdProfVis.rMaxRampVel;
   END_IF;
   fbConstOutputRamp(bReParam:=TRUE,
                    bStart:=TRUE,
                    bStop := FALSE,
                    rActValue:=sv_rToggleLeverPosition,           
                    rStartValue:= rMaxVoltageValve,
                    rMinOutput := rMinOutput,
                    LintabParam:=sv_ValveCharacteristicLintab,
                    bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                    bProfileRamp:=FALSE,
                    rEndValue:=rEndValue,
                    bDir:=FALSE,
                    rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,
                    rStopRamp:=rStopRamp,
                    bActive := abMoldClose.aRun.bActive);
    
   
   fbPumpVelocityOutput(Start := FALSE,
                        Stop  := FALSE,
                        ReParam  := TRUE,
                        CycleTime := dCycleTime,
                        PreRamp := 1.0e10,
                        PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                        StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                        ProfilData := PumpVelocityProfile,
                        MinOutput := 0.0,
                        RampType := sv_MoldBwdProfVis.RampTypeVel,
                        OpenEnd := sv_MoldBwdProfVis.bOpenEndProfile,
                        DeadTime := T#0s,
                        InputValue := sv_rToggleLeverPosition,
                        Interrupt := FALSE,
                        DelayTime := T#0s);
   
   rPessureDrop := MAX(0.0, sv_rMoldValvePressureDropClose);
   
   bStart := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitValveController*)
ACTION AResetIdentBlock: #BEGIN_EDIT_BLOCK
sv_rFwdInterruptPosition := sv_rIdentPosition;
IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
   rPositionDown := (sv_rToggleLeverPosition + sv_rFwdInterruptPosition) * 0.5;   
END_IF;
abMoldCloseStep.aRun(bStart := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AResetIdentBlock*)
ACTION ACalcValveControllerHiPress: #BEGIN_EDIT_BLOCK
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF sv_bPumpUseProfileVelociy THEN
         mrPumpVelocity := abConstHiPress.aRun.rOutputVel;
      ELSE
         fbPumpVelocityOutput(Start := bStart,
                              Stop  := bStop,
                              ReParam  := FALSE,
                              PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                              StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                              InputValue := sv_rToggleLeverPosition,
                              Interrupt := FALSE,
                              DelayTime := T#0s);   
         IF fbPumpVelocityOutput.Error  THEN
            mrPumpVelocity := rSetVelocity;
         ELSE
            IF abConstHiPress.aRun.bActive THEN
               mrPumpVelocity := fbPumpVelocityOutput.Output;      
            ELSE
               mrPumpVelocity := 0.0;
            END_IF;
         END_IF;         
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, mrPumpVelocity);
      
      IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
           bStopActive := TRUE;    
      ELSE
           bStopActive := FALSE;  
      END_IF;  

      rYXSetPos := rYXSetPos - mrSetVelocity * rCycleTime;
      rYXSetVel := mrSetVelocity;
             
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;  
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;          
       
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := rYXSetPos*1.0e-3,
                             rSetVelocity := -rYXSetVel*1.0e-3,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
       
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
         
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
         
      ELSE
         rMoldValveOutput := 0.5 * (rOffsetPos + rOffsetNeg); 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;

      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rYXSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rYXSetVel);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetAccel, rYXSetAccel);
   ELSIF sv_bUseValve THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
      IF mbUsePropValve THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := abConstHiPress.aRun.rOutputVel * mrAreaOutletFactor;
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abConstHiPress.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput); 
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      END_IF;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
   END_IF;

   bStart := FALSE;
ELSIF g_bMoldValve THEN
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
   IF (mbUsePropValve AND sv_ServoValveControlData.bEnable) THEN // calc feed forward if init OK
      // use feedforward calculated from pressure drop at prop valve
      rSetFlow := abConstHiPress.aRun.rOutputVel * mrAreaOutletFactor;
      abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                               rFlow := rSetFlow);                  
      mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
      mrPressOutlet := rPessureDrop;
      mrSetFlowOutlet := rSetFlow;
   ELSE   
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
   END_IF;
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
END_IF;


;#END_EDIT_BLOCK END_ACTION (*ACalcValveControllerHiPress*)
ACTION AInitValveControllerHiPRess: #BEGIN_EDIT_BLOCK
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN
   rYXSetPos := sv_rToggleLeverPosition;
   rYXSetAccel := 0.0;
   rYXSetJerk  := 0.0;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInitValveControllerHiPRess*)
ACTION AResetStandStillDetect: #BEGIN_EDIT_BLOCK
fbStandStill(bDoCalib := FALSE);
bStandStill := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AResetStandStillDetect*)
ACTION ADetectStandStillMoldAdjust: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill AND sv_bPresMoldHeightAdjustActive THEN
    fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := sv_dStandStillDetectTime,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ADetectStandStillMoldAdjust*)
ACTION AICMInterruptPos: #BEGIN_EDIT_BLOCK
IF bICMInterruptStop THEN
    //Set the interrupt position if use ICM
    sv_rFwdInterruptPosition := sv_rSetMoldStartPosition;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AICMInterruptPos*)
ACTION aICMInterruptStop: #BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN

    IF (sv_CoiningActivateMode <> nDeactivate) 
            OR (sv_VentingActivateMode <> nDeactivate) THEN  

        bICMInterruptStop := TRUE;     //Interrupt stop for ICM
    END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aICMInterruptStop*)
ACTION AMoldCloseTime: #BEGIN_EDIT_BLOCK

IF g_MoveCtrl.pData^.MoveId <> cMoveFwdInterPos THEN
   b := WRITE_SV_DIRECT(sv_dActCloseTime, abMoldClose.aRun.dActMoveTime);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AMoldCloseTime*)
ACTION AResetCalibBlock2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStart := FALSE,
                    LintabPoint := sv_TmpLintabPoint);

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock2*)
ACTION ATransducerCalib2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                    bStart := TRUE,
                    rActVoltage := ai_Position,
                    rMaxVoltageDiff := sv_rMaxVoltageDiff,
                    dStandStillDetectTime := sv_dStandStillDetectTime,
                    LintabPoint := dummypoint,
                    rSetValue := 0.0,
                    bActive => sv_bOutputActive,
                    rOutputPre => sv_rPressureAbs,
                    rOutputVel => sv_rVelocityAbs,
                    bPreOutputReached => sv_bPreOutputReady);
sv_bDoTransducerCalib := NOT (abMoldFwdCalib.aRun.bPointDetected);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib2*)
ACTION ATransducerCalib: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                    bStart := TRUE,
                    rActVoltage := ai_Position,
                    rMaxVoltageDiff := sv_rMaxVoltageDiff,
                    dStandStillDetectTime := sv_dStandStillDetectTime,
                    LintabPoint := sv_TmpLintabPoint,
                    rSetValue := 0.0,
                    dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                    dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                    bActive => sv_bOutputActive,
                    rOutputPre => sv_rPressureAbs,
                    rOutputVel => sv_rVelocityAbs,
                    bPreOutputReached => sv_bPreOutputReady,
                    iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abMoldFwdCalib.aRun.bPointDetected);
bError := abMoldFwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib*)
ACTION AStepOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseStep.aRun(bUsePosDetect := sv_rFwdInterruptPosition <> 0.0,
                     rPositionDown := (sv_rToggleLeverPosition + sv_rFwdInterruptPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedFwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := FALSE,
                     rActPos := sv_rToggleLeverPosition,
                     rTargetPos := sv_rFwdInterruptPosition,
                     dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffFwd,
                     rPositionUp := sv_rToggleLeverPosition,
                     rHighOutput := sv_ConstFwdVis.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

IF (g_bMoldValve) THEN
   // if use stop ramp close mold valve
   IF (sv_rToggleLeverPosition <rPositionDown) AND (sv_ConstFwdVis.Velocity.Output.rOutputValue > 0.0) THEN
      rOutput := rMaxVoltageValve * sv_rVelocityAbs / sv_ConstFwdVis.Velocity.Output.rOutputValue;
      IF rOutput > 0.0 THEN
         rMoldValveOutput := rOutput + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := rOutput + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AStepOutput*)
ACTION AProfileOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abLintabApplyToggle.aCalcInv(rY := sv_rFwdInterruptPosition,
                             rX => rInterruptTogglePosition);

abMoldClose.aRun(bStop := sv_bTransducerError OR bStop OR FALSE,
                 rInterruptPosition := rInterruptTogglePosition - sv_rInterstopTolerance,
                 bUseInterruptPos := (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) OR bICMInterruptStop,
                 bStart := TRUE,
                 rActPosition := sv_rToggleLeverPosition,
                 dMaxMoveTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                 dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                 dDelayTimeOff := dValveOffDelay,
                 DeadTime := sv_dSetDelayTimeOffFwd,
                 rAmplification := rAmplification,
                 ManualDelayTime := sv_CloseManualDelayTime,
                 StopDeadTime := sv_CloseInterstopDeadTime,
                 rInterruptAccel := sv_rFwdInterruptAccel,
                 rInterruptDeaccel := sv_rFwdInterruptDeaccel,
                 rSmoothFactor := sv_rSmoothFactor,
                 rVelocityOutput => rSetVelocity,
                 bActive => sv_bOutputActive,
                 iActiveStage => sv_iActiveStage,
                 bPreOutputReached => sv_bPreOutputReady);
                 
b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abMoldClose.aRun.rPressureOutput);                 
b := WRITE_SV_DIRECT(sv_MoldCloseTimesAct.dActMoveTime, abMoldClose.aRun.dActMoveTime);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);                 

;#END_EDIT_BLOCK END_ACTION (*AProfileOutput*)
ACTION AMoldProtection: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldProtection.aRun(bMovementActive := sv_bOutputActive,
                      rActPosition := sv_rMoldPosition,
                      pVisProfile := @sv_MoldFwdProfVis,
                      dProtectTime := sv_dMoldProtectTimeSet);
b := WRITE_SV_DIRECT(sv_dMoldProtectTimeAct, abMoldProtection.aRun.dActTime); 

;#END_EDIT_BLOCK END_ACTION (*AMoldProtection*)
ACTION AConstOutputMHAdjustSetup: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseConst.aRun(bStop := (bStop OR bStandStill OR sv_bTransducerError OR bPosReached),
                      bStart := TRUE,
                      bDirection := FALSE,
                      rActPos := sv_rMoldPosition,
                      rTargetPos := rTargetPos,
                      bUsePosDetect := TRUE,
                      dMaxTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bActive => sv_bOutputActive,
                      dActTime => sv_MoldCloseTimesAct.dActMoveTime,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*AConstOutputMHAdjustSetup*)
ACTION AConstOutputHiPress: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF (NOT sv_bClampForceReached) THEN
   // use const output
   abConstHiPress.aRun(bStop := bStop OR bStandStill,
                       bStart := TRUE,
                       bDirection := FALSE,
                       rActPos := sv_rMoldPosition,
                       bUsePosDetect := FALSE,
                       rStartOutputPre := mrStartOutputPres,
                       rStartOutputVel := mrStartOutputVel,
                       dMaxTime := sv_MoldLockTimesSet.dMaxMoveTime,
                       dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                       bActive => sv_bOutputActive,
                       bPreOutputReached => sv_bPreOutputReady);

   sv_bMoldLockStageActive := sv_bOutputActive;
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abConstHiPress.aRun.rOutputPre);
   IF NOT abConstHiPress.aRun.bActive THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
   END_IF;
   mrSetVelocity := abConstHiPress.aRun.rOutputVel;
   b := WRITE_SV_DIRECT(sv_MoldLockTimesAct.dActMoveTime, abConstHiPress.aRun.dActTime);
   dActCloseTime := abConstHiPress.aRun.dActTime + sv_MoldCloseTimesAct.dActMoveTime;
   b := WRITE_SV_DIRECT(sv_dActCloseTime, dActCloseTime);

   abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

   abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);
ELSE
// stop at sv_bClampForceReached
   sv_bOutputActive := FALSE;   
   sv_bMoldLockStageActive := sv_bOutputActive;
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, 0.0);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, 0.0);   
   mrSetVelocity := 0.0;
   b := WRITE_SV_DIRECT(sv_MoldLockTimesAct.dActMoveTime, abConstHiPress.aRun.dActTime);
   dActCloseTime := abConstHiPress.aRun.dActTime + sv_MoldCloseTimesAct.dActMoveTime;
   b := WRITE_SV_DIRECT(sv_dActCloseTime, dActCloseTime);

   abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

   sv_rVelocityAbs := 0.0;
   abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);   
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AConstOutputHiPress*)
ACTION AConstOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseConst.aRun(bUsePosDetect := (sv_rFwdInterruptPosition <> 0.0),
                      bStart := TRUE,
                      bStop := bStop,
                      bDirection := FALSE,
                      rActPos := sv_rMoldPosition,
                      rTargetPos := sv_rFwdInterruptPosition,
                      dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bActive => sv_bOutputActive,
                      dActTime => sv_MoldCloseTimesAct.dActMoveTime,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*AConstOutput*)
ACTION ACalcPumpVelocity: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*ACalcPumpVelocity*)
(* end sfc-code *)


END_ALGORITHM

ALGORITHM aInit

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldClose.aInit(pProfile := @sv_ToggleFwdProfVis,
                  MoveDir := sv_MoveClose.MoveDir,
                  pdCalcedDuration := @sv_dCalculatedDurationClose,
                  prCalcDurationStartPosition := @sv_MoldBwdProfVis.Profile.Points[sv_MoldBwdProfVis.Profile.iNoOfPoints + 1].rStartPos,
                  pInstanceDataInterPos := @sv_InstanceDataCloseToggleInter);

abMoldCloseConst.aInit(pConst := @sv_ConstFwdVis,
                       MoveId := cMoveFwd);

abMoldFwdCalib.aInit(pConst := @sv_ConstFwdVis,
                     MoveId := cMoveFwd);

abConstHiPress.aInit(pConst := @sv_ConstHiPressVis,
                     MoveId := cMoveFwd);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutFwdP);
abLintabApplyVel.aInit(pLintab := @sv_LintabOutFwdV);

abMoldClose.aInitMaxRamps(prMaxAbsAccelStart := @sv_MoldBwdProfVis.rMaxRampVel,
                          prMaxAbsAccelEnd := @sv_MoldFwdProfVis.rMaxRampVel,
                          prPosAccelStart := @sv_MoldFwdProfVis.Profile.Points[1].rStartPos,
                          prPosAccelEnd := @sv_MoldBwdProfVis.Profile.Points[1].rStartPos,
                          bUseAccelerationReduction := NOT g_bDirectLockAvailable);

abLintabApplyToggle.aInit(pLintab := @sv_ToggleLeverLintab);

abLintabApplyToggleSlow.aInit(pLintab := @sv_ToggleLeverLintab);

abMoldCloseStep.aInit(pConst := @sv_ConstFwdVis,
                      MoveId := cMoveFwd,
                      prMaxSpeed := @sv_rMaxSpeedFwd);

mbFastCloseLinked := IS_LINKED(do_FastClose);


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pMinOutputChanged ON PU_Task_7 WITH sv_MinOutputFwd,sv_bInitStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to fwd profile
sv_MoldFwdProfVis.rMinOutputVel := sv_MinOutputFwd.rVelocity;
sv_MoldFwdProfVis.rMinOutputPress := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd constoutput
sv_ConstFwdVis.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdVis.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStrokeChanged ON PU_Task_7 WITH sv_rMoldStroke,sv_bInitStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy stroke to start position of first profile point
sv_MoldFwdProfVis.Profile.Points[1].rStartPos := sv_rMoldStroke;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Close.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Close.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelocity);
variableName := CONCAT(fuName,'.Close.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
variableName := CONCAT(fuName,'.Close.bLockStageActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bMoldLockStageActive);



variableName := CONCAT(fuName,'.rMoldValveOutput');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rMoldValveOutput);
variableName := CONCAT(fuName,'.Control.rSetPos');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetPos);
variableName := CONCAT(fuName,'.Control.rSetVel');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetVel);
variableName := CONCAT(fuName,'.Control.rSetAccel');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetAccel);
variableName := CONCAT(fuName,'.Control.rSetJerk');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetJerk);


variableName := CONCAT(fuName,'.Close.rPumpVelocity');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrPumpVelocity);
variableName := CONCAT(fuName,'.Control.rUP_Fwd');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrUP);
variableName := CONCAT(fuName,'.Control.rUD_Fwd');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrUD);


STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pMoldFwdProfVisChanged ON PU_Task_3 WITH sv_MoldFwdProfVis.Profile,sv_MoldFwdProfVis.rMaxRampPress,sv_MoldFwdProfVis.rMaxRampVel,sv_bInitDone

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Take last stage of the profile (High Pressure) as value for constant output
sv_ConstHiPressVis.Pressure.Output.rOutputValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rPressure;
sv_ConstHiPressVis.Velocity.Output.rOutputValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rVelocity;

IF g_b2Platen THEN
   sv_MoldFwdProfVis.rEndOutputPress := 0.0;
   sv_MoldFwdProfVis.rEndOutputVel := 0.0;
ELSE
   sv_MoldFwdProfVis.rEndOutputPress := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints-1].rPressure;
   sv_MoldFwdProfVis.rEndOutputVel := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints-1].rVelocity;
END_IF;



//mold close profile must stop before high pressure because high pressure is done by a constant output
// -> copy start pos to both profile points so that profile movement ends at this position
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rStartPos := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rStartPos;
//also copy endoutput values to pressure and velocity value of next profile stage
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rPressure := sv_MoldFwdProfVis.rEndOutputPress;
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rVelocity := sv_MoldFwdProfVis.rEndOutputVel;


// set ramps for high pressure stage const movement
sv_ConstHiPressVis.Pressure.Output.rRamp := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rPressRamp * sv_MoldFwdProfVis.rMaxRampPress / 100.0;
sv_ConstHiPressVis.Velocity.Output.rRamp := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rVelRamp * sv_MoldFwdProfVis.rMaxRampVel / 100.0;

 









;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcToggleProfile ON PU_Task_7 WITH sv_bInitDone,sv_MoldFwdProfVis

#BEGIN_EDIT_BLOCK
START_PROCESS_ALGORITHM(paCalcToggleProfile);


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCalcToggleProfile ON TaskSlow


VAR_TEMP
 i : UDINT;
END_VAR

VAR
 pCalcedProfile : REFTO tCalculatedProfiles;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//save reference to calced profile
pCalcedProfile := sv_ToggleFwdProfVis.pCalculatedProfile;

sv_ToggleFwdProfVis := sv_MoldFwdProfVis;
FOR i:= 1 TO sv_MoldFwdProfVis.Profile.iNoOfPoints+1 DO
    abLintabApplyToggleSlow.aCalcInv(rY := sv_MoldFwdProfVis.Profile.Points[i].rStartPos,
                                 rX => sv_ToggleFwdProfVis.Profile.Points[i].rStartPos);
END_FOR;

//copy original reference
sv_ToggleFwdProfVis.pCalculatedProfile := pCalcedProfile;

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcToggleInterPos ON PU_Task_7 WITH sv_bInitDone,sv_InstanceDataCloseInterPos

#BEGIN_EDIT_BLOCK
START_PROCESS_ALGORITHM(paCalcToggleInterPos);


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCalcToggleInterPos ON TaskSlow


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_InstanceDataCloseToggleInter := sv_InstanceDataCloseInterPos;
FOR i:=1 TO cMaxIntermediateConditions DO
    abLintabApplyToggleSlow.aCalcInv(rY := sv_InstanceDataCloseInterPos[i].rTargetValue,
                                 rX => sv_InstanceDataCloseToggleInter[i].rTargetValue);
END_FOR;
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcMovementDirection ON PU_Task_7 WITH sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd

#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
    IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
        rOffsetPos := sv_ValveData.rValveOffsetFwd;
        rOffsetNeg := sv_ValveData.rValveOffsetBwd;
        rMaxVoltageValve := MAX_VOLTAGE;
    ELSE    
        rOffsetPos := sv_ValveData.rValveOffsetBwd;
        rOffsetNeg := sv_ValveData.rValveOffsetFwd;
        rMaxVoltageValve := -MAX_VOLTAGE;
    END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pInstanceDataDurationChanged ON PU_Task_13 WITH sv_InstanceDataCloseToggleInter


VAR_TEMP
 i : DINT;
END_VAR

VAR
 InstDataCloseToggleInter : tyInstanceListArray;
 bCopyDurations : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Copy only necessary, if any calculated duration has changed
FOR i := 1 TO cMaxIntermediateConditions DO
   IF (sv_InstanceDataCloseToggleInter[i].dCalculatedDuration <> InstDataCloseToggleInter[i].dCalculatedDuration) THEN
      bCopyDurations := TRUE;
      EXIT;   
   END_IF; 
END_FOR; 

IF bCopyDurations THEN
   //Copy calculated duration to instance data array
   FOR i := 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataCloseInterPos[i].dCalculatedDuration := sv_InstanceDataCloseToggleInter[i].dCalculatedDuration;              
   END_FOR;
   
   InstDataCloseToggleInter := sv_InstanceDataCloseToggleInter;

   bCopyDurations := FALSE;
END_IF;





;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcedPresProfileChanged ON PU_Task_7 WITH sv_CalculatedProfileFwdToggle.PressureProfile.iProfileChangedCounter

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

START_PROCESS_ALGORITHM(paCalcDisplayedPresProfile);


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcedVelProfileChanged ON PU_Task_7 WITH sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

START_PROCESS_ALGORITHM(paCalcDisplayedVelProfile);


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCalcDisplayedVelProfile ON TaskSlow


VAR_TEMP
 i : UDINT;
 rMaxVelProfFwd : REAL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile := sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile;
FOR i:=1 TO sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints DO
   abLintabApplyToggleSlow.aCalc(rX := sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.Point[i].rX,
                               rY => sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[i].rX);
END_FOR;    
sv_CalculatedProfileFwd.VelocityProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter;
  
// ad clamp force build-up velocity
//sv_ConstHiPressVis.Velocity.Output.rOutputValue;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints := sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints +3;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints].rX := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints].rY := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-1].rX := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-1].rY := 
    sv_ConstHiPressVis.Velocity.Output.rOutputValue;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-2].rX := 
    sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-3].rX;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-2].rY := 
    sv_ConstHiPressVis.Velocity.Output.rOutputValue;

// calc velocity profile for pump
IF (sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints > 0) THEN
   PumpVelocityProfile.ProfilePoints.uNoOfPoints := 2;
   rMaxVelProfFwd := 0.0;
   FOR i := 1 TO sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints DO
      rMaxVelProfFwd :=MAX(rMaxVelProfFwd, sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.Point[i].rY);
   END_FOR;
   PumpVelocityProfile.ProfilePoints.Point[1].rX := sv_rToggleLeverStroke;
   PumpVelocityProfile.ProfilePoints.Point[1].rY := MIN(1.1*rMaxVelProfFwd, sv_rMaxSpeedFwd);
   PumpVelocityProfile.ProfilePoints.Point[2].rX := 0.0;
   PumpVelocityProfile.ProfilePoints.Point[2].rY := PumpVelocityProfile.ProfilePoints.Point[1].rY;
   PumpVelocityProfile.Acceleration := sv_ToggleFwdProfVis.rMaxRampVel;
   PumpVelocityProfile.InterAcceleration := sv_ToggleFwdProfVis.rMaxRampVel;
   PumpVelocityProfile.StopAcceleration := sv_ToggleFwdProfVis.rMaxRampVel;
END_IF;
        
// signalize a change in calculated velocity profile
sv_CalculatedProfileFwd.VelocityProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter;
    
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCalcDisplayedPresProfile ON TaskSlow


VAR_TEMP
 i : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile := sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile;
FOR i:=1 TO sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile.uNoOfPoints DO
   abLintabApplyToggleSlow.aCalc(rX := sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile.Point[i].rX,
                               rY => sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[i].rX);
END_FOR;    

// ad clamp force build-up pressure
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints := sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints + 3;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints].rX := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints].rY := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-1].rX := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-1].rY := 
    sv_ConstHiPressVis.Pressure.Output.rOutputValue;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-2].rX := 
    sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-3].rX;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-2].rY := 
    sv_ConstHiPressVis.Pressure.Output.rOutputValue;

        
// signalize a change of calculated profile
sv_CalculatedProfileFwd.PressureProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.PressureProfile.iProfileChangedCounter;
    
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pUpdateMoldPosReached ON PU_Task_7 WITH sv_CoiningActivateMode,sv_VentingActivateMode,sv_bInitDone

#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN  
    
    IF (sv_CoiningActivateMode = nDeactivate) 
        AND (sv_VentingActivateMode = nDeactivate) THEN  
        
        //pointer to mold closed if deactivate ICM 
        sv_MoveClose.pbPosReached := @sv_bMoldClosed;
    END_IF;    
END_IF;    




;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcValveCharacteristic ON PU_Task_7 WITH sv_bInitDone,sv_ValveData,sv_ConstructionData,sv_rMoldPropValveParams

#BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_rMoldPropValveParams) AND
   IS_LINKED(sv_ValveData) AND
   IS_LINKED(sv_ConstructionData) THEN

   abPropValve.aInit(ValveParams := sv_rMoldPropValveParams);
   // [l/min] = [mm³/s]*60/10^6 = [m²]*[mm/s]*60 => [v] = [mm/s],[rPistonArea1]=[m²] 
   mrAreaOutletFactor := sv_ConstructionData.rPistonArea2 * 60.0;
   IF (sv_ValveData.rValveOffsetBwd > sv_ValveData.rValveOffsetFwd) THEN
      mrSign := -1.0;
   ELSE
      mrSign := 1.0;
   END_IF;
 
   IF (abPropValve.aInit.bInitDone AND (mrAreaOutletFactor > 0.0)) THEN
      mbUsePropValve := TRUE;
   ELSE
      mbUsePropValve := FALSE;
   END_IF;
   
ELSE
   mbUsePropValve := FALSE;
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 159 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
5 
@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)GET_TASK_INTERVAL @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
19 
@Var @RT(25)KCTRL_YXGen_Input_Default @RT(0) @T @T @DERIVED 0 @F @RT(21)KCTRL_YXGen_InputType @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)cLockGroupClampingUnit @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)65 @RT(29)Members: Mold, Ejector, Cores 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cLockGroupSafetyGateMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)61 @RT(73)Members: Mold Close, Mold Hight Forward, Auto Mold Hight, Core In, Inject 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cLockGroupMotor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)69 @RT(56)Members: Mold, Ejector, Cores, Injection, Plast, Purge,  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(25)cLockGroupRotateInjectPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)72 @RT(8)Members: 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nActive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)nDeviceState @RT(0) @T @T @DERIVED 0 @F @RT(12)tnTraceLevel @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveFwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)17 @RT(37)move forward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)nInactive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cMoveFwdForMHAdjust @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)32 @RT(61)mold forward movement during automatic mold height adjustment 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cMoveFwdForMHAdjustSetup @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)39 @RT(61)mold forward movement during automatic mold height adjustment 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)tnCalibState_Error @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(32)error occured during calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)MAX_VOLTAGE @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)10.0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)KCTRL_YXGen_RampType_Sin @RT(0) @T @T @DERIVED 0 @F @RT(20)KCTRL_YXGen_RampType @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)nDeactivate @RT(0) @T @T @DERIVED 0 @F @RT(17)tnICMActivateMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(10)deactivate 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)cMaxIntermediateConditions @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(38)max. number of intermediate conditions 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(11)ABMoveClose @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
156 
@Var @RT(12)sv_MoveClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoveCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rMoldPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iActiveStage @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_MoldFwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rFwdInterruptAccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rFwdInterruptDeaccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rFwdInterruptPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_bMoldClosed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_ConstFwdVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)const output for mold close movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_TmpLintabPoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)ai_Position @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)analog input value from transducer @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dStandStillDetectTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)time for standstill detection @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxVoltageDiff @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. voltage difference to detect stand still @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bPreOutputReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)PreOutput is ready @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoveCloseForMHAdj @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)move forward for mold height auto adjustment @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)Output is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bDoTransducerCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bTransducerError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_CalibState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsCalibMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MinOutputFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsMinOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dMoldProtectTimeSet @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dMoldProtectTimeAct @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoldCloseTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoldCloseTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_rMoldStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bInitStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_MoveCloseForMHAdjSetup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_ToggleLeverLintabDerive @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)derivation calculated from sv_ToggleLeverLintab @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_CloseInterstopDeadTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_CloseManualDelayTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_dCalculatedDurationClose @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)Calculated duration for mold close @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_MoldBwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_InstanceDataCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(60)array with target positions of mold close interpos movements @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_ConstHiPressVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_ClampForceBuildUpTimeSet @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)set build up time for clamp pressure @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_ClampForceBuildUpTimeAct @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)act build up time for clamp pressure @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bMoldLockStageActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)mold lock stage active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_bClampForceBuildUpWithTime @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)use time dependent clamp force build up @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bClampForceReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)Clamp force reached @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_dClampPressureCheckTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_ClampForce @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)tsClampForces @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)actual clamp force @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoldLockTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoldLockTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rClampForceAct @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bCloseActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)mold close is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_ValveCharacteristicLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)KCTRL_Lintab_Param_Light @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ToggleLeverLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)derivation calculated from sv_ToggleLeverLintab @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_ToggleFwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(31)sv_InstanceDataCloseToggleInter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(60)array with target positions of mold close interpos movements @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rToggleLeverPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rToggleLeverStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)Opening Stroke of toggle lever @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)pressure mold fwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rMoldPressure2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)pressure mold bwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_rToggleLeverVelEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ServoValveControlData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tServoValveControlData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_ValveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tServoValveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_ServoValveControlSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tServoValveControlSet @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bUseValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ToggleLeverSplineData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsToggleLeverSplineData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_ConstructionData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tServoValveConstructionData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_rInterstopTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bMoveIdent @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dSetDelayTimeOffFwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rSmoothFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(30)sv_bPresMoldHeightAdjustActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_rMinAmplification @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)minimum amplification @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_rMaxAmplification @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)maximum amplification @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_rToggleLeverSetPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rSetMoldStartPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rActMoldStartPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bICMStartPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_ICMMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)tnICMMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_CoiningActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_VentingActivateMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tnICMActivateMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_dActCloseTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)includes pressure build up time @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bDoPumpPressureCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rMoldPropValveParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsPropValveParams @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(30)sv_rMoldValvePressureDropClose @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_rFastVelocityFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)do_FastClose @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_bPumpUseProfileVelociy @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)erMoldNotClosed @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)erMoldPosNotCorrect @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)PU_Task_13 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(12)pSysPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(22)g_bDirectLockAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(12)g_bMoldValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor1Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor2Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensorsAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(13)rTankPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMaxVoltageValve @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)abMoldClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABProfileMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abMoldCloseConst @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)abMoldFwdCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABConstCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abLintabApplyVel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abLintabApplyPres @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)abToggleLeverLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Light @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)ToggleLeverLintabPar @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)KCTRL_Lintab_Param_Light @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)abConstHiPress @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mrStartOutputPres @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mrStartOutputVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)rInterruptTogglePosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)abLintabApplyToggleSlow @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)block for usage in TaskSlow @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)abLintabApplyToggle @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abValveController @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABValveController @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abYXGenLightB @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_YXGen_LightB @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Param @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_YXGenParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)InputType @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)KCTRL_YXGen_InputType @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(25)KCTRL_YXGen_Input_Default @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)Accelerations @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(25)KCTRL_YXGen_Accelerations @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)StopPoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_ProfPoint @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rYXSetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rYXSetVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)rYXSetAccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rYXSetJerk @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)CalcedVelocityProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KAPPL_ProfileData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rOffsetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rOffsetNeg @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)-1.2 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)abMoldCloseStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABStepOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)PumpVelocityProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KAPPL_ProfileData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)fbPumpVelocityOutput @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)KAPPL_Plastics_ProfileOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mrPumpVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrSetVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)mrUP @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)mrUD @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)abPropValve @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)ABProportionalValve @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mrAreaOutletFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mrPropValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbUsePropValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mrSetFlowOutlet @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrPressOutlet @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)mrSign @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbFastCloseLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)sv_CalculatedProfileFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tCalculatedProfiles @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_CalculatedProfileFwdToggle @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tCalculatedProfiles @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bStandStillDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)g_b2Platen @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

19 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(27)abMoveCloseForMHAdjRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)abMoveCloseForMHAdjSetupReg @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)abMoveCloseRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)abMoveCloseInterPosRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Alarm @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)tsAlarm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
43 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(16)rMoldValveOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)dActCloseTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbStandStill @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBStandStill @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)bStandStill @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abMoldProtection @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)ABMoldProtection @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)bPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rTargetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rAmplification @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbBuildUpTimer @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbClampPreTON @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbConstOutputRamp @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBConstOutputRamp @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rEndValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rMinOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)10.0 @RT(1)% @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rSetPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rSetVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rQNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rPNom @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rQNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rPNomPB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rPressure2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)abEstimatePressure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABEstimatePressure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)bStopActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rCycleTime @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)bICMInterruptStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)dValveOffDelay @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dummypoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rPositionDown @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rSetFlow @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rPessureDrop @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)10.0 @RT(27)pressure drop at valve edge @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)rSetVelocityValve @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pMinOutputChanged @STRUCTURED_TEXT 
@RT(0) @RT(29)sv_MinOutputFwd,sv_bInitStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pStrokeChanged @STRUCTURED_TEXT 
@RT(0) @RT(28)sv_rMoldStroke,sv_bInitStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pMoldFwdProfVisChanged @STRUCTURED_TEXT 
@RT(0) @RT(100)sv_MoldFwdProfVis.Profile,sv_MoldFwdProfVis.rMaxRampPress,sv_MoldFwdProfVis.rMaxRampVel,sv_bInitDone @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pCalcToggleProfile @STRUCTURED_TEXT 
@RT(0) @RT(30)sv_bInitDone,sv_MoldFwdProfVis @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(19)paCalcToggleProfile @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)pCalcedProfile @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(19)tCalculatedProfiles @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(19)pCalcToggleInterPos @STRUCTURED_TEXT 
@RT(0) @RT(41)sv_bInitDone,sv_InstanceDataCloseInterPos @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(20)paCalcToggleInterPos @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pCalcMovementDirection @STRUCTURED_TEXT 
@RT(0) @RT(70)sv_bInitDone,sv_ValveData.rValveOffsetFwd,sv_ValveData.rValveOffsetBwd @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(28)pInstanceDataDurationChanged @STRUCTURED_TEXT 
@RT(0) @RT(31)sv_InstanceDataCloseToggleInter @RT(10)PU_Task_13 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(24)InstDataCloseToggleInter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bCopyDurations @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(25)pCalcedPresProfileChanged @STRUCTURED_TEXT 
@RT(0) @RT(68)sv_CalculatedProfileFwdToggle.PressureProfile.iProfileChangedCounter @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(24)pCalcedVelProfileChanged @STRUCTURED_TEXT 
@RT(0) @RT(68)sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(25)paCalcDisplayedVelProfile @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)rMaxVelProfFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(26)paCalcDisplayedPresProfile @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pUpdateMoldPosReached @STRUCTURED_TEXT 
@RT(0) @RT(58)sv_CoiningActivateMode,sv_VentingActivateMode,sv_bInitDone @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(24)pCalcValveCharacteristic @STRUCTURED_TEXT 
@RT(0) @RT(69)sv_bInitDone,sv_ValveData,sv_ConstructionData,sv_rMoldPropValveParams @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(51)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveClose.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveClose.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveClose.pdActiveTimeAct := @sv_dActCloseTime;
sv_MoveClose.pdTimeLimit     := @sv_MoldCloseTimesSet.dMaxMoveTime;
sv_MoveClose.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveClose.LockGroups[2] := cLockGroupSafetyGateMold;
sv_MoveClose.LockGroups[3] := cLockGroupMotor;
sv_MoveClose.LockGroups[4] := cLockGroupRotateInjectPos;
sv_MoveClose.LockGroups[5] := cLockGroupMoldNutOpen;
sv_MoveClose.pbPosReached := @sv_bMoldClosed;
sv_MoveClose.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movMoldFwd.gif");
Alarm.AlarmId := erMoldNotClosed;
sv_MoveClose.Alarm := Alarm;
abMoveCloseRegister.aRegister(@sv_MoveClose);


// register movement to intermediate position
sv_MoveCloseInterPos.pdActiveTimeAct := @sv_MoldCloseTimesAct.dActMoveTime;
sv_MoveCloseInterPos.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseInterPos.sIconPath := CONCAT(GET_MY_FU_NAME(), "\hmi\images\movMoldInterposFwd.gif");    
Alarm.AlarmId := erMoldPosNotCorrect;
sv_MoveCloseInterPos.Alarm := Alarm;
abMoveCloseInterPosRegister.aRegister(@sv_MoveCloseInterPos);

// register movement for automatic mold height adjustment
sv_MoveCloseForMHAdj.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveCloseForMHAdj.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveCloseForMHAdj.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseForMHAdj.sIconPath := sv_MoveClose.sIconPath;
sv_MoveCloseForMHAdj.pbPosReached := @sv_bMoldClosed;       
Alarm.AlarmId := erMoldNotClosed;
sv_MoveCloseForMHAdj.Alarm := Alarm;
abMoveCloseForMHAdjRegister.aRegister(@sv_MoveCloseForMHAdj);


sv_MoveCloseForMHAdjSetup.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
sv_MoveCloseForMHAdjSetup.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
sv_MoveCloseForMHAdjSetup.LockGroups := sv_MoveClose.LockGroups;
sv_MoveCloseForMHAdjSetup.sIconPath := sv_MoveClose.sIconPath;
sv_MoveCloseForMHAdjSetup.pbPosReached := @sv_bMoldClosed;
Alarm.AlarmId := erMoldNotClosed;
sv_MoveCloseForMHAdjSetup.Alarm := Alarm;
abMoveCloseForMHAdjSetupReg.aRegister(@sv_MoveCloseForMHAdjSetup);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
44 16 23 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(6)aStart @F @T @RT(1)P @RT(0) @F @F @T @TL(7)
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveFwd,
                   State    := nActive);
sv_bCloseActive := TRUE;
fbDebugTrace2(nDeviceState, 'Mold close started');

@F 
@Acb @RT(17)aICMInterruptStop @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(8)TMoveFwd @F @T @F @F @T @F @TL(3)
g_MoveCtrl.pData^.MoveId = cMoveFwd OR
g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos

@RT(8)TMoveFwd @F 
@Step @RT(20)s_CheckOperationMode @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TSetupMode @F @T @F @F @T @F @TL(2)
(sv_OperationMode = nSetup) AND NOT sv_bPresMoldHeightAdjustActive

@RT(10)TSetupMode @F 
@Step @RT(14)S_CheckIfCalib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotCalib @F @T @F @F @T @F @TL(3)
NOT sv_bDoTransducerCalib AND 
NOT sv_bMoveIdent

@RT(9)TNotCalib @F 
@Step @RT(6)Step16 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(20)TNoPumpPressureCalib @F @T @F @F @T @F @TL(2)
NOT sv_bDoPumpPressureCalib

@RT(20)TNoPumpPressureCalib @F 
@Step @RT(11)S_ConstMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(12)AConstOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TConstMoveReady @F @T @F @F @T @T @TL(2)
NOT abMoldCloseConst.aRun.bActive

@RT(15)TConstMoveReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(13)TMoveFwdToEnd @F @T @F @F @T @F @TL(2)
sv_bDoPumpPressureCalib

@RT(13)TMoveFwdToEnd @F 
@Step @RT(10)S_FwdToEnd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(17)AResetCalibBlock2 @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ATransducerCalib2 @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)TFwdEnd @F @T @F @F @T @T @TL(2)
NOT abMoldFwdCalib.aRun.bActive

@RT(7)TFwdEnd @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TCalibActivated @F @T @F @F @T @F @TL(2)
sv_bDoTransducerCalib

@RT(15)TCalibActivated @F 
@Step @RT(7)S_Calib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(16)AResetCalibBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)ATransducerCalib @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckCalibError @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TCalibReady @F @T @F @F @T @T @TL(2)
 NOT abMoldFwdCalib.aRun.bActive OR bError

@RT(11)TCalibReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(19)TMoveIdentActivated @F @T @F @F @T @F @TL(2)
sv_bMoveIdent

@RT(19)TMoveIdentActivated @F 
@Step @RT(11)S_MoveIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetIdentBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(11)AStepOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TMoveIdentReady @F @T @F @F @T @T @TL(2)
NOT abMoldCloseStep.aRun.bActive

@RT(15)TMoveIdentReady @F 



@TransSeq @RT(4)tseq @F 7 
@Trans @RT(9)TNotSetup @F @T @F @F @T @F @TL(2)
(sv_OperationMode <> nSetup) OR sv_bPresMoldHeightAdjustActive

@RT(9)TNotSetup @F 
@Step @RT(13)S_ProfileMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 12 
@Acb @RT(18)AResetProfileBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(28)AParToggleLeverAmplification @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(29)ACalcToggleLeverAmplification @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)AICMInterruptPos @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)AProfileOutput @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(14)AMoldCloseTime @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(15)AMoldProtection @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(20)AInitValveController @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(20)ACalcValveController @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(17)ACalcPumpVelocity @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(21)ACopySetPositionClose @F @T @RT(2)P0 @RT(0) @F @F @T @TL(6)
IF bStop THEN
   b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, sv_rToggleLeverPosition);
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, abMoldClose.aRun.rEndPosition); 
END_IF;

@F 
@Acb @RT(23)AResetEndOutputPressure @F @T @RT(2)P0 @RT(0) @F @F @T @TL(6)
// use EndOutpuPressure only before HiPress
IF (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressure, 0.0);
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, sv_rPressure);
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(17)TProfileMoveReady @F @T @F @F @T @F @TL(7)
NOT abMoldClose.aRun.bActive
AND NOT bStop
AND NOT abMoldClose.aRun.bError
AND NOT abMoldClose.aRun.bTimeOut
AND (g_MoveCtrl.pData^.MoveId <> cMoveFwdInterPos)
AND NOT bICMInterruptStop

@RT(17)TProfileMoveReady @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(17)TMoldCloseStopped @F @T @F @F @T @F @TL(3)
NOT abMoldClose.aRun.bActive


@RT(17)TMoldCloseStopped @F 
@Goto @RT(5)READY @F @F 


@Step @RT(14)S_Check2Platen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(10)TNo2PLaten @F @T @F @F @T @F @TL(2)
NOT g_b2Platen

@RT(7)Trans21 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(8)T2Platen @F @T @F @F @T @F @TL(2)
g_b2Platen

@RT(7)Trans22 @F 
@Goto @RT(5)READY @F @F 


@Step @RT(15)S_Const_HiPress @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 8 
@Acb @RT(24)AResetConstOutputHiPress @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(22)AResetStandStillDetect @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(19)AConstOutputHiPress @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(27)AInitValveControllerHiPRess @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(27)ACalcValveControllerHiPress @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckClampForce @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(27)ADetectStandStillMoldAdjust @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(23)ACopySetPositionHiPress @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
b := WRITE_SVREAL_DIRECT(sv_rToggleLeverSetPosition, sv_rToggleLeverPosition);

@F 

@Trans @RT(20)TProfileHiPressReady @F @T @F @F @T @F @TL(2)
NOT sv_bOutputActive

@RT(20)TProfileHiPressReady @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(27)TMoveFwdForMoldHeightAdjust @F @T @F @F @T @F @TL(2)
g_MoveCtrl.pData^.MoveId = cMoveFwdForMHAdjust

@RT(27)TMoveFwdForMoldHeightAdjust @F 
@Step @RT(21)S_ProfileMoveForMHAdj @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 5 
@Acb @RT(8)Action22 @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
bPosReached := sv_bMoldClosed;
rTargetPos := -10.0;

@F 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(22)AResetStandStillDetect @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ADetectStandStill @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(25)AConstOutputMHAdjustSetup @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(18)TProfileMoveReady2 @F @T @F @F @T @T @TL(2)
NOT abMoldCloseConst.aRun.bActive

@RT(18)TProfileMoveReady2 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(24)TMoveFwdForMHAdjustSetup @F @T @F @F @T @F @TL(2)
g_MoveCtrl.pData^.MoveId = cMoveFwdForMHAdjustSetup

@RT(24)TMoveFwdForMHAdjustSetup @T @TL(2)
Comment :try to move to pos 0
detect standstill, when pos is not reached

@Step @RT(6)Step17 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 5 
@Acb @RT(8)Action21 @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
bPosReached := FALSE;
rTargetPos := 0.0;

@F 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(22)AResetStandStillDetect @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ADetectStandStill @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(25)AConstOutputMHAdjustSetup @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(29)TMoveFwdForMHAdjustSetupReady @F @T @F @F @T @T @TL(2)
NOT abMoldCloseConst.aRun.bActive

@RT(29)TMoveFwdForMHAdjustSetupReady @F 


@Step @RT(5)READY @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(24)
IF g_bMoldValve THEN
   sv_rMoldValveOutput := 0.0;
END_IF;

//injection compression molding
IF bICMInterruptStop THEN
    IF NOT bStop THEN
        sv_bICMStartPosReached := TRUE;
        //copy the actual start pos of ICM
        sv_rActMoldStartPosition := sv_rMoldPosition;
    END_IF;
    
    //set pos-raach for mold close if use ICM 
    sv_MoveClose.pbPosReached := @sv_bICMStartPosReached;
    bICMInterruptStop := FALSE;
END_IF;

bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := cMoveFwd,
                   State    := nInactive);
sv_bCloseActive := FALSE;
fbDebugTrace2(nDeviceState, 'Mold close ready');

@F 


@Trans @RT(6)TReady @F @T @T @T @T @T @TL(2)
TRUE

@RT(6)TReady @F 

@END_SfcData 
@SaActions 29 
@SaText @RT(16)AResetCalibBlock 1 @TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := FALSE;
abMoldFwdCalib.aRun(bStart := FALSE,
                    LintabPoint := sv_TmpLintabPoint);
IF abMoldFwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;



@SaText @RT(18)AResetProfileBlock 1 @TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldClose.aRun(bStart := FALSE);
sv_bClampForceReached := FALSE;
sv_ClampForceBuildUpTimeAct := T#0s;


@SaText @RT(16)AResetConstBlock 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;
IF sv_bMoveIdent OR sv_rIdentPosition > 0.0 THEN
   sv_rFwdInterruptPosition := sv_rIdentPosition;
END_IF;
abMoldCloseConst.aRun(bStart := FALSE);
                   


@SaText @RT(17)ADetectStandStill 1 @TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill THEN
    fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := sv_dStandStillDetectTime,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);
END_IF;

sv_bStandStillDetected := bStandStill;




@SaText @RT(28)AParToggleLeverAmplification 1 @TL(9)
// parametrization
ToggleLeverLintabPar.Mode.bZeroExtrapolation := FALSE;
ToggleLeverLintabPar.Mode.bLinearExtrapolation := TRUE;
ToggleLeverLintabPar.Mode.bSetNegativeValuesToZero :=FALSE;
ToggleLeverLintabPar.rXOffs := 0.0;
ToggleLeverLintabPar.rYOffs := 0.0;
ToggleLeverLintabPar.LintabPoints := sv_ToggleLeverLintabDerive.LintabPoints;
abToggleLeverLintab.Par(Param:=ToggleLeverLintabPar);


@SaText @RT(29)ACalcToggleLeverAmplification 1 @TL(25)
// calculate
abToggleLeverLintab.Calculate(rX:=sv_rMoldPosition);

IF ((abToggleLeverLintab.Calculate.rY) < sv_rMinAmplification) THEN
   //use at least a minimum value
   rAmplification := sv_rMinAmplification;
ELSIF ((abToggleLeverLintab.Calculate.rY) > sv_rMaxAmplification) THEN
   //don´t exceed a maximum value
   rAmplification := sv_rMaxAmplification;
ELSE
   //use calculated value
   rAmplification := abToggleLeverLintab.Calculate.rY;
END_IF;

IF bStop OR (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) OR bICMInterruptStop OR g_b2Platen THEN
   //movement interrupted (button released or locked) or movement to interrupt position is executed
   //or 2 platen IMM
   //-> use set valve delay time
   dValveOffDelay := sv_MoldCloseTimesSet.dSetDelayTimeValve;
ELSE
   //valve delay is done after high pressure build up
   //-> set valve delay for profile movement to 0.0s 
   dValveOffDelay := t#0.0s;
END_IF;


@SaText @RT(16)ACheckCalibError 1 @TL(5)
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;


@SaText @RT(16)ACheckClampForce 1 @TL(20)
fbClampPreTON(IN := sv_rClampForceAct > sv_ClampForce.rSetClampForce,
              PT := sv_dClampPressureCheckTime);
IF g_bDirectLockAvailable THEN
   IF NOT sv_bClampForceReached THEN
      IF NOT sv_bClampForceBuildUpWithTime THEN
         IF fbClampPreTON.Q THEN
            sv_bClampForceReached := TRUE;
         END_IF;
      ELSE
         fbBuildUpTimer(IN := sv_bMoldLockStageActive, 
                        PT := sv_ClampForceBuildUpTimeSet,
                        Q => sv_bClampForceReached,
                        ET => sv_ClampForceBuildUpTimeAct);
      END_IF;
   END_IF;
ELSE
   sv_bClampForceReached := sv_bMoldClosed; 
END_IF;



@SaText @RT(24)AResetConstOutputHiPress 1 @TL(13)
abConstHiPress.aRun(bStart := FALSE, // reset start flag
                    bStop := TRUE,
                    dMaxTime := T#0s);  // ignore timeout before start
sv_bMoldLockStageActive := TRUE;
sv_bClampForceReached := FALSE;
fbBuildUpTimer(IN:=FALSE);
fbClampPreTON(IN := FALSE);

sv_ConstHiPressVis.Pressure.PreOutput.rOutputValue := sv_rPressureAbs;
sv_ConstHiPressVis.Velocity.PreOutput.rOutputValue := mrSetVelocity;//sv_rVelocityAbs is usedd for pump, not for profile
mrStartOutputPres := sv_rPressureAbs;
mrStartOutputVel := mrSetVelocity;//sv_rVelocityAbs is usedd for pump, not for profile


@SaText @RT(20)ACalcValveController 1 @TL(211)
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN
   IF mbFastCloseLinked AND do_FastClose THEN
      rSetVelocityValve := sv_rFastVelocityFactor * rSetVelocity;
   ELSE
      rSetVelocityValve := rSetVelocity;   
   END_IF;
   IF sv_bPumpUseProfileVelociy THEN
      mrPumpVelocity := rSetVelocity;
   ELSE
      fbPumpVelocityOutput(Start := bStart,
                           Stop  := bStop,
                           ReParam  := FALSE,
                           PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                           StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                           InputValue := sv_rToggleLeverPosition,
                           Interrupt := FALSE,
                           DelayTime := T#0s);   
      IF fbPumpVelocityOutput.Error  THEN
         mrPumpVelocity := rSetVelocity;
      ELSE
         IF ((NOT abMoldClose.aRun.bActive) AND bStop)  THEN
            mrPumpVelocity := 0.0;
         ELSE
            mrPumpVelocity := fbPumpVelocityOutput.Output;      
         END_IF;
      END_IF;         
   END_IF;      
   
   IF sv_ServoValveControlData.bEnable THEN
      IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
           bStopActive := TRUE;    
      ELSE
           bStopActive := FALSE;  
      END_IF;
      
      //rYXSetPos := abYXGenLightB.Calculate.rS;  -> calculate after controller call
      rYXSetVel := rSetVelocityValve;
             
      IF NOT g_bPressureSensor1Available THEN
         abYXGenLightB.Calculate(rX:=sv_rToggleLeverPosition, bStopPointActive:=bStopActive);
         IF (abYXGenLightB.Calculate.calcStatus <> KCTRL_Ret_OK)  THEN
            sv_rMoldValveOutput := 0.0;
            sv_rVelocityAbs := 0.0; 
            RETURN; 
         END_IF; 
         rYXSetAccel := abYXGenLightB.Calculate.rA;
         rYXSetJerk := abYXGenLightB.Calculate.rJ;
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;     
      ELSIF NOT g_bPressureSensor2Available THEN
         abYXGenLightB.Calculate(rX:=sv_rToggleLeverPosition, bStopPointActive:=bStopActive);
         IF (abYXGenLightB.Calculate.calcStatus <> KCTRL_Ret_OK)  THEN
            sv_rMoldValveOutput := 0.0;
            sv_rVelocityAbs := 0.0; 
            RETURN; 
         END_IF; 
         rYXSetAccel := abYXGenLightB.Calculate.rA;
         rYXSetJerk := abYXGenLightB.Calculate.rJ;
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;          
       
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := rYXSetPos*1.0e-3,
                             rSetVelocity := -rYXSetVel*1.0e-3,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
      mrUP := abValveController.aRun.rUP;
      mrUD := abValveController.aRun.rUD;
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSE
         rMoldValveOutput := 0.5 * (rOffsetPos + rOffsetNeg); 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;
      
      // update reference position
      rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
      // integrator stop at maximum position (profile or interstop) of movement
      IF rYXSetPos < rEndValue  THEN
         rYXSetPos :=  rEndValue;
      END_IF;            

      
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, mrPumpVelocity);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rYXSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rYXSetVel);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetAccel, rYXSetAccel);
   ELSIF sv_bUseValve THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      IF mbUsePropValve THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := mrAreaOutletFactor * (rSetVelocityValve 
                   + sv_ServoValveControlData.rGainPFwd * (sv_rToggleLeverPosition - rYXSetPos)                       
                   + sv_ServoValveControlData.rGainDFwd * (rSetVelocityValve + sv_rToggleLeverVelEstimate));
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
         // update reference position
         rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
         // integrator stop at maximum position (profile or interstop) of movement
         IF rYXSetPos < rEndValue  THEN
            rYXSetPos :=  rEndValue;
         END_IF;            
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abMoldClose.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput);
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
      END_IF;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
   END_IF;

   bStart := FALSE;
ELSIF g_bMoldValve THEN
   IF (sv_bUseValve OR sv_ServoValveControlData.bEnable) THEN
      IF mbFastCloseLinked AND do_FastClose THEN
         rSetVelocityValve := sv_rFastVelocityFactor * rSetVelocity;
      ELSE
         rSetVelocityValve := rSetVelocity;   
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
      IF (mbUsePropValve AND sv_ServoValveControlData.bEnable) THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := mrAreaOutletFactor * (rSetVelocityValve
                   + sv_ServoValveControlData.rGainPFwd * (sv_rToggleLeverPosition - rYXSetPos)                       
                   + sv_ServoValveControlData.rGainDFwd * (rSetVelocityValve + sv_rToggleLeverVelEstimate));
         
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
         // update reference position
         rYXSetPos := rYXSetPos - rSetVelocityValve * rCycleTime;
         // integrator stop at maximum position (profile or interstop) of movement
         IF rYXSetPos < rEndValue  THEN
            rYXSetPos :=  rEndValue;
         END_IF;            
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abMoldClose.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput);
      END_IF;
   ELSE
       b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
       b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
   END_IF;
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, rSetVelocity);
END_IF;

mrSetVelocity := rSetVelocity;


@SaText @RT(20)AInitValveController 1 @TL(115)
IF g_bMoldValve THEN
   IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
      rEndValue := rInterruptTogglePosition; // use toggle lever position calculated from mold position sv_rFwdInterruptPosition
   ELSE
      rEndValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rStartPos;
   END_IF;
   IF rEndValue < 0.0 THEN
      rEndValue := 0.0;
   END_IF;
   rYXSetPos := sv_rToggleLeverPosition;

   IF NOT bInitDone THEN
      dCycleTime := GET_TASK_INTERVAL();
      rCycleTime := LINT_TO_REAL(TIME_TO_LINT(dCycleTime))/1.0e6;  
      bInitDone := TRUE;
   END_IF;
    
   IF g_bPressureSensorsAvailable THEN
      rQNom := sv_ValveData.rQNom / 60000.0; //l/min -> m/s
      rPNom := sv_ValveData.rDeltaPNom * 1.0e5; // bar -> N/m² 
      rQNomPB := sv_ValveData.rQNomPB / 60000.0; //l/min -> m/s
      rPNomPB := sv_ValveData.rDeltaPNomPB * 1.0e5; // bar -> N/mÂ²
      abValveController.aPar(rPistonArea1 := sv_ConstructionData.rPistonArea1,
                             rPistonArea2 := sv_ConstructionData.rPistonArea2,
                             rQNom := rQNom,
                             rDeltaPressNom := rPNom,
                             rQNomPB := rQNomPB,
                             rDeltaPressNomPB := rPNomPB,
                             bUsePB := sv_ValveData.bNominalAsysmmetric,
                             rMaxStroke := sv_rToggleLeverStroke*1.0e-3, // mm -> m
                             rVolume1 := sv_ConstructionData.rVolume1*1.0e-3, // dm³ -> m³
                             rVolume2 := sv_ConstructionData.rVolume2*1.0e-3, // dm³ -> m³
                             rGainP := sv_ServoValveControlData.rGainPFwd,
                             rGainD := sv_ServoValveControlData.rGainDFwd,
                             bPositiveVoltageIncreasing := 
                                sv_ServoValveControlData.bPositiveVoltageIncreasing,
                             bPositionIncreasing := FALSE);
      rSetPos := sv_rToggleLeverPosition;
      // trajectories generator: s, v, a, j
      abMoldClose.aGetVelocityProfile();
      CalcedVelocityProfile := abMoldClose.aGetVelocityProfile.CalcedVelocityProfile;
      Accelerations.rSoft  := CalcedVelocityProfile.StopAcceleration;
      Accelerations.rStop  := CalcedVelocityProfile.InterAcceleration;
      Accelerations.rStart := CalcedVelocityProfile.Acceleration;
      Param.Mode.RampType    := KCTRL_YXGen_RampType_Sin;
      Param.Mode.bPeriodMode := FALSE;;
      Param.ProfilePoints := CalcedVelocityProfile.ProfilePoints;
    
      abYXGenLightB.Par(dCycleTime:= dCycleTime,
                        Param:=Param,
                        InputType:=InputType);
      abYXGenLightB.ParAccelerations(Accelerations:=Accelerations);
      StopPoint.rX :=rInterruptTogglePosition - sv_rInterstopTolerance; 
      abYXGenLightB.ParStopPoint(StopPoint:=StopPoint); 
      abYXGenLightB.Init(rX0:=sv_rToggleLeverPosition,
                         rY0:=0.0);
      
 
      IF sv_ServoValveControlData.bEnable THEN
         IF NOT (g_bPressureSensor1Available AND g_bPressureSensor2Available) THEN
            abEstimatePressure.aPar(rMassPiston := sv_ConstructionData.rMassPiston,
                              rMassMold := sv_ConstructionData.rMassMold,
                              rViscoseFrictonCylinder := sv_ConstructionData.rViscoseFrictonCylinder,
                              rViscoseFrictonMold := sv_ConstructionData.rViscoseFrictonMold,
                              rCoulombFrictonCylinder := sv_ConstructionData.rCoulombFrictonCylinder,
                              rCoulombFrictonMold := sv_ConstructionData.rCoulombFrictonMold,
                              rPistonArea1 := sv_ConstructionData.rPistonArea1,
                              rPistonArea2 := sv_ConstructionData.rPistonArea2,
                              ToggleLeverSplineData:=sv_ToggleLeverSplineData);
         END_IF;
      END_IF;           
   END_IF;
        
   IF sv_MoldFwdProfVis.rMaxRampVel > sv_MoldBwdProfVis.rMaxRampVel THEN
      rStopRamp := sv_MoldBwdProfVis.rMaxRampVel;
   ELSE
      rStopRamp := sv_MoldFwdProfVis.rMaxRampVel;
   END_IF;
   fbConstOutputRamp(bReParam:=TRUE,
                    bStart:=TRUE,
                    bStop := FALSE,
                    rActValue:=sv_rToggleLeverPosition,           
                    rStartValue:= rMaxVoltageValve,
                    rMinOutput := rMinOutput,
                    LintabParam:=sv_ValveCharacteristicLintab,
                    bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                    bProfileRamp:=FALSE,
                    rEndValue:=rEndValue,
                    bDir:=FALSE,
                    rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,
                    rStopRamp:=rStopRamp,
                    bActive := abMoldClose.aRun.bActive);
    
   
   fbPumpVelocityOutput(Start := FALSE,
                        Stop  := FALSE,
                        ReParam  := TRUE,
                        CycleTime := dCycleTime,
                        PreRamp := 1.0e10,
                        PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                        StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                        ProfilData := PumpVelocityProfile,
                        MinOutput := 0.0,
                        RampType := sv_MoldBwdProfVis.RampTypeVel,
                        OpenEnd := sv_MoldBwdProfVis.bOpenEndProfile,
                        DeadTime := T#0s,
                        InputValue := sv_rToggleLeverPosition,
                        Interrupt := FALSE,
                        DelayTime := T#0s);
   
   rPessureDrop := MAX(0.0, sv_rMoldValvePressureDropClose);
   
   bStart := TRUE;
END_IF;


@SaText @RT(16)AResetIdentBlock 1 @TL(8)
sv_rFwdInterruptPosition := sv_rIdentPosition;
IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
   rPositionDown := (sv_rToggleLeverPosition + sv_rFwdInterruptPosition) * 0.5;   
END_IF;
abMoldCloseStep.aRun(bStart := FALSE);



@SaText @RT(27)ACalcValveControllerHiPress 1 @TL(145)
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN

   IF sv_ServoValveControlData.bEnable THEN
      IF sv_bPumpUseProfileVelociy THEN
         mrPumpVelocity := abConstHiPress.aRun.rOutputVel;
      ELSE
         fbPumpVelocityOutput(Start := bStart,
                              Stop  := bStop,
                              ReParam  := FALSE,
                              PreOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY,
                              StartOutputValue := PumpVelocityProfile.ProfilePoints.Point[1].rY, 
                              InputValue := sv_rToggleLeverPosition,
                              Interrupt := FALSE,
                              DelayTime := T#0s);   
         IF fbPumpVelocityOutput.Error  THEN
            mrPumpVelocity := rSetVelocity;
         ELSE
            IF abConstHiPress.aRun.bActive THEN
               mrPumpVelocity := fbPumpVelocityOutput.Output;      
            ELSE
               mrPumpVelocity := 0.0;
            END_IF;
         END_IF;         
      END_IF;
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, mrPumpVelocity);
      
      IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
           bStopActive := TRUE;    
      ELSE
           bStopActive := FALSE;  
      END_IF;  

      rYXSetPos := rYXSetPos - mrSetVelocity * rCycleTime;
      rYXSetVel := mrSetVelocity;
             
      IF NOT g_bPressureSensor1Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure2*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := TRUE);
         rPressure1 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure2 := sv_rMoldPressure2*1.0e5;  
      ELSIF NOT g_bPressureSensor2Available THEN
         abEstimatePressure.aRun(rPressure := sv_rMoldPressure1*1.0e5, 
                                 rSetPos    := rYXSetPos*1.0e-3,
                                 rSetVel    := rYXSetVel*1.0e-3,
                                 rSetAccel  := rYXSetAccel*1.0e-3,
                                 bCalcPressure1 := FALSE);
         rPressure2 := abEstimatePressure.aRun.rPressureEstimate;
         rPressure1 := sv_rMoldPressure1*1.0e5;  
      ELSE    
         rPressure1 := sv_rMoldPressure1*1.0e5;
         rPressure2 := sv_rMoldPressure2*1.0e5;    
      END_IF;          
       
       
      // use SI-units 
      abValveController.aRun(bStart := bStart,
                             rSetPosition := rYXSetPos*1.0e-3,
                             rSetVelocity := -rYXSetVel*1.0e-3,
                             rActPosition := sv_rToggleLeverPosition*1.0e-3,
                             rActVelocity := sv_rToggleLeverVelEstimate*1.0e-3,
                             rSystemPressure := pSysPressure^*1.0e5,
                             rTankPressure := rTankPressure*1.0e5,
                             rPressure1 := rPressure1,
                             rPressure2 := rPressure2);

      rOutput := abValveController.aRun.rU;
       
    
      IF rOutput > 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
         
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := abValveController.aRun.rU + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
         
      ELSE
         rMoldValveOutput := 0.5 * (rOffsetPos + rOffsetNeg); 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;

      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rYXSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rYXSetVel);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetAccel, rYXSetAccel);
   ELSIF sv_bUseValve THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
      IF mbUsePropValve THEN // calc feed forward if init OK
         // use feedforward calculated from pressure drop at prop valve
         rSetFlow := abConstHiPress.aRun.rOutputVel * mrAreaOutletFactor;
         abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                                  rFlow := rSetFlow);                  
         mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
         mrPressOutlet := rPessureDrop;
         mrSetFlowOutlet := rSetFlow;
      ELSE   
         fbConstOutputRamp(bStart:=FALSE,
                           bStop:=bStop,
                           rActValue:=sv_rToggleLeverPosition,
                           bInterstopRamp:=abMoldClose.aRun.bOnInterstopRamp,
                           bProfileRamp:=FALSE,
                           rEndValue:=rEndValue,
                           bDir:=FALSE,
                           rStartValueStopRamp:=abMoldClose.aRun.rVelocityOutput,    
                           rStopRamp:=rStopRamp,
                           bActive := abConstHiPress.aRun.bActive);
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, fbConstOutputRamp.rOutput); 
         b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      END_IF;
   ELSE
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetPos, rSetPos);
      b := WRITE_SVREAL_DIRECT(sv_ServoValveControlSet.rSetVel, rSetVelocity);
   END_IF;

   bStart := FALSE;
ELSIF g_bMoldValve THEN
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
   IF (mbUsePropValve AND sv_ServoValveControlData.bEnable) THEN // calc feed forward if init OK
      // use feedforward calculated from pressure drop at prop valve
      rSetFlow := abConstHiPress.aRun.rOutputVel * mrAreaOutletFactor;
      abPropValve.aCalcVoltage(rPressure := rPessureDrop,
                               rFlow := rSetFlow);                  
      mrPropValveOutput := abPropValve.aCalcVoltage.rControlVoltage * mrSign;
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, mrPropValveOutput);
      mrPressOutlet := rPessureDrop;
      mrSetFlowOutlet := rSetFlow;
   ELSE   
      b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMaxVoltageValve);
   END_IF;
ELSE
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
END_IF;



@SaText @RT(27)AInitValveControllerHiPRess 1 @TL(6)
IF g_bMoldValve AND g_bPressureSensorsAvailable THEN
   rYXSetPos := sv_rToggleLeverPosition;
   rYXSetAccel := 0.0;
   rYXSetJerk  := 0.0;
END_IF;


@SaText @RT(22)AResetStandStillDetect 1 @TL(3)
fbStandStill(bDoCalib := FALSE);
bStandStill := FALSE;


@SaText @RT(27)ADetectStandStillMoldAdjust 1 @TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill AND sv_bPresMoldHeightAdjustActive THEN
    fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := sv_dStandStillDetectTime,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);
END_IF;


@SaText @RT(16)AICMInterruptPos 1 @TL(5)
IF bICMInterruptStop THEN
    //Set the interrupt position if use ICM
    sv_rFwdInterruptPosition := sv_rSetMoldStartPosition;
END_IF;


@SaText @RT(17)aICMInterruptStop 1 @TL(9)
IF IS_LINKED(sv_ICMMode) THEN

    IF (sv_CoiningActivateMode <> nDeactivate) 
            OR (sv_VentingActivateMode <> nDeactivate) THEN  

        bICMInterruptStop := TRUE;     //Interrupt stop for ICM
    END_IF;
END_IF;


@SaText @RT(14)AMoldCloseTime 1 @TL(5)

IF g_MoveCtrl.pData^.MoveId <> cMoveFwdInterPos THEN
   b := WRITE_SV_DIRECT(sv_dActCloseTime, abMoldClose.aRun.dActMoveTime);
END_IF;


@SaText @RT(17)AResetCalibBlock2 1 @TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStart := FALSE,
                    LintabPoint := sv_TmpLintabPoint);

IF g_bMoldValve THEN
   sv_rMoldValveOutput := rMaxVoltageValve;
END_IF;


@SaText @RT(17)ATransducerCalib2 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                    bStart := TRUE,
                    rActVoltage := ai_Position,
                    rMaxVoltageDiff := sv_rMaxVoltageDiff,
                    dStandStillDetectTime := sv_dStandStillDetectTime,
                    LintabPoint := dummypoint,
                    rSetValue := 0.0,
                    bActive => sv_bOutputActive,
                    rOutputPre => sv_rPressureAbs,
                    rOutputVel => sv_rVelocityAbs,
                    bPreOutputReached => sv_bPreOutputReady);
sv_bDoTransducerCalib := NOT (abMoldFwdCalib.aRun.bPointDetected);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(16)ATransducerCalib 1 @TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                    bStart := TRUE,
                    rActVoltage := ai_Position,
                    rMaxVoltageDiff := sv_rMaxVoltageDiff,
                    dStandStillDetectTime := sv_dStandStillDetectTime,
                    LintabPoint := sv_TmpLintabPoint,
                    rSetValue := 0.0,
                    dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                    dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                    bActive => sv_bOutputActive,
                    rOutputPre => sv_rPressureAbs,
                    rOutputVel => sv_rVelocityAbs,
                    bPreOutputReached => sv_bPreOutputReady,
                    iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abMoldFwdCalib.aRun.bPointDetected);
bError := abMoldFwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)AStepOutput 1 @TL(51)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseStep.aRun(bUsePosDetect := sv_rFwdInterruptPosition <> 0.0,
                     rPositionDown := (sv_rToggleLeverPosition + sv_rFwdInterruptPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedFwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := FALSE,
                     rActPos := sv_rToggleLeverPosition,
                     rTargetPos := sv_rFwdInterruptPosition,
                     dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffFwd,
                     rPositionUp := sv_rToggleLeverPosition,
                     rHighOutput := sv_ConstFwdVis.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

IF (g_bMoldValve) THEN
   // if use stop ramp close mold valve
   IF (sv_rToggleLeverPosition <rPositionDown) AND (sv_ConstFwdVis.Velocity.Output.rOutputValue > 0.0) THEN
      rOutput := rMaxVoltageValve * sv_rVelocityAbs / sv_ConstFwdVis.Velocity.Output.rOutputValue;
      IF rOutput > 0.0 THEN
         rMoldValveOutput := rOutput + rOffsetPos;
         IF rMoldValveOutput > MAX_VOLTAGE THEN
            rMoldValveOutput := MAX_VOLTAGE;
         END_IF;
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      ELSIF rOutput < 0.0 THEN
         rMoldValveOutput := rOutput + rOffsetNeg;
         IF rMoldValveOutput < -MAX_VOLTAGE THEN
            rMoldValveOutput := -MAX_VOLTAGE;
         END_IF; 
         b := WRITE_SVREAL_DIRECT(sv_rMoldValveOutput, rMoldValveOutput);
      END_IF;
   END_IF;
END_IF;



@SaText @RT(14)AProfileOutput 1 @TL(34)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abLintabApplyToggle.aCalcInv(rY := sv_rFwdInterruptPosition,
                             rX => rInterruptTogglePosition);

abMoldClose.aRun(bStop := sv_bTransducerError OR bStop OR FALSE,
                 rInterruptPosition := rInterruptTogglePosition - sv_rInterstopTolerance,
                 bUseInterruptPos := (g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos) OR bICMInterruptStop,
                 bStart := TRUE,
                 rActPosition := sv_rToggleLeverPosition,
                 dMaxMoveTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                 dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                 dDelayTimeOff := dValveOffDelay,
                 DeadTime := sv_dSetDelayTimeOffFwd,
                 rAmplification := rAmplification,
                 ManualDelayTime := sv_CloseManualDelayTime,
                 StopDeadTime := sv_CloseInterstopDeadTime,
                 rInterruptAccel := sv_rFwdInterruptAccel,
                 rInterruptDeaccel := sv_rFwdInterruptDeaccel,
                 rSmoothFactor := sv_rSmoothFactor,
                 rVelocityOutput => rSetVelocity,
                 bActive => sv_bOutputActive,
                 iActiveStage => sv_iActiveStage,
                 bPreOutputReached => sv_bPreOutputReady);
                 
b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abMoldClose.aRun.rPressureOutput);                 
b := WRITE_SV_DIRECT(sv_MoldCloseTimesAct.dActMoveTime, abMoldClose.aRun.dActMoveTime);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);                 


@SaText @RT(15)AMoldProtection 1 @TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldProtection.aRun(bMovementActive := sv_bOutputActive,
                      rActPosition := sv_rMoldPosition,
                      pVisProfile := @sv_MoldFwdProfVis,
                      dProtectTime := sv_dMoldProtectTimeSet);
b := WRITE_SV_DIRECT(sv_dMoldProtectTimeAct, abMoldProtection.aRun.dActTime); 


@SaText @RT(25)AConstOutputMHAdjustSetup 1 @TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseConst.aRun(bStop := (bStop OR bStandStill OR sv_bTransducerError OR bPosReached),
                      bStart := TRUE,
                      bDirection := FALSE,
                      rActPos := sv_rMoldPosition,
                      rTargetPos := rTargetPos,
                      bUsePosDetect := TRUE,
                      dMaxTime := sv_MoldCloseTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bActive => sv_bOutputActive,
                      dActTime => sv_MoldCloseTimesAct.dActMoveTime,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(19)AConstOutputHiPress 1 @TL(52)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF (NOT sv_bClampForceReached) THEN
   // use const output
   abConstHiPress.aRun(bStop := bStop OR bStandStill,
                       bStart := TRUE,
                       bDirection := FALSE,
                       rActPos := sv_rMoldPosition,
                       bUsePosDetect := FALSE,
                       rStartOutputPre := mrStartOutputPres,
                       rStartOutputVel := mrStartOutputVel,
                       dMaxTime := sv_MoldLockTimesSet.dMaxMoveTime,
                       dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                       bActive => sv_bOutputActive,
                       bPreOutputReached => sv_bPreOutputReady);

   sv_bMoldLockStageActive := sv_bOutputActive;
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abConstHiPress.aRun.rOutputPre);
   IF NOT abConstHiPress.aRun.bActive THEN
      b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abConstHiPress.aRun.rOutputVel);
   END_IF;
   mrSetVelocity := abConstHiPress.aRun.rOutputVel;
   b := WRITE_SV_DIRECT(sv_MoldLockTimesAct.dActMoveTime, abConstHiPress.aRun.dActTime);
   dActCloseTime := abConstHiPress.aRun.dActTime + sv_MoldCloseTimesAct.dActMoveTime;
   b := WRITE_SV_DIRECT(sv_dActCloseTime, dActCloseTime);

   abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

   abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);
ELSE
// stop at sv_bClampForceReached
   sv_bOutputActive := FALSE;   
   sv_bMoldLockStageActive := sv_bOutputActive;
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, 0.0);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, 0.0);   
   mrSetVelocity := 0.0;
   b := WRITE_SV_DIRECT(sv_MoldLockTimesAct.dActMoveTime, abConstHiPress.aRun.dActTime);
   dActCloseTime := abConstHiPress.aRun.dActTime + sv_MoldCloseTimesAct.dActMoveTime;
   b := WRITE_SV_DIRECT(sv_dActCloseTime, dActCloseTime);

   abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

   sv_rVelocityAbs := 0.0;
   abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);   
END_IF;


@SaText @RT(12)AConstOutput 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldCloseConst.aRun(bUsePosDetect := (sv_rFwdInterruptPosition <> 0.0),
                      bStart := TRUE,
                      bStop := bStop,
                      bDirection := FALSE,
                      rActPos := sv_rMoldPosition,
                      rTargetPos := sv_rFwdInterruptPosition,
                      dDelayTimeOn := sv_MoldCloseTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_MoldCloseTimesSet.dSetDelayTimeValve,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bActive => sv_bOutputActive,
                      dActTime => sv_MoldCloseTimesAct.dActMoveTime,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(17)ACalcPumpVelocity 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoldClose.aInit(pProfile := @sv_ToggleFwdProfVis,
                  MoveDir := sv_MoveClose.MoveDir,
                  pdCalcedDuration := @sv_dCalculatedDurationClose,
                  prCalcDurationStartPosition := @sv_MoldBwdProfVis.Profile.Points[sv_MoldBwdProfVis.Profile.iNoOfPoints + 1].rStartPos,
                  pInstanceDataInterPos := @sv_InstanceDataCloseToggleInter);

abMoldCloseConst.aInit(pConst := @sv_ConstFwdVis,
                       MoveId := cMoveFwd);

abMoldFwdCalib.aInit(pConst := @sv_ConstFwdVis,
                     MoveId := cMoveFwd);

abConstHiPress.aInit(pConst := @sv_ConstHiPressVis,
                     MoveId := cMoveFwd);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutFwdP);
abLintabApplyVel.aInit(pLintab := @sv_LintabOutFwdV);

abMoldClose.aInitMaxRamps(prMaxAbsAccelStart := @sv_MoldBwdProfVis.rMaxRampVel,
                          prMaxAbsAccelEnd := @sv_MoldFwdProfVis.rMaxRampVel,
                          prPosAccelStart := @sv_MoldFwdProfVis.Profile.Points[1].rStartPos,
                          prPosAccelEnd := @sv_MoldBwdProfVis.Profile.Points[1].rStartPos,
                          bUseAccelerationReduction := NOT g_bDirectLockAvailable);

abLintabApplyToggle.aInit(pLintab := @sv_ToggleLeverLintab);

abLintabApplyToggleSlow.aInit(pLintab := @sv_ToggleLeverLintab);

abMoldCloseStep.aInit(pConst := @sv_ConstFwdVis,
                      MoveId := cMoveFwd,
                      prMaxSpeed := @sv_rMaxSpeedFwd);

mbFastCloseLinked := IS_LINKED(do_FastClose);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to fwd profile
sv_MoldFwdProfVis.rMinOutputVel := sv_MinOutputFwd.rVelocity;
sv_MoldFwdProfVis.rMinOutputPress := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd constoutput
sv_ConstFwdVis.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdVis.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy stroke to start position of first profile point
sv_MoldFwdProfVis.Profile.Points[1].rStartPos := sv_rMoldStroke;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(58)
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Close.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Close.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrSetVelocity);
variableName := CONCAT(fuName,'.Close.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
variableName := CONCAT(fuName,'.Close.bLockStageActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bMoldLockStageActive);



variableName := CONCAT(fuName,'.rMoldValveOutput');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rMoldValveOutput);
variableName := CONCAT(fuName,'.Control.rSetPos');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetPos);
variableName := CONCAT(fuName,'.Control.rSetVel');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetVel);
variableName := CONCAT(fuName,'.Control.rSetAccel');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetAccel);
variableName := CONCAT(fuName,'.Control.rSetJerk');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_ServoValveControlSet.rSetJerk);


variableName := CONCAT(fuName,'.Close.rPumpVelocity');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrPumpVelocity);
variableName := CONCAT(fuName,'.Control.rUP_Fwd');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrUP);
variableName := CONCAT(fuName,'.Control.rUD_Fwd');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := mrUD);


STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(40)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Take last stage of the profile (High Pressure) as value for constant output
sv_ConstHiPressVis.Pressure.Output.rOutputValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rPressure;
sv_ConstHiPressVis.Velocity.Output.rOutputValue := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rVelocity;

IF g_b2Platen THEN
   sv_MoldFwdProfVis.rEndOutputPress := 0.0;
   sv_MoldFwdProfVis.rEndOutputVel := 0.0;
ELSE
   sv_MoldFwdProfVis.rEndOutputPress := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints-1].rPressure;
   sv_MoldFwdProfVis.rEndOutputVel := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints-1].rVelocity;
END_IF;



//mold close profile must stop before high pressure because high pressure is done by a constant output
// -> copy start pos to both profile points so that profile movement ends at this position
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rStartPos := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rStartPos;
//also copy endoutput values to pressure and velocity value of next profile stage
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rPressure := sv_MoldFwdProfVis.rEndOutputPress;
sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints+1].rVelocity := sv_MoldFwdProfVis.rEndOutputVel;


// set ramps for high pressure stage const movement
sv_ConstHiPressVis.Pressure.Output.rRamp := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rPressRamp * sv_MoldFwdProfVis.rMaxRampPress / 100.0;
sv_ConstHiPressVis.Velocity.Output.rRamp := sv_MoldFwdProfVis.Profile.Points[sv_MoldFwdProfVis.Profile.iNoOfPoints].rVelRamp * sv_MoldFwdProfVis.rMaxRampVel / 100.0;

 








@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
START_PROCESS_ALGORITHM(paCalcToggleProfile);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//save reference to calced profile
pCalcedProfile := sv_ToggleFwdProfVis.pCalculatedProfile;

sv_ToggleFwdProfVis := sv_MoldFwdProfVis;
FOR i:= 1 TO sv_MoldFwdProfVis.Profile.iNoOfPoints+1 DO
    abLintabApplyToggleSlow.aCalcInv(rY := sv_MoldFwdProfVis.Profile.Points[i].rStartPos,
                                 rX => sv_ToggleFwdProfVis.Profile.Points[i].rStartPos);
END_FOR;

//copy original reference
sv_ToggleFwdProfVis.pCalculatedProfile := pCalcedProfile;

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
START_PROCESS_ALGORITHM(paCalcToggleInterPos);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_InstanceDataCloseToggleInter := sv_InstanceDataCloseInterPos;
FOR i:=1 TO cMaxIntermediateConditions DO
    abLintabApplyToggleSlow.aCalcInv(rY := sv_InstanceDataCloseInterPos[i].rTargetValue,
                                 rX => sv_InstanceDataCloseToggleInter[i].rTargetValue);
END_FOR;
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
IF g_bMoldValve THEN
    IF sv_ValveData.rValveOffsetFwd > sv_ValveData.rValveOffsetBwd THEN
        rOffsetPos := sv_ValveData.rValveOffsetFwd;
        rOffsetNeg := sv_ValveData.rValveOffsetBwd;
        rMaxVoltageValve := MAX_VOLTAGE;
    ELSE    
        rOffsetPos := sv_ValveData.rValveOffsetBwd;
        rOffsetNeg := sv_ValveData.rValveOffsetFwd;
        rMaxVoltageValve := -MAX_VOLTAGE;
    END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Copy only necessary, if any calculated duration has changed
FOR i := 1 TO cMaxIntermediateConditions DO
   IF (sv_InstanceDataCloseToggleInter[i].dCalculatedDuration <> InstDataCloseToggleInter[i].dCalculatedDuration) THEN
      bCopyDurations := TRUE;
      EXIT;   
   END_IF; 
END_FOR; 

IF bCopyDurations THEN
   //Copy calculated duration to instance data array
   FOR i := 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataCloseInterPos[i].dCalculatedDuration := sv_InstanceDataCloseToggleInter[i].dCalculatedDuration;              
   END_FOR;
   
   InstDataCloseToggleInter := sv_InstanceDataCloseToggleInter;

   bCopyDurations := FALSE;
END_IF;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

START_PROCESS_ALGORITHM(paCalcDisplayedPresProfile);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

START_PROCESS_ALGORITHM(paCalcDisplayedVelProfile);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(46)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile := sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile;
FOR i:=1 TO sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints DO
   abLintabApplyToggleSlow.aCalc(rX := sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.Point[i].rX,
                               rY => sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[i].rX);
END_FOR;    
sv_CalculatedProfileFwd.VelocityProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter;
  
// ad clamp force build-up velocity
//sv_ConstHiPressVis.Velocity.Output.rOutputValue;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints := sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints +3;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints].rX := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints].rY := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-1].rX := 0.0;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-1].rY := 
    sv_ConstHiPressVis.Velocity.Output.rOutputValue;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-2].rX := 
    sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-3].rX;
sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.VelocityProfile.CalculatedProfile.uNoOfPoints-2].rY := 
    sv_ConstHiPressVis.Velocity.Output.rOutputValue;

// calc velocity profile for pump
IF (sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints > 0) THEN
   PumpVelocityProfile.ProfilePoints.uNoOfPoints := 2;
   rMaxVelProfFwd := 0.0;
   FOR i := 1 TO sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.uNoOfPoints DO
      rMaxVelProfFwd :=MAX(rMaxVelProfFwd, sv_CalculatedProfileFwdToggle.VelocityProfile.CalculatedProfile.Point[i].rY);
   END_FOR;
   PumpVelocityProfile.ProfilePoints.Point[1].rX := sv_rToggleLeverStroke;
   PumpVelocityProfile.ProfilePoints.Point[1].rY := MIN(1.1*rMaxVelProfFwd, sv_rMaxSpeedFwd);
   PumpVelocityProfile.ProfilePoints.Point[2].rX := 0.0;
   PumpVelocityProfile.ProfilePoints.Point[2].rY := PumpVelocityProfile.ProfilePoints.Point[1].rY;
   PumpVelocityProfile.Acceleration := sv_ToggleFwdProfVis.rMaxRampVel;
   PumpVelocityProfile.InterAcceleration := sv_ToggleFwdProfVis.rMaxRampVel;
   PumpVelocityProfile.StopAcceleration := sv_ToggleFwdProfVis.rMaxRampVel;
END_IF;
        
// signalize a change in calculated velocity profile
sv_CalculatedProfileFwd.VelocityProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.VelocityProfile.iProfileChangedCounter;
    
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(29)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile := sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile;
FOR i:=1 TO sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile.uNoOfPoints DO
   abLintabApplyToggleSlow.aCalc(rX := sv_CalculatedProfileFwdToggle.PressureProfile.CalculatedProfile.Point[i].rX,
                               rY => sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[i].rX);
END_FOR;    

// ad clamp force build-up pressure
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints := sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints + 3;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints].rX := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints].rY := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-1].rX := 0.0;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-1].rY := 
    sv_ConstHiPressVis.Pressure.Output.rOutputValue;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-2].rX := 
    sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-3].rX;
sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.Point[sv_CalculatedProfileFwd.PressureProfile.CalculatedProfile.uNoOfPoints-2].rY := 
    sv_ConstHiPressVis.Pressure.Output.rOutputValue;

        
// signalize a change of calculated profile
sv_CalculatedProfileFwd.PressureProfile.iProfileChangedCounter := sv_CalculatedProfileFwdToggle.PressureProfile.iProfileChangedCounter;
    
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
IF IS_LINKED(sv_ICMMode) THEN  
    
    IF (sv_CoiningActivateMode = nDeactivate) 
        AND (sv_VentingActivateMode = nDeactivate) THEN  
        
        //pointer to mold closed if deactivate ICM 
        sv_MoveClose.pbPosReached := @sv_bMoldClosed;
    END_IF;    
END_IF;    



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
IF IS_LINKED(sv_rMoldPropValveParams) AND
   IS_LINKED(sv_ValveData) AND
   IS_LINKED(sv_ConstructionData) THEN

   abPropValve.aInit(ValveParams := sv_rMoldPropValveParams);
   // [l/min] = [mm³/s]*60/10^6 = [m²]*[mm/s]*60 => [v] = [mm/s],[rPistonArea1]=[m²] 
   mrAreaOutletFactor := sv_ConstructionData.rPistonArea2 * 60.0;
   IF (sv_ValveData.rValveOffsetBwd > sv_ValveData.rValveOffsetFwd) THEN
      mrSign := -1.0;
   ELSE
      mrSign := 1.0;
   END_IF;
 
   IF (abPropValve.aInit.bInitDone AND (mrAreaOutletFactor > 0.0)) THEN
      mbUsePropValve := TRUE;
   ELSE
      mbUsePropValve := FALSE;
   END_IF;
   
ELSE
   mbUsePropValve := FALSE;
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
