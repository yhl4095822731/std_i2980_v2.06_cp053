IMPORT_OVER_LISTFILE
 WRITE_SV_DIRECT
, GET_SYNC_REFTO
, SET_ALARM
, IS_LINKED
, cSubOptionMoldDirectLock
, nAnaOutputModeMid
, cMovePVCalib
, cMoveBwd
, cMoveFwd
, cMoveAll
, cMoveCoining
, cMoveVenting
, cMoveBwdInterPos
, cMoveFwdInterPos
, nSequentialICM
, nParallelICM
, nSetup
, nReady
, cApplPlasticsPI
, KSYS_Status_OK
, KAPPL_LintabData
, KAPPL_LintabData_2P
, tOptionId
, tnOperationMode
, KAPPL_VisProfile
, tsCylinderData
, tsToggleLeverSplineData
, tServoValveConstructionData
, tServoValveControlData
, tsControlParameters
, tsDerivationEstimateParam
, tnDataState
, tnICMMode
, tsMoveData
, tyInterCondTimeArray
, tsRequiredPumps
, tsHydrMaxValues
, tsPropValveParams
, tServoValveData
, tsMoveCtrl
, ABMoveOpen
, ABMoveClose
, ABLintabApply
, ABPositionController
, ABMoveCoining
, ABMoveVenting
, ABMovementHistory
, ABMovePVCalib
, ABCalcHydrMaxValues
, ABUpdateRelLintabPre
, ABUpdateRelLintabVel
, ABOutputRequest
, ABLintabAnalysis
, KSYS_Status

END_IMPORT

ALGORITHM_BLOCK ABMovementAdmin #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_bInitStart : BOOL;
 sv_bDeviceStart : BOOL (* Start Device *);
 sv_ToggleLeverLintab : KAPPL_LintabData (* lintab for toggle lever pos(x) -> platen pos(y) *);
 sv_ToggleLeverLintabDerive : KAPPL_LintabData (* derivation calculated from sv_ToggleLeverLintab *);
 sv_rToggleLeverStroke : REAL (* Opening Stroke of toggle lever *);
 sv_rMoldStroke : REAL (* Opening Stroke of Mold *);
 sv_ToggleLeverPosLintab : KAPPL_LintabData_2P (* lintab for voltage(x) -> toggle lever pos(y) *);
 sv_MoldLintab : KAPPL_LintabData_2P;
 sv_Options : tOptionId;
 sv_iActiveStage : DINT;
 sv_iActiveStageFwd : DINT (* active profile stage mold close (fwd) *);
 sv_iActiveStageBwd : DINT (* active profile stage mold open (bwd) *);
 sv_bDeviceReady : BOOL;
 sv_OperationMode : tnOperationMode;
 sv_bMoldLockStageActive : BOOL;
 sv_MoldFwdProfVis : KAPPL_VisProfile;
 ao_Valve : REAL;
 sv_CylinderData : tsCylinderData;
 sv_ToggleLeverSplineData : tsToggleLeverSplineData;
 sv_bInitDone : BOOL;
 sv_ConstructionData : tServoValveConstructionData;
 sv_ServoValveControlData : tServoValveControlData;
 sv_MoldPosControlParam : tsControlParameters;
 sv_rToggleLeverPosition : REAL;
 sv_rToggleLeverSetPosition : REAL;
 sv_rPositionTolerance : REAL;
 sv_rMaxPositionTolerance : REAL;
 sv_LintabOutMoldPosCtrl : KAPPL_LintabData;
 sv_dMaxPosCtrlTime : TIME;
 sv_DerivationEstimateParToggle : tsDerivationEstimateParam;
 sv_DataState : tnDataState;
 sv_ICMMode : tnICMMode;
 sv_rBwdInterruptPosition : REAL;
 sv_rFwdInterruptPosition : REAL;
 sv_MoveCloseInterPos : tsMoveData (* move forward to intermediate position *);
 sv_MoveOpenInterPos : tsMoveData (* move backward to intermediate position *);
 sv_MoveClose : tsMoveData;
 sv_MoveOpen : tsMoveData;
 sv_bStepBwdActive : BOOL (* TRUE: stepping bwd is active *);
 sv_bStepPosReached : BOOL (* TRUE: target position of step bwd movement reached (only needed for stepping bwd) *);
 sv_bMoldClosed : BOOL;
 sv_bMoldOpen : BOOL;
 sv_ActiveTimesCloseInterPos : tyInterCondTimeArray;
 sv_ActiveTimesOpenInterPos : tyInterCondTimeArray;
 sv_RequiredPumpsClose : tsRequiredPumps;
 sv_RequiredPumpsOpen : tsRequiredPumps;
 sv_HydrMaxValuesClose : tsHydrMaxValues (* hydraulic max values for mold close *);
 sv_HydrMaxValuesOpen : tsHydrMaxValues (* hydraulic max values for mold open *);
 sv_LintabOutFwdP : KAPPL_LintabData;
 sv_LintabOutFwdV : KAPPL_LintabData;
 sv_LintabOutBwdP : KAPPL_LintabData;
 sv_LintabOutBwdV : KAPPL_LintabData;
 sv_rMaxSpeedFwd : REAL;
 sv_rMaxPressureFwd : REAL;
 sv_rMaxSpeedBwd : REAL;
 sv_rMaxPressureBwd : REAL;
 sv_bDoPumpVelocityCalib : BOOL;
 sv_rMaxSpeedFwdCalc : REAL;
 sv_rMaxSpeedBwdCalc : REAL;
 sv_rMaxSpeedFwdCalib : REAL;
 sv_rMaxSpeedBwdCalib : REAL;
 sv_rMaxSpeedReducePercent : REAL;
 sv_bFALSE : BOOL;
 sv_rMoldPropValveParams : tsPropValveParams;
 sv_ValveData : tServoValveData;
 sv_rFastVelocityFactor : REAL;
END_VAR

SYSTEM_OBJECT
 PU_Task_7 : TASK;
 TaskAnalog : TASK;
 EV_Task_1 : TASK;
 PU_Task_3 : TASK;
 TaskSlow : TASK;
 erMoldControlSensorNotAvailable : ALARM;
END_OBJECT

VAR_EXTERNAL
 g_MoveCtrl : tsMoveCtrl;
 g_bDirectLockAvailable : BOOL;
 g_bMoldValve : BOOL;
 g_bPressureSensorsAvailable : BOOL;
 pSysPressure : REFTO REAL;
 g_bPressureSensor1Available : BOOL;
 g_bPressureSensor2Available : BOOL;
 g_b2Platen : BOOL;
END_VAR

VAR
 abMoveOpen : ABMoveOpen;
 abMoveClose : ABMoveClose;
 abLintabToggleLeverStroke : ABLintabApply;
 abPositionController : ABPositionController;
 mbUseToggleLeverEstimate : BOOL;
 abMoveCoining : ABMoveCoining;
 abMoveVenting : ABMoveVenting;
 abMovementHistory : ABMovementHistory;
 abMovePVCalib : ABMovePVCalib;
 miDigitsToFloor : SINT := 2;
 mbPropValve : BOOL;
 mpbMoldLockStageActive : REFTO BOOL;
END_VAR

(*
Calls the registration-algo of every movementblock after the deviceregistration succeeded(sv_bInitStart->true)

*)

POSTUPDATE_ALGORITHM pInitStart ON PU_Task_7 WITH sv_bInitStart


VAR
 abCalcMaxValuesClose : ABCalcHydrMaxValues;
 abCalcMaxValuesOpen : ABCalcHydrMaxValues;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bInitStart THEN
    //Register Movement Mold Open    
    g_bDirectLockAvailable := (sv_Options AND cSubOptionMoldDirectLock) = cSubOptionMoldDirectLock;
    g_b2Platen := (sv_Options AND cSubOptionMold2Platen) = cSubOptionMold2Platen;
   
    IF g_b2Platen THEN
       mpbMoldLockStageActive := @sv_bMoldLockStageActive;
    END_IF;
    
    g_bMoldValve := IS_LINKED(ao_Valve);
    mbPropValve := IS_LINKED(sv_rMoldPropValveParams);
    
    abMoveOpen.aRegister();
    abMoveOpen.aInit();
        
    //Initialize Movement Mold Close
    abMoveClose.aRegister();
    abMoveClose.aInit();
    
    //Initialize Movement ICM   
    IF IS_LINKED(sv_ICMMode) THEN
        //Coining
        abMoveCoining.aRegister();
        abMoveCoining.aInit(); 
        
        //Venting
        abMoveVenting.aRegister();
        abMoveVenting.aInit();
    END_IF;                                       
   
    //block for pump calib
    abMovePVCalib.aRegister();
    abMovePVCalib.aInit();
   
    //init calc of hydraulic max values for mold close movement
    abCalcMaxValuesClose.aInit(pRequiredPumps := @sv_RequiredPumpsClose,
                               pHydrMaxValues := @sv_HydrMaxValuesClose);
   
    //init calc of hydraulic max values for mold close movement
    abCalcMaxValuesOpen.aInit(pRequiredPumps := @sv_RequiredPumpsOpen,
                              pHydrMaxValues := @sv_HydrMaxValuesOpen);
   
    IF g_bMoldValve THEN
    // position control
       abPositionController.aInit(pActPosition := @sv_rToggleLeverPosition,
                                  pSetPosition := @sv_rToggleLeverSetPosition,
                                  pSetVelocity := @ao_Valve,
                                  pPositionControlParam := @sv_MoldPosControlParam,
                                  pOperationMode := @sv_OperationMode,
                                  pbDeviceReady := @sv_bDeviceReady,
                                  pLintabOutV := @sv_LintabOutMoldPosCtrl,
                                  pdMaxMoveTime := @sv_dMaxPosCtrlTime,
                                  bFastOutput:= FALSE,
                                  bIgnoreMoveCtrlData := TRUE,
                                  pPositionTolerance := @sv_rPositionTolerance,
                                  pMaxPositionTolerance := @sv_rMaxPositionTolerance);
   
    END_IF;
    mbUseToggleLeverEstimate := sv_DerivationEstimateParToggle.bUseDerivationEstimator;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Starts the algo paRun when sv_bDeviceStart is set by ABControl.
*)

POSTUPDATE_ALGORITHM pDeviceStart ON EV_Task_1 WITH sv_bDeviceStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bDeviceStart THEN
   //start device
   START_PROCESS_ALGORITHM(paRun);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pInitRelLintabUpdater ON PU_Task_7 WITH sv_bInitDone


VAR
 abUpdateRelLintabPreClose : ABUpdateRelLintabPre;
 abUpdateRelLintabVelClose : ABUpdateRelLintabVel;
 abUpdateRelLintabPreOpen : ABUpdateRelLintabPre;
 abUpdateRelLintabVelOpen : ABUpdateRelLintabVel;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abUpdateRelLintabPreClose.aInit(pLintabOut := @sv_LintabOutFwdP,
                                prMaxPressure := @sv_rMaxPressureFwd,
                                prMaxHydrPressure := @sv_HydrMaxValuesClose.rMaxPressure,
                                bUseForce := FALSE,
                                bFwd := TRUE,
                                pCylinderData := @sv_CylinderData);

abUpdateRelLintabVelClose.aInit(pLintabOut := @sv_LintabOutFwdV,
                                prMaxSpeed := @sv_rMaxSpeedFwd,
                                prMaxSpeedCalc := @sv_rMaxSpeedFwdCalc,
                                prMaxSpeedCalib := @sv_rMaxSpeedFwdCalib,
                                prMaxSpeedReducePercent := @sv_rMaxSpeedReducePercent,
                                iMaxSpeedDigitsToFloor := miDigitsToFloor,                                                              
                                prAbsFlow := @sv_HydrMaxValuesClose.rAbsFlow,
                                bFwd := TRUE,
                                pCylinderData := @sv_CylinderData);

abUpdateRelLintabPreOpen.aInit(pLintabOut := @sv_LintabOutBwdP,
                               prMaxPressure := @sv_rMaxPressureBwd,
                               prMaxHydrPressure := @sv_HydrMaxValuesOpen.rMaxPressure,
                               bUseForce := FALSE,
                               bFwd := FALSE,
                               pCylinderData := @sv_CylinderData);

abUpdateRelLintabVelOpen.aInit(pLintabOut := @sv_LintabOutBwdV,
                               prMaxSpeed := @sv_rMaxSpeedBwd,
                               prMaxSpeedCalc := @sv_rMaxSpeedBwdCalc,
                               prMaxSpeedCalib := @sv_rMaxSpeedBwdCalib,
                               prMaxSpeedReducePercent := @sv_rMaxSpeedReducePercent,  
                               iMaxSpeedDigitsToFloor := miDigitsToFloor,                                                             
                               prAbsFlow := @sv_HydrMaxValuesOpen.rAbsFlow,
                               bFwd := FALSE,
                               pCylinderData := @sv_CylinderData);


;#END_EDIT_BLOCK END_ALGORITHM

(*
Calls depending on the MoveId and MoveDir the movementblock. g_MoveCtrl.MoveId/MoveDir are set by the Block ABControl after
evStart was received. The movement-block has to be called until the it returns abMoveXxx.aRun.bReady.
In case of hydraulic movements the output-request has to be done before starting the movement.
*)

PROCESS_ALGORITHM paRun ON TaskAnalog(5000)


VAR_TEMP
 dActiveTime : TIME;
 b : BOOL;
END_VAR

VAR
 abOutputRequest : ABOutputRequest;
 bPumpOutputNeeded : BOOL;
 bModified : BOOL;
 bPumpCalib : BOOL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
Action14 (P);
aStepModeActive (P);
aCheckPumpOutputNeeded (P);
END_STEP

ACTION Action14: #BEGIN_EDIT_BLOCK
b := WRITE_SV_DIRECT(sv_bDeviceStart, sv_bFALSE);

;#END_EDIT_BLOCK END_ACTION (*Action14*)

(* steps *)
STEP OUTPUT_REQUEST:
AOutputRequest (P);
ACheckOutput (N);
END_STEP

ACTION AOutputRequest: #BEGIN_EDIT_BLOCK
abOutputRequest.aRequest(pMoveData := g_MoveCtrl.pData,
                         AnaOutputMode := nAnaOutputModeMid);

;#END_EDIT_BLOCK END_ACTION (*AOutputRequest*)
ACTION ACheckOutput: #BEGIN_EDIT_BLOCK
abOutputRequest.aCheck();

;#END_EDIT_BLOCK END_ACTION (*ACheckOutput*)
STEP OUTPUT:
END_STEP

STEP OPEN:
aOpen (N);
END_STEP

STEP Step15:
ACheckIfCalib (P);
END_STEP

ACTION ACheckIfCalib: #BEGIN_EDIT_BLOCK
bPumpCalib := sv_bDoPumpVelocityCalib OR
              (g_MoveCtrl.pData^.MoveId = cMovePVCalib)

;#END_EDIT_BLOCK END_ACTION (*ACheckIfCalib*)
STEP CLOSE:
aClose (N);
END_STEP

STEP S_PumpCalib:
ACalib (N);
END_STEP

STEP COINING:
aCoining (N);
END_STEP

STEP VENTING:
aVenting (N);
END_STEP

STEP READY:
Action2 (P);
AMovementHistory (P);
END_STEP

ACTION Action2: #BEGIN_EDIT_BLOCK
g_MoveCtrl.bReady := TRUE;
//output release

IF bPumpOutputNeeded THEN     
    abOutputRequest.aRelease(pMoveData := g_MoveCtrl.pData); 
    bPumpOutputNeeded := FALSE; 
END_IF;

IF NOT sv_bDeviceStart THEN
    STOP_PROCESS_ALGORITHM();
END_IF;

;#END_EDIT_BLOCK END_ACTION (*Action2*)

(* transitions *)
GO_ON_TRANSITION Trans12 (* Trans12 *) FROM START TO OUTPUT_REQUEST :=  #BEGIN_EDIT_BLOCK
bPumpOutputNeeded 
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans18 (* Trans18 *) FROM START TO OUTPUT :=  #BEGIN_EDIT_BLOCK
 NOT bPumpOutputNeeded 
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans13 (* Trans13 *) FROM OUTPUT_REQUEST TO READY :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.bStop
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans15 (* Trans15 *) FROM OUTPUT_REQUEST TO OUTPUT :=  #BEGIN_EDIT_BLOCK
abOutputRequest.aCheck.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans9 (* Trans9 *) FROM OUTPUT TO OPEN :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveDir = cMoveBwd 
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans1 (* Trans1 *) FROM OPEN TO READY :=  #BEGIN_EDIT_BLOCK
abMoveOpen.aRun.bReady;
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans2 (* Trans2 *) FROM OUTPUT TO Step15 :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveDir = cMoveFwd
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoPumpCalib (* TNoPumpCalib *) FROM Step15 TO CLOSE :=  #BEGIN_EDIT_BLOCK
NOT bPumpCalib
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans11 (* Trans11 *) FROM CLOSE TO READY :=  #BEGIN_EDIT_BLOCK
abMoveClose.aRun.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPumpCalib (* TPumpCalib *) FROM Step15 TO S_PumpCalib :=  #BEGIN_EDIT_BLOCK
bPumpCalib
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TPumpCalibReady (* TPumpCalibReady *) FROM S_PumpCalib TO READY :=  #BEGIN_EDIT_BLOCK
abMovePVCalib.aRun.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans5 (* Trans5 *) FROM OUTPUT TO COINING :=  #BEGIN_EDIT_BLOCK
(g_MoveCtrl.pData^.MoveDir = cMoveAll)
AND (g_MoveCtrl.pData^.MoveId = cMoveCoining)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans6 (* Trans6 *) FROM COINING TO READY :=  #BEGIN_EDIT_BLOCK
abMoveCoining.aRun.bReady
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans20 (* Trans20 *) FROM OUTPUT TO VENTING :=  #BEGIN_EDIT_BLOCK
(g_MoveCtrl.pData^.MoveDir = cMoveAll)
AND (g_MoveCtrl.pData^.MoveId = cMoveVenting)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans21 (* Trans21 *) FROM VENTING TO READY :=  #BEGIN_EDIT_BLOCK
abMoveVenting.aRun.bReady
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans8 (* Trans8 *) FROM READY TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION aOpen: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoveOpen.aRun(bStop := g_MoveCtrl.bStop);

IF g_MoveCtrl.pData^.MoveId = cMoveBwdInterPos THEN
   dActiveTime := OPEN.T;
   b := WRITE_SV_DIRECT(sv_ActiveTimesOpenInterPos[g_MoveCtrl.iCount], dActiveTime);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aOpen*)
ACTION aClose: #BEGIN_EDIT_BLOCK
abMoveClose.aRun(bStop := g_MoveCtrl.bStop);

IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
   dActiveTime := CLOSE.T;
   b := WRITE_SV_DIRECT(sv_ActiveTimesCloseInterPos[g_MoveCtrl.iCount], dActiveTime);
END_IF;


;#END_EDIT_BLOCK END_ACTION (*aClose*)
ACTION aCoining: #BEGIN_EDIT_BLOCK
abMoveCoining.aRun(bStop := g_MoveCtrl.bStop);

;#END_EDIT_BLOCK END_ACTION (*aCoining*)
ACTION aVenting: #BEGIN_EDIT_BLOCK
abMoveVenting.aRun(bStop := g_MoveCtrl.bStop);

;#END_EDIT_BLOCK END_ACTION (*aVenting*)
ACTION aCheckPumpOutputNeeded: #BEGIN_EDIT_BLOCK
IF IS_LINKED(sv_ICMMode) THEN    
    
    //Venting in sequential 
    IF (g_MoveCtrl.pData^.MoveDir = cMoveAll) 
            AND g_MoveCtrl.pData^.MoveId = cMoveVenting
                 AND sv_ICMMode = nSequentialICM  THEN
            
        bPumpOutputNeeded := TRUE; 
    END_IF; 
    
    //Parallel movement
    IF (g_MoveCtrl.pData^.MoveDir = cMoveAll)   
            AND ((sv_ICMMode = nParallelICM)
                OR ((sv_ICMMode = nSequentialICM) 
                     AND (g_MoveCtrl.pData^.MoveId = cMoveCoining))) THEN
        
        bPumpOutputNeeded := FALSE; 
    END_IF;
    
    //Mold close or open
    IF g_MoveCtrl.pData^.MoveDir <> cMoveAll THEN
        bPumpOutputNeeded := TRUE;
    END_IF;      

    
ELSE 
    //ICM unused 
    IF g_MoveCtrl.pData^.MoveDir <> cMoveAll THEN
        bPumpOutputNeeded := TRUE;
    END_IF;      
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aCheckPumpOutputNeeded*)
ACTION aStepModeActive: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bStepBwdActive THEN
   IF (g_MoveCtrl.pData^.MoveId = cMoveBwd) AND (sv_rBwdInterruptPosition <> 0.0) THEN
      //modify pointer to movedata because otherwise the movement does not stop at interpos
      g_MoveCtrl.pData := @sv_MoveOpenInterPos;
      sv_MoveOpen.pbPosReached := @sv_bStepPosReached;
      bModified := TRUE;
   ELSIF (g_MoveCtrl.pData^.MoveId = cMoveFwd) AND (sv_rFwdInterruptPosition <> 0.0) THEN
      //modify pointer to movedata because otherwise the movement does not stop at interpos
      g_MoveCtrl.pData := @sv_MoveCloseInterPos;
      sv_MoveClose.pbPosReached := @sv_bStepPosReached;
      bModified := TRUE;
   END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aStepModeActive*)
ACTION AMovementHistory: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMovementHistory.aUpdate();

IF bModified THEN
   IF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
      g_MoveCtrl.pData := @sv_MoveClose;   
   ELSIF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
      g_MoveCtrl.pData := @sv_MoveOpen;
   END_IF;
   bModified := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AMovementHistory*)
ACTION ACalib: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMovePVCalib.aRun(bStop := g_MoveCtrl.bStop);

;#END_EDIT_BLOCK END_ACTION (*ACalib*)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcToggleLeverStroke ON PU_Task_7 WITH sv_bInitStart,sv_rMoldStroke,sv_ToggleLeverLintab,sv_MoldLintab


VAR_TEMP
 i : UDINT;
 rY2 : REAL;
END_VAR

VAR
 bInit : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInit THEN
   abLintabToggleLeverStroke.aInit(pLintab := @sv_ToggleLeverLintab, bLinearExtrapolation := TRUE); 
   bInit := TRUE; 
END_IF;
abLintabToggleLeverStroke.aCalcInv(rY := sv_rMoldStroke);
sv_rToggleLeverStroke := abLintabToggleLeverStroke.aCalcInv.rX;

sv_ToggleLeverPosLintab.LintabPoints.uNoOfPoints := sv_MoldLintab.LintabPoints.uNoOfPoints;
FOR i:= 1 TO sv_MoldLintab.LintabPoints.uNoOfPoints DO
   abLintabToggleLeverStroke.aCalcInv(rY := sv_MoldLintab.LintabPoints.Point[i].rY);
   sv_ToggleLeverPosLintab.LintabPoints.Point[i].rY :=abLintabToggleLeverStroke.aCalcInv.rX;
   sv_ToggleLeverPosLintab.LintabPoints.Point[i].rX := sv_MoldLintab.LintabPoints.Point[i].rX;
END_FOR;


// rdl: calculate derivation of toggle lever lintab
sv_ToggleLeverLintabDerive.LintabPoints.uNoOfPoints := sv_ToggleLeverLintab.LintabPoints.uNoOfPoints;
FOR i:=2 TO sv_ToggleLeverLintab.LintabPoints.uNoOfPoints DO
   sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rX := sv_ToggleLeverLintab.LintabPoints.Point[i].rY;
   IF (ABS(sv_ToggleLeverLintab.LintabPoints.Point[i].rX - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rX)> 0.0) THEN
      sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rY := ABS(
         (sv_ToggleLeverLintab.LintabPoints.Point[i].rY - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rY)/
         (sv_ToggleLeverLintab.LintabPoints.Point[i].rX - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rX));
   ELSE
      sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rY := 1.0;
   END_IF;
END_FOR;
sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rX := sv_ToggleLeverLintab.LintabPoints.Point[1].rY;
IF (sv_ToggleLeverLintabDerive.LintabPoints.uNoOfPoints > 1) THEN
   rY2 :=  sv_ToggleLeverLintabDerive.LintabPoints.Point[2].rY;
   sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rY := rY2;
ELSE
   sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rY := 0.0;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pActiveProfileStage ON PU_Task_3 WITH sv_iActiveStage,sv_bDeviceReady,sv_bMoldLockStageActive

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bDeviceReady THEN
   
   IF sv_OperationMode = nSetup THEN
      //mold movement in setup mode active
      //-> reset active stage information
      sv_iActiveStageFwd := 0;
      sv_iActiveStageBwd := 0;
   ELSE
      
      //mold movement in manual - half - or fullauto mode 
      IF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
   
         //reset bwd stage info if fwd movement is started
         sv_iActiveStageBwd := 0; 
         
         IF sv_iActiveStage > 0 THEN
            sv_iActiveStageFwd := sv_iActiveStage;
         END_IF;
         
         IF sv_bMoldLockStageActive THEN
            //mold high pressure stage active
            sv_iActiveStageFwd := UDINT_TO_DINT(sv_MoldFwdProfVis.Profile.iNoOfPoints);
         END_IF;
         
      ELSIF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
         
         //reset Fwd stage info if bwd movement is started
         sv_iActiveStageFwd := 0;
         
         IF sv_iActiveStage > 0 THEN
            sv_iActiveStageBwd := sv_iActiveStage;
         END_IF;
      END_IF;
   END_IF;
   
END_IF;





;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcSplineParameters ON PU_Task_7 WITH sv_ToggleLeverLintab


VAR
 bSensorMissing : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bSensorMissing := (g_bPressureSensor1Available AND NOT g_bPressureSensor2Available) OR 
                  (g_bPressureSensor2Available AND NOT g_bPressureSensor1Available);

IF g_bMoldValve AND bSensorMissing THEN
   //start calculation of spline parameters if a mold valve is available
   //but one pressure sensor is missing
   sv_ToggleLeverSplineData.uNoPoints := 0;
   START_PROCESS_ALGORITHM(paCalcSplineParameters);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCalcSplineParameters ON TaskSlow


VAR
 abLintabAnalysis : ABLintabAnalysis;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//delay calculation until data reading is finished 
IF sv_DataState = nReady  THEN
    
   IF NOT abLintabAnalysis.aPar.bDone OR abLintabAnalysis.aOptimize.bDone OR abLintabAnalysis.aOptimize.bError THEN
      abLintabAnalysis.aPar(LintabData:=sv_ToggleLeverLintab, uNoPoints:=15, uMaxNoIterations:=10000);
   END_IF;
   abLintabAnalysis.aOptimize();
   
   IF abLintabAnalysis.aOptimize.bDone THEN
      sv_ToggleLeverSplineData.rMaxValue := LREAL_TO_REAL(abLintabAnalysis.aOptimize.rMaxValue);
      sv_ToggleLeverSplineData.rInterval := LREAL_TO_REAL(abLintabAnalysis.aOptimize.rInterval);
      sv_ToggleLeverSplineData.rCoefficients := abLintabAnalysis.aOptimize.rCoefficients;
      sv_ToggleLeverSplineData.uNoPoints := abLintabAnalysis.aOptimize.uNoPoints;
      STOP_PROCESS_ALGORITHM();
   ELSIF abLintabAnalysis.aOptimize.bError THEN
      sv_ToggleLeverSplineData.uNoPoints := 0;
      STOP_PROCESS_ALGORITHM();
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCalcCylinderData ON PU_Task_7 WITH sv_CylinderData,sv_ValveData,sv_rMoldPropValveParams

#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   // calc area close -> rPistonArea1 & area open -> rPistonArea2
   IF sv_CylinderData.bUseSmallSize THEN
      // unit [m²]
        sv_ConstructionData.rPistonArea2 := 0.25e-6*EXPT(sv_CylinderData.rCylinderDiameter,2.0)*cApplPlasticsPI;
        sv_ConstructionData.rPistonArea1 := 0.25e-6*(EXPT(sv_CylinderData.rCylinderDiameter,2.0) - EXPT(sv_CylinderData.rPistonRodDiameter,2.0))*cApplPlasticsPI;
        IF sv_ConstructionData.rPistonArea1 < 0.0 THEN
           sv_ConstructionData.rPistonArea1 := 0.0;
        END_IF;
    ELSE
        sv_ConstructionData.rPistonArea2 := 0.25e-6*(EXPT(sv_CylinderData.rCylinderDiameter,2.0) - EXPT(sv_CylinderData.rPistonRodDiameter,2.0))*cApplPlasticsPI;
        IF sv_ConstructionData.rPistonArea2 < 0.0 THEN
           sv_ConstructionData.rPistonArea2 := 0.0;
        END_IF;
        sv_ConstructionData.rPistonArea1 := 0.25e-6*EXPT(sv_CylinderData.rCylinderDiameter,2.0)*cApplPlasticsPI;
    END_IF;
   
   // check valve
   IF IS_LINKED(sv_rMoldPropValveParams) AND
      IS_LINKED(sv_ValveData) THEN
      sv_rMoldPropValveParams.rFlowNominalPA := sv_ValveData.rQNom;
      sv_rMoldPropValveParams.rPressureNominalPA := sv_ValveData.rDeltaPNom;
      sv_rMoldPropValveParams.rFlowNominalPB := sv_ValveData.rQNomPB;
      sv_rMoldPropValveParams.rPressureNominalPB := sv_ValveData.rDeltaPNomPB;
      sv_rMoldPropValveParams.bNominalAsysmmetric := sv_ValveData.bNominalAsysmmetric;
      sv_rMoldPropValveParams.rMaxVoltage := 10.0;
      IF (sv_ValveData.rValveOffsetFwd >= sv_ValveData.rValveOffsetBwd) THEN
         sv_rMoldPropValveParams.rOffsetPA := sv_ValveData.rValveOffsetFwd;
         sv_rMoldPropValveParams.rOffsetPB := sv_ValveData.rValveOffsetBwd;
      ELSE
         sv_rMoldPropValveParams.rOffsetPB := sv_ValveData.rValveOffsetFwd;
         sv_rMoldPropValveParams.rOffsetPA := sv_ValveData.rValveOffsetBwd;
      END_IF;   
   END_IF;
END_IF;
// factor fast close (open)
IF (sv_CylinderData.rPistonRodDiameter > 0.0) THEN
   sv_rFastVelocityFactor := MAX(1.0, EXPT((sv_CylinderData.rCylinderDiameter / sv_CylinderData.rPistonRodDiameter), 2.0));
ELSE
   sv_rFastVelocityFactor := 1.0;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCheckMoldControl ON PU_Task_7 WITH sv_bInitDone


VAR
 Status : KSYS_Status;
END_VAR
#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
    pSysPressure := GET_SYNC_REFTO('Injection1.sv_rActSysPressure', T#0s, Status);
    IF (Status = KSYS_Status_OK) THEN
        g_bPressureSensorsAvailable := g_bPressureSensorsAvailable AND TRUE;
    ELSE    
        g_bPressureSensorsAvailable := FALSE;
    END_IF;
    IF (g_bPressureSensorsAvailable OR mbPropValve) THEN
        IF sv_ServoValveControlData.bEnable AND 
          (sv_ServoValveControlData.rGainDFwd > 0.0) OR (sv_ServoValveControlData.rGainDBwd > 0.0) THEN
            sv_DerivationEstimateParToggle.bUseDerivationEstimator := TRUE;        
        ELSE   
            sv_DerivationEstimateParToggle.bUseDerivationEstimator := mbUseToggleLeverEstimate;
        END_IF;  
    END_IF;
ELSE
   g_bPressureSensorsAvailable := FALSE; 
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCheckController ON PU_Task_7 WITH sv_ServoValveControlData.bEnable,sv_ServoValveControlData.rGainDBwd,sv_ServoValveControlData.rGainDFwd

#BEGIN_EDIT_BLOCK
IF g_bMoldValve THEN
   IF sv_ServoValveControlData.bEnable THEN
      IF (NOT g_bPressureSensorsAvailable) AND (NOT mbPropValve) THEN
         SET_ALARM(erMoldControlSensorNotAvailable);
         sv_ServoValveControlData.bEnable := FALSE;
         //save CPU usage
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := FALSE;
      ELSIF (sv_ServoValveControlData.rGainDFwd > 0.0) OR (sv_ServoValveControlData.rGainDBwd > 0.0) THEN
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := TRUE;
      ELSE   
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := mbUseToggleLeverEstimate;
      END_IF;
   ELSE
      //save CPU usage
      sv_DerivationEstimateParToggle.bUseDerivationEstimator := FALSE;
   END_IF; 
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStepBwdActive ON PU_Task_7 WITH sv_bStepBwdActive

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bStepBwdActive THEN
   //set pos reached flags to original value
   sv_MoveClose.pbPosReached := @sv_bMoldClosed;
   sv_MoveOpen.pbPosReached := @sv_bMoldOpen;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pHighPressureStage ON PU_Task_3 WITH mpbMoldLockStageActive^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//On 2 platen IMM´s the high pressure stage is implemented in TieBars1 - fu, 
//so the sv_bDeviceReady of the Mold1 - fu is TRUE during high pressure stage
//and the postupdate "pActiveProfileStage" will not set the according active stage information.

IF sv_bMoldLockStageActive THEN
   //mold high pressure stage active
   sv_iActiveStageFwd := UDINT_TO_DINT(sv_MoldFwdProfVis.Profile.iNoOfPoints);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 159 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)IS_LINKED @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
16 
@Var @RT(24)cSubOptionMoldDirectLock @RT(0) @T @F @DT @RT(5)DWORD @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(6)16#200 @RT(19)Mold is direct lock 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)nAnaOutputModeMid @RT(0) @T @T @DERIVED 0 @F @RT(15)tnAnaOutputMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMovePVCalib @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)38 @RT(38)injection movement with voltage output 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMaxMoveIdent @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMoveCoining @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)75 @RT(46)coining for the injection compression moulding 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMoveVenting @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)76 @RT(46)venting for the injection compression moulding 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveBwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)16 @RT(38)move backward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveFwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)17 @RT(37)move forward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)nSequentialICM @RT(0) @T @T @DERIVED 0 @F @RT(9)tnICMMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)nParallelICM @RT(0) @T @T @DERIVED 0 @F @RT(9)tnICMMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nReady @RT(0) @T @T @DERIVED 0 @F @RT(11)tnDataState @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cApplPlasticsPI @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(10)3.14159265 @RT(13)pi=3.14159265 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KSYS_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(11)KSYS_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(15)ABMovementAdmin @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
92 
@Var @RT(13)sv_bInitStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bDeviceStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)Start Device @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ToggleLeverLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)lintab for toggle lever pos(x) -> platen pos(y) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_ToggleLeverLintabDerive @RT(0) @T @T @DERIVED 0 @F @RT(16)KAPPL_LintabData @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)derivation calculated from sv_ToggleLeverLintab @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rToggleLeverStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)Opening Stroke of toggle lever @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_rMoldStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)Opening Stroke of Mold @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_ToggleLeverPosLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)KAPPL_LintabData_2P @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)lintab for voltage(x) -> toggle lever pos(y) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_MoldLintab @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)KAPPL_LintabData_2P @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_Options @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)tOptionId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iActiveStage @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_iActiveStageFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)active profile stage mold close (fwd) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_iActiveStageBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)active profile stage mold open (bwd) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bDeviceReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bMoldLockStageActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_MoldFwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)ao_Valve @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_CylinderData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tsCylinderData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ToggleLeverSplineData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsToggleLeverSplineData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_ConstructionData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tServoValveConstructionData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_ServoValveControlData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tServoValveControlData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_MoldPosControlParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tsControlParameters @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rToggleLeverPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_rToggleLeverSetPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rPositionTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rMaxPositionTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_LintabOutMoldPosCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_dMaxPosCtrlTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(30)sv_DerivationEstimateParToggle @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(25)tsDerivationEstimateParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_DataState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tnDataState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_ICMMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)tnICMMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rBwdInterruptPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rFwdInterruptPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoveCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)move forward to intermediate position @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoveOpenInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)move backward to intermediate position @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_MoveClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_MoveOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_bStepBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)TRUE: stepping bwd is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bStepPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(81)TRUE: target position of step bwd movement reached (only needed for stepping bwd) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_bMoldClosed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bMoldOpen @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_ActiveTimesCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondTimeArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_ActiveTimesOpenInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondTimeArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_RequiredPumpsClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_RequiredPumpsOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_HydrMaxValuesClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)hydraulic max values for mold close @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_HydrMaxValuesOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)hydraulic max values for mold open @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxPressureFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxPressureBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bDoPumpVelocityCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_rMaxSpeedFwdCalc @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_rMaxSpeedBwdCalc @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_rMaxSpeedFwdCalib @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_rMaxSpeedBwdCalib @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_rMaxSpeedReducePercent @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)sv_bFALSE @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rMoldPropValveParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsPropValveParams @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_ValveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tServoValveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_rFastVelocityFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_1 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(31)erMoldControlSensorNotAvailable @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(22)g_bDirectLockAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(12)g_bMoldValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensorsAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(12)pSysPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(10)abMoveOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)ABMoveOpen @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)abMoveClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)ABMoveClose @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)abLintabToggleLeverStroke @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)abPositionController @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)ABPositionController @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)mbUseToggleLeverEstimate @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abMoveCoining @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABMoveCoining @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abMoveVenting @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABMoveVenting @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abMovementHistory @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABMovementHistory @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abMovePVCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABMovePVCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)miDigitsToFloor @RT(0) @T @F @DT @RT(4)SINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)2 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)g_bPressureSensor1Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(27)g_bPressureSensor2Available @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(11)mbPropValve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)g_b2Platen @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(22)mpbMoldLockStageActive @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

13 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(10)pInitStart @STRUCTURED_TEXT 
@RT(0) @RT(13)sv_bInitStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(20)abCalcMaxValuesClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)ABCalcHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)abCalcMaxValuesOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)ABCalcHydrMaxValues @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(12)pDeviceStart @STRUCTURED_TEXT 
@RT(0) @RT(15)sv_bDeviceStart @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pInitRelLintabUpdater @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_bInitDone @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(25)abUpdateRelLintabPreClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)ABUpdateRelLintabPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)abUpdateRelLintabVelClose @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)ABUpdateRelLintabVel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)abUpdateRelLintabPreOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)ABUpdateRelLintabPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)abUpdateRelLintabVelOpen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)ABUpdateRelLintabVel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(5)paRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(16)TaskAnalog(5000) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(11)dActiveTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(15)abOutputRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABOutputRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)bPumpOutputNeeded @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bModified @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)bPumpCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pCalcToggleLeverStroke @STRUCTURED_TEXT 
@RT(0) @RT(63)sv_bInitStart,sv_rMoldStroke,sv_ToggleLeverLintab,sv_MoldLintab @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)bInit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(3)rY2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(19)pActiveProfileStage @STRUCTURED_TEXT 
@RT(0) @RT(55)sv_iActiveStage,sv_bDeviceReady,sv_bMoldLockStageActive @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pCalcSplineParameters @STRUCTURED_TEXT 
@RT(0) @RT(20)sv_ToggleLeverLintab @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(14)bSensorMissing @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paCalcSplineParameters @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(16)abLintabAnalysis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)ABLintabAnalysis @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pCalcCylinderData @STRUCTURED_TEXT 
@RT(0) @RT(52)sv_CylinderData,sv_ValveData,sv_rMoldPropValveParams @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pCheckMoldControl @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_bInitDone @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(6)Status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(16)pCheckController @STRUCTURED_TEXT 
@RT(0) @RT(102)sv_ServoValveControlData.bEnable,sv_ServoValveControlData.rGainDBwd,sv_ServoValveControlData.rGainDFwd @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pStepBwdActive @STRUCTURED_TEXT 
@RT(0) @RT(17)sv_bStepBwdActive @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pHighPressureStage @STRUCTURED_TEXT 
@RT(0) @RT(23)mpbMoldLockStageActive^ @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(66)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bInitStart THEN
    //Register Movement Mold Open    
    g_bDirectLockAvailable := (sv_Options AND cSubOptionMoldDirectLock) = cSubOptionMoldDirectLock;
    g_b2Platen := (sv_Options AND cSubOptionMold2Platen) = cSubOptionMold2Platen;
   
    IF g_b2Platen THEN
       mpbMoldLockStageActive := @sv_bMoldLockStageActive;
    END_IF;
    
    g_bMoldValve := IS_LINKED(ao_Valve);
    mbPropValve := IS_LINKED(sv_rMoldPropValveParams);
    
    abMoveOpen.aRegister();
    abMoveOpen.aInit();
        
    //Initialize Movement Mold Close
    abMoveClose.aRegister();
    abMoveClose.aInit();
    
    //Initialize Movement ICM   
    IF IS_LINKED(sv_ICMMode) THEN
        //Coining
        abMoveCoining.aRegister();
        abMoveCoining.aInit(); 
        
        //Venting
        abMoveVenting.aRegister();
        abMoveVenting.aInit();
    END_IF;                                       
   
    //block for pump calib
    abMovePVCalib.aRegister();
    abMovePVCalib.aInit();
   
    //init calc of hydraulic max values for mold close movement
    abCalcMaxValuesClose.aInit(pRequiredPumps := @sv_RequiredPumpsClose,
                               pHydrMaxValues := @sv_HydrMaxValuesClose);
   
    //init calc of hydraulic max values for mold close movement
    abCalcMaxValuesOpen.aInit(pRequiredPumps := @sv_RequiredPumpsOpen,
                              pHydrMaxValues := @sv_HydrMaxValuesOpen);
   
    IF g_bMoldValve THEN
    // position control
       abPositionController.aInit(pActPosition := @sv_rToggleLeverPosition,
                                  pSetPosition := @sv_rToggleLeverSetPosition,
                                  pSetVelocity := @ao_Valve,
                                  pPositionControlParam := @sv_MoldPosControlParam,
                                  pOperationMode := @sv_OperationMode,
                                  pbDeviceReady := @sv_bDeviceReady,
                                  pLintabOutV := @sv_LintabOutMoldPosCtrl,
                                  pdMaxMoveTime := @sv_dMaxPosCtrlTime,
                                  bFastOutput:= FALSE,
                                  bIgnoreMoveCtrlData := TRUE,
                                  pPositionTolerance := @sv_rPositionTolerance,
                                  pMaxPositionTolerance := @sv_rMaxPositionTolerance);
   
    END_IF;
    mbUseToggleLeverEstimate := sv_DerivationEstimateParToggle.bUseDerivationEstimator;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Calls the registration-algo of every movementblock after the deviceregistration succeeded(sv_bInitStart->true)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bDeviceStart THEN
   //start device
   START_PROCESS_ALGORITHM(paRun);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Starts the algo paRun when sv_bDeviceStart is set by ABControl.
@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abUpdateRelLintabPreClose.aInit(pLintabOut := @sv_LintabOutFwdP,
                                prMaxPressure := @sv_rMaxPressureFwd,
                                prMaxHydrPressure := @sv_HydrMaxValuesClose.rMaxPressure,
                                bUseForce := FALSE,
                                bFwd := TRUE,
                                pCylinderData := @sv_CylinderData);

abUpdateRelLintabVelClose.aInit(pLintabOut := @sv_LintabOutFwdV,
                                prMaxSpeed := @sv_rMaxSpeedFwd,
                                prMaxSpeedCalc := @sv_rMaxSpeedFwdCalc,
                                prMaxSpeedCalib := @sv_rMaxSpeedFwdCalib,
                                prMaxSpeedReducePercent := @sv_rMaxSpeedReducePercent,
                                iMaxSpeedDigitsToFloor := miDigitsToFloor,                                                              
                                prAbsFlow := @sv_HydrMaxValuesClose.rAbsFlow,
                                bFwd := TRUE,
                                pCylinderData := @sv_CylinderData);

abUpdateRelLintabPreOpen.aInit(pLintabOut := @sv_LintabOutBwdP,
                               prMaxPressure := @sv_rMaxPressureBwd,
                               prMaxHydrPressure := @sv_HydrMaxValuesOpen.rMaxPressure,
                               bUseForce := FALSE,
                               bFwd := FALSE,
                               pCylinderData := @sv_CylinderData);

abUpdateRelLintabVelOpen.aInit(pLintabOut := @sv_LintabOutBwdV,
                               prMaxSpeed := @sv_rMaxSpeedBwd,
                               prMaxSpeedCalc := @sv_rMaxSpeedBwdCalc,
                               prMaxSpeedCalib := @sv_rMaxSpeedBwdCalib,
                               prMaxSpeedReducePercent := @sv_rMaxSpeedReducePercent,  
                               iMaxSpeedDigitsToFloor := miDigitsToFloor,                                                             
                               prAbsFlow := @sv_HydrMaxValuesOpen.rAbsFlow,
                               bFwd := FALSE,
                               pCylinderData := @sv_CylinderData);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
14 12 17 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 5 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(8)Action14 @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
b := WRITE_SV_DIRECT(sv_bDeviceStart, sv_bFALSE);

@F 
@Acb @RT(15)aStepModeActive @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(22)aCheckPumpOutputNeeded @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans12 @F @T @F @F @T @F @TL(2)
bPumpOutputNeeded 

@RT(7)Trans12 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans18 @F @T @F @F @T @F @TL(2)
 NOT bPumpOutputNeeded 

@RT(7)Trans18 @F 
@Goto @RT(6)OUTPUT @F @F 


@Step @RT(14)OUTPUT_REQUEST @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(14)AOutputRequest @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
abOutputRequest.aRequest(pMoveData := g_MoveCtrl.pData,
                         AnaOutputMode := nAnaOutputModeMid);

@F 
@Acb @RT(12)ACheckOutput @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
abOutputRequest.aCheck();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans13 @F @T @F @F @T @T @TL(2)
g_MoveCtrl.bStop

@RT(7)Trans13 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(7)Trans15 @F @T @F @F @T @F @TL(2)
abOutputRequest.aCheck.bReady

@RT(7)Trans15 @F 
@Step @RT(6)OUTPUT @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 4 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)Trans9 @F @T @F @F @T @F @TL(2)
g_MoveCtrl.pData^.MoveDir = cMoveBwd 

@RT(6)Trans9 @F 
@Step @RT(4)OPEN @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)aOpen @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(6)Trans1 @F @T @F @F @T @F @TL(2)
abMoveOpen.aRun.bReady;

@RT(6)Trans1 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)Trans2 @F @T @F @F @T @F @TL(2)
g_MoveCtrl.pData^.MoveDir = cMoveFwd

@RT(6)Trans2 @F 
@Step @RT(6)Step15 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)ACheckIfCalib @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
bPumpCalib := sv_bDoPumpVelocityCalib OR
              (g_MoveCtrl.pData^.MoveId = cMovePVCalib)

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(12)TNoPumpCalib @F @T @F @F @T @F @TL(2)
NOT bPumpCalib

@RT(12)TNoPumpCalib @F 
@Step @RT(5)CLOSE @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)aClose @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans11 @F @T @F @F @T @F @TL(2)
abMoveClose.aRun.bReady

@RT(7)Trans11 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TPumpCalib @F @T @F @F @T @F @TL(2)
bPumpCalib

@RT(10)TPumpCalib @F 
@Step @RT(11)S_PumpCalib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)ACalib @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TPumpCalibReady @F @T @F @F @T @T @TL(2)
abMovePVCalib.aRun.bReady

@RT(15)TPumpCalibReady @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)Trans5 @F @T @F @F @T @F @TL(3)
(g_MoveCtrl.pData^.MoveDir = cMoveAll)
AND (g_MoveCtrl.pData^.MoveId = cMoveCoining)

@RT(6)Trans5 @F 
@Step @RT(7)COINING @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)aCoining @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(6)Trans6 @F @T @F @F @T @F @TL(2)
abMoveCoining.aRun.bReady

@RT(6)Trans6 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(7)Trans20 @F @T @F @F @T @F @TL(3)
(g_MoveCtrl.pData^.MoveDir = cMoveAll)
AND (g_MoveCtrl.pData^.MoveId = cMoveVenting)

@RT(7)Trans20 @F 
@Step @RT(7)VENTING @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)aVenting @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans21 @F @T @F @F @T @F @TL(2)
abMoveVenting.aRun.bReady

@RT(7)Trans21 @F 




@Step @RT(5)READY @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(7)Action2 @F @T @RT(1)P @RT(0) @F @F @T @TL(12)
g_MoveCtrl.bReady := TRUE;
//output release

IF bPumpOutputNeeded THEN     
    abOutputRequest.aRelease(pMoveData := g_MoveCtrl.pData); 
    bPumpOutputNeeded := FALSE; 
END_IF;

IF NOT sv_bDeviceStart THEN
    STOP_PROCESS_ALGORITHM();
END_IF;

@F 
@Acb @RT(16)AMovementHistory @F @F @RT(1)P @RT(0) @F @F @F @F 


@Trans @RT(6)Trans8 @F @T @F @T @T @T @TL(2)
TRUE

@RT(6)Trans8 @F 

@END_SfcData 
@SaActions 8 
@SaText @RT(5)aOpen 1 @TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMoveOpen.aRun(bStop := g_MoveCtrl.bStop);

IF g_MoveCtrl.pData^.MoveId = cMoveBwdInterPos THEN
   dActiveTime := OPEN.T;
   b := WRITE_SV_DIRECT(sv_ActiveTimesOpenInterPos[g_MoveCtrl.iCount], dActiveTime);
END_IF;


@SaText @RT(6)aClose 1 @TL(8)
abMoveClose.aRun(bStop := g_MoveCtrl.bStop);

IF g_MoveCtrl.pData^.MoveId = cMoveFwdInterPos THEN
   dActiveTime := CLOSE.T;
   b := WRITE_SV_DIRECT(sv_ActiveTimesCloseInterPos[g_MoveCtrl.iCount], dActiveTime);
END_IF;



@SaText @RT(8)aCoining 1 @TL(2)
abMoveCoining.aRun(bStop := g_MoveCtrl.bStop);


@SaText @RT(8)aVenting 1 @TL(2)
abMoveVenting.aRun(bStop := g_MoveCtrl.bStop);


@SaText @RT(22)aCheckPumpOutputNeeded 1 @TL(32)
IF IS_LINKED(sv_ICMMode) THEN    
    
    //Venting in sequential 
    IF (g_MoveCtrl.pData^.MoveDir = cMoveAll) 
            AND g_MoveCtrl.pData^.MoveId = cMoveVenting
                 AND sv_ICMMode = nSequentialICM  THEN
            
        bPumpOutputNeeded := TRUE; 
    END_IF; 
    
    //Parallel movement
    IF (g_MoveCtrl.pData^.MoveDir = cMoveAll)   
            AND ((sv_ICMMode = nParallelICM)
                OR ((sv_ICMMode = nSequentialICM) 
                     AND (g_MoveCtrl.pData^.MoveId = cMoveCoining))) THEN
        
        bPumpOutputNeeded := FALSE; 
    END_IF;
    
    //Mold close or open
    IF g_MoveCtrl.pData^.MoveDir <> cMoveAll THEN
        bPumpOutputNeeded := TRUE;
    END_IF;      

    
ELSE 
    //ICM unused 
    IF g_MoveCtrl.pData^.MoveDir <> cMoveAll THEN
        bPumpOutputNeeded := TRUE;
    END_IF;      
END_IF;


@SaText @RT(15)aStepModeActive 1 @TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bStepBwdActive THEN
   IF (g_MoveCtrl.pData^.MoveId = cMoveBwd) AND (sv_rBwdInterruptPosition <> 0.0) THEN
      //modify pointer to movedata because otherwise the movement does not stop at interpos
      g_MoveCtrl.pData := @sv_MoveOpenInterPos;
      sv_MoveOpen.pbPosReached := @sv_bStepPosReached;
      bModified := TRUE;
   ELSIF (g_MoveCtrl.pData^.MoveId = cMoveFwd) AND (sv_rFwdInterruptPosition <> 0.0) THEN
      //modify pointer to movedata because otherwise the movement does not stop at interpos
      g_MoveCtrl.pData := @sv_MoveCloseInterPos;
      sv_MoveClose.pbPosReached := @sv_bStepPosReached;
      bModified := TRUE;
   END_IF;
END_IF;


@SaText @RT(16)AMovementHistory 1 @TL(16)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMovementHistory.aUpdate();

IF bModified THEN
   IF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
      g_MoveCtrl.pData := @sv_MoveClose;   
   ELSIF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
      g_MoveCtrl.pData := @sv_MoveOpen;
   END_IF;
   bModified := FALSE;
END_IF;


@SaText @RT(6)ACalib 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abMovePVCalib.aRun(bStop := g_MoveCtrl.bStop);


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(3)
Calls depending on the MoveId and MoveDir the movementblock. g_MoveCtrl.MoveId/MoveDir are set by the Block ABControl after
evStart was received. The movement-block has to be called until the it returns abMoveXxx.aRun.bReady.
In case of hydraulic movements the output-request has to be done before starting the movement.
@@@END_Comment@@@ 

@BEG_Body 
@TL(41)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInit THEN
   abLintabToggleLeverStroke.aInit(pLintab := @sv_ToggleLeverLintab, bLinearExtrapolation := TRUE); 
   bInit := TRUE; 
END_IF;
abLintabToggleLeverStroke.aCalcInv(rY := sv_rMoldStroke);
sv_rToggleLeverStroke := abLintabToggleLeverStroke.aCalcInv.rX;

sv_ToggleLeverPosLintab.LintabPoints.uNoOfPoints := sv_MoldLintab.LintabPoints.uNoOfPoints;
FOR i:= 1 TO sv_MoldLintab.LintabPoints.uNoOfPoints DO
   abLintabToggleLeverStroke.aCalcInv(rY := sv_MoldLintab.LintabPoints.Point[i].rY);
   sv_ToggleLeverPosLintab.LintabPoints.Point[i].rY :=abLintabToggleLeverStroke.aCalcInv.rX;
   sv_ToggleLeverPosLintab.LintabPoints.Point[i].rX := sv_MoldLintab.LintabPoints.Point[i].rX;
END_FOR;


// rdl: calculate derivation of toggle lever lintab
sv_ToggleLeverLintabDerive.LintabPoints.uNoOfPoints := sv_ToggleLeverLintab.LintabPoints.uNoOfPoints;
FOR i:=2 TO sv_ToggleLeverLintab.LintabPoints.uNoOfPoints DO
   sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rX := sv_ToggleLeverLintab.LintabPoints.Point[i].rY;
   IF (ABS(sv_ToggleLeverLintab.LintabPoints.Point[i].rX - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rX)> 0.0) THEN
      sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rY := ABS(
         (sv_ToggleLeverLintab.LintabPoints.Point[i].rY - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rY)/
         (sv_ToggleLeverLintab.LintabPoints.Point[i].rX - sv_ToggleLeverLintab.LintabPoints.Point[i-1].rX));
   ELSE
      sv_ToggleLeverLintabDerive.LintabPoints.Point[i].rY := 1.0;
   END_IF;
END_FOR;
sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rX := sv_ToggleLeverLintab.LintabPoints.Point[1].rY;
IF (sv_ToggleLeverLintabDerive.LintabPoints.uNoOfPoints > 1) THEN
   rY2 :=  sv_ToggleLeverLintabDerive.LintabPoints.Point[2].rY;
   sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rY := rY2;
ELSE
   sv_ToggleLeverLintabDerive.LintabPoints.Point[1].rY := 0.0;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(45)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bDeviceReady THEN
   
   IF sv_OperationMode = nSetup THEN
      //mold movement in setup mode active
      //-> reset active stage information
      sv_iActiveStageFwd := 0;
      sv_iActiveStageBwd := 0;
   ELSE
      
      //mold movement in manual - half - or fullauto mode 
      IF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
   
         //reset bwd stage info if fwd movement is started
         sv_iActiveStageBwd := 0; 
         
         IF sv_iActiveStage > 0 THEN
            sv_iActiveStageFwd := sv_iActiveStage;
         END_IF;
         
         IF sv_bMoldLockStageActive THEN
            //mold high pressure stage active
            sv_iActiveStageFwd := UDINT_TO_DINT(sv_MoldFwdProfVis.Profile.iNoOfPoints);
         END_IF;
         
      ELSIF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
         
         //reset Fwd stage info if bwd movement is started
         sv_iActiveStageFwd := 0;
         
         IF sv_iActiveStage > 0 THEN
            sv_iActiveStageBwd := sv_iActiveStage;
         END_IF;
      END_IF;
   END_IF;
   
END_IF;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bSensorMissing := (g_bPressureSensor1Available AND NOT g_bPressureSensor2Available) OR 
                  (g_bPressureSensor2Available AND NOT g_bPressureSensor1Available);

IF g_bMoldValve AND bSensorMissing THEN
   //start calculation of spline parameters if a mold valve is available
   //but one pressure sensor is missing
   sv_ToggleLeverSplineData.uNoPoints := 0;
   START_PROCESS_ALGORITHM(paCalcSplineParameters);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//delay calculation until data reading is finished 
IF sv_DataState = nReady  THEN
    
   IF NOT abLintabAnalysis.aPar.bDone OR abLintabAnalysis.aOptimize.bDone OR abLintabAnalysis.aOptimize.bError THEN
      abLintabAnalysis.aPar(LintabData:=sv_ToggleLeverLintab, uNoPoints:=15, uMaxNoIterations:=10000);
   END_IF;
   abLintabAnalysis.aOptimize();
   
   IF abLintabAnalysis.aOptimize.bDone THEN
      sv_ToggleLeverSplineData.rMaxValue := LREAL_TO_REAL(abLintabAnalysis.aOptimize.rMaxValue);
      sv_ToggleLeverSplineData.rInterval := LREAL_TO_REAL(abLintabAnalysis.aOptimize.rInterval);
      sv_ToggleLeverSplineData.rCoefficients := abLintabAnalysis.aOptimize.rCoefficients;
      sv_ToggleLeverSplineData.uNoPoints := abLintabAnalysis.aOptimize.uNoPoints;
      STOP_PROCESS_ALGORITHM();
   ELSIF abLintabAnalysis.aOptimize.bError THEN
      sv_ToggleLeverSplineData.uNoPoints := 0;
      STOP_PROCESS_ALGORITHM();
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(42)
IF g_bMoldValve THEN
   // calc area close -> rPistonArea1 & area open -> rPistonArea2
   IF sv_CylinderData.bUseSmallSize THEN
      // unit [m²]
        sv_ConstructionData.rPistonArea2 := 0.25e-6*EXPT(sv_CylinderData.rCylinderDiameter,2.0)*cApplPlasticsPI;
        sv_ConstructionData.rPistonArea1 := 0.25e-6*(EXPT(sv_CylinderData.rCylinderDiameter,2.0) - EXPT(sv_CylinderData.rPistonRodDiameter,2.0))*cApplPlasticsPI;
        IF sv_ConstructionData.rPistonArea1 < 0.0 THEN
           sv_ConstructionData.rPistonArea1 := 0.0;
        END_IF;
    ELSE
        sv_ConstructionData.rPistonArea2 := 0.25e-6*(EXPT(sv_CylinderData.rCylinderDiameter,2.0) - EXPT(sv_CylinderData.rPistonRodDiameter,2.0))*cApplPlasticsPI;
        IF sv_ConstructionData.rPistonArea2 < 0.0 THEN
           sv_ConstructionData.rPistonArea2 := 0.0;
        END_IF;
        sv_ConstructionData.rPistonArea1 := 0.25e-6*EXPT(sv_CylinderData.rCylinderDiameter,2.0)*cApplPlasticsPI;
    END_IF;
   
   // check valve
   IF IS_LINKED(sv_rMoldPropValveParams) AND
      IS_LINKED(sv_ValveData) THEN
      sv_rMoldPropValveParams.rFlowNominalPA := sv_ValveData.rQNom;
      sv_rMoldPropValveParams.rPressureNominalPA := sv_ValveData.rDeltaPNom;
      sv_rMoldPropValveParams.rFlowNominalPB := sv_ValveData.rQNomPB;
      sv_rMoldPropValveParams.rPressureNominalPB := sv_ValveData.rDeltaPNomPB;
      sv_rMoldPropValveParams.bNominalAsysmmetric := sv_ValveData.bNominalAsysmmetric;
      sv_rMoldPropValveParams.rMaxVoltage := 10.0;
      IF (sv_ValveData.rValveOffsetFwd >= sv_ValveData.rValveOffsetBwd) THEN
         sv_rMoldPropValveParams.rOffsetPA := sv_ValveData.rValveOffsetFwd;
         sv_rMoldPropValveParams.rOffsetPB := sv_ValveData.rValveOffsetBwd;
      ELSE
         sv_rMoldPropValveParams.rOffsetPB := sv_ValveData.rValveOffsetFwd;
         sv_rMoldPropValveParams.rOffsetPA := sv_ValveData.rValveOffsetBwd;
      END_IF;   
   END_IF;
END_IF;
// factor fast close (open)
IF (sv_CylinderData.rPistonRodDiameter > 0.0) THEN
   sv_rFastVelocityFactor := MAX(1.0, EXPT((sv_CylinderData.rCylinderDiameter / sv_CylinderData.rPistonRodDiameter), 2.0));
ELSE
   sv_rFastVelocityFactor := 1.0;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
IF g_bMoldValve THEN
    pSysPressure := GET_SYNC_REFTO('Injection1.sv_rActSysPressure', T#0s, Status);
    IF (Status = KSYS_Status_OK) THEN
        g_bPressureSensorsAvailable := g_bPressureSensorsAvailable AND TRUE;
    ELSE    
        g_bPressureSensorsAvailable := FALSE;
    END_IF;
    IF (g_bPressureSensorsAvailable OR mbPropValve) THEN
        IF sv_ServoValveControlData.bEnable AND 
          (sv_ServoValveControlData.rGainDFwd > 0.0) OR (sv_ServoValveControlData.rGainDBwd > 0.0) THEN
            sv_DerivationEstimateParToggle.bUseDerivationEstimator := TRUE;        
        ELSE   
            sv_DerivationEstimateParToggle.bUseDerivationEstimator := mbUseToggleLeverEstimate;
        END_IF;  
    END_IF;
ELSE
   g_bPressureSensorsAvailable := FALSE; 
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
IF g_bMoldValve THEN
   IF sv_ServoValveControlData.bEnable THEN
      IF (NOT g_bPressureSensorsAvailable) AND (NOT mbPropValve) THEN
         SET_ALARM(erMoldControlSensorNotAvailable);
         sv_ServoValveControlData.bEnable := FALSE;
         //save CPU usage
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := FALSE;
      ELSIF (sv_ServoValveControlData.rGainDFwd > 0.0) OR (sv_ServoValveControlData.rGainDBwd > 0.0) THEN
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := TRUE;
      ELSE   
         sv_DerivationEstimateParToggle.bUseDerivationEstimator := mbUseToggleLeverEstimate;
      END_IF;
   ELSE
      //save CPU usage
      sv_DerivationEstimateParToggle.bUseDerivationEstimator := FALSE;
   END_IF; 
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bStepBwdActive THEN
   //set pos reached flags to original value
   sv_MoveClose.pbPosReached := @sv_bMoldClosed;
   sv_MoveOpen.pbPosReached := @sv_bMoldOpen;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//On 2 platen IMM´s the high pressure stage is implemented in TieBars1 - fu, 
//so the sv_bDeviceReady of the Mold1 - fu is TRUE during high pressure stage
//and the postupdate "pActiveProfileStage" will not set the according active stage information.

IF sv_bMoldLockStageActive THEN
   //mold high pressure stage active
   sv_iActiveStageFwd := UDINT_TO_DINT(sv_MoldFwdProfVis.Profile.iNoOfPoints);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
